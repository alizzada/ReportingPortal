{"ast":null,"code":"import _toConsumableArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _get from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/appointmentSettingsGenerator.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../core/utils/date\";\nimport { isEmptyObject } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { getRecurrenceProcessor } from \"./recurrence\";\nimport timeZoneUtils from \"./utils.timeZone.js\";\nvar toMs = dateUtils.dateToMilliseconds;\nexport var AppointmentSettingsGenerator = /*#__PURE__*/function () {\n  function AppointmentSettingsGenerator(scheduler) {\n    _classCallCheck(this, AppointmentSettingsGenerator);\n\n    this.scheduler = scheduler;\n    this.settingsStrategy = this.scheduler.isVirtualScrolling() ? new AppointmentSettingsGeneratorVirtualStrategy(this.scheduler) : new AppointmentSettingsGeneratorBaseStrategy(this.scheduler);\n  }\n\n  _createClass(AppointmentSettingsGenerator, [{\n    key: \"create\",\n    value: function create(rawAppointment) {\n      return this.settingsStrategy.create(rawAppointment);\n    }\n  }]);\n\n  return AppointmentSettingsGenerator;\n}();\nexport var AppointmentSettingsGeneratorBaseStrategy = /*#__PURE__*/function () {\n  function AppointmentSettingsGeneratorBaseStrategy(scheduler) {\n    _classCallCheck(this, AppointmentSettingsGeneratorBaseStrategy);\n\n    this.scheduler = scheduler;\n  }\n\n  _createClass(AppointmentSettingsGeneratorBaseStrategy, [{\n    key: \"timeZoneCalculator\",\n    get: function get() {\n      return this.scheduler.timeZoneCalculator;\n    }\n  }, {\n    key: \"workspace\",\n    get: function get() {\n      return this.scheduler.getWorkSpace();\n    }\n  }, {\n    key: \"viewDataProvider\",\n    get: function get() {\n      return this.workspace.viewDataProvider;\n    }\n  }, {\n    key: \"create\",\n    value: function create(rawAppointment) {\n      var scheduler = this.scheduler;\n      var appointment = scheduler.createAppointmentAdapter(rawAppointment);\n\n      var itemResources = scheduler._resourcesManager.getResourcesFromItem(rawAppointment);\n\n      var isAllDay = this._isAllDayAppointment(rawAppointment);\n\n      var appointmentList = this._createAppointments(appointment, itemResources);\n\n      appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointment);\n\n      if (this._canProcessNotNativeTimezoneDates(appointment)) {\n        appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointment);\n      }\n\n      var gridAppointmentList = this._createGridAppointmentList(appointmentList, appointment);\n\n      gridAppointmentList = this._cropAppointmentsByStartDayHour(gridAppointmentList, rawAppointment, isAllDay);\n      gridAppointmentList = this._getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment);\n      var appointmentInfos = this.createAppointmentInfos(gridAppointmentList, itemResources, isAllDay, appointment.isRecurrent);\n      return appointmentInfos;\n    }\n  }, {\n    key: \"_getProcessedByAppointmentTimeZone\",\n    value: function _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\n      var _this2 = this;\n\n      var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\n\n      if (appointmentList.length > 1 && hasAppointmentTimeZone) {\n        var appointmentOffsets = {\n          startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\n          endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\n        };\n        appointmentList.forEach(function (a) {\n          var sourceOffsets_startDate = _this2.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\n              sourceOffsets_endDate = _this2.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\n\n          var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\n          var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\n\n          if (0 !== startDateOffsetDiff) {\n            a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"));\n          }\n\n          if (0 !== endDateOffsetDiff) {\n            a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"));\n          }\n        });\n      }\n\n      return appointmentList;\n    }\n  }, {\n    key: \"_isAllDayAppointment\",\n    value: function _isAllDayAppointment(rawAppointment) {\n      return this.scheduler.appointmentTakesAllDay(rawAppointment) && this.workspace.supportAllDayRow();\n    }\n  }, {\n    key: \"_createAppointments\",\n    value: function _createAppointments(appointment, resources) {\n      var appointments = this._createRecurrenceAppointments(appointment, resources);\n\n      if (!appointment.isRecurrent && 0 === appointments.length) {\n        appointments.push({\n          startDate: appointment.startDate,\n          endDate: appointment.endDate\n        });\n      }\n\n      appointments = appointments.map(function (item) {\n        var _item$endDate;\n\n        var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\n\n        if (item.startDate.getTime() === resultEndTime) {\n          item.endDate.setTime(resultEndTime + toMs(\"minute\"));\n        }\n\n        return _extends({}, item, {\n          exceptionDate: new Date(item.startDate)\n        });\n      });\n      return appointments;\n    }\n  }, {\n    key: \"_canProcessNotNativeTimezoneDates\",\n    value: function _canProcessNotNativeTimezoneDates(appointment) {\n      var timeZoneName = this.scheduler.option(\"timeZone\");\n      var isTimeZoneSet = !isEmptyObject(timeZoneName);\n\n      if (!isTimeZoneSet) {\n        return false;\n      }\n\n      if (!appointment.isRecurrent) {\n        return false;\n      }\n\n      return !timeZoneUtils.isEqualLocalTimeZone(timeZoneName, appointment.startDate);\n    }\n  }, {\n    key: \"_getProcessedNotNativeDateIfCrossDST\",\n    value: function _getProcessedNotNativeDateIfCrossDST(date, offset) {\n      if (offset < 0) {\n        var newDate = new Date(date);\n        var newDateMinusOneHour = new Date(newDate);\n        newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\n        var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\n        var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\n\n        if (newDateOffset !== newDateMinusOneHourOffset) {\n          return 0;\n        }\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"_getProcessedNotNativeTimezoneDates\",\n    value: function _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\n      var _this3 = this;\n\n      var startDateRange = appointment.startDate;\n      var endDateRange = appointmentList[appointmentList.length - 1].endDate;\n      var startDateRangeOffset = this.timeZoneCalculator.getOffsets(startDateRange).common;\n      var endDateRangeOffset = this.timeZoneCalculator.getOffsets(endDateRange).common;\n      var isChangeOffsetInRange = startDateRangeOffset !== endDateRangeOffset;\n\n      if (isChangeOffsetInRange) {\n        return appointmentList.map(function (item) {\n          var diffStartDateOffset = _this3.timeZoneCalculator.getOffsets(appointment.startDate).common - _this3.timeZoneCalculator.getOffsets(item.startDate).common;\n\n          var diffEndDateOffset = _this3.timeZoneCalculator.getOffsets(appointment.endDate).common - _this3.timeZoneCalculator.getOffsets(item.endDate).common;\n\n          diffStartDateOffset = _this3._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\n          diffEndDateOffset = _this3._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\n          var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\n          var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\n\n          var testNewStartDate = _this3.timeZoneCalculator.createDate(newStartDate, {\n            path: \"toGrid\"\n          });\n\n          var testNewEndDate = _this3.timeZoneCalculator.createDate(newEndDate, {\n            path: \"toGrid\"\n          });\n\n          if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\n            newEndDate = new Date(newStartDate.getTime() + appointment.duration);\n          }\n\n          return _extends({}, item, {\n            startDate: newStartDate,\n            endDate: newEndDate,\n            exceptionDate: new Date(newStartDate)\n          });\n        });\n      }\n\n      return appointmentList;\n    }\n  }, {\n    key: \"_getProcessedLongAppointmentsIfRequired\",\n    value: function _getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment) {\n      var _this4 = this;\n\n      var rawAppointment = appointment.source();\n      var allDay = this.scheduler.appointmentTakesAllDay(rawAppointment);\n      var dateRange = this.workspace.getDateRange();\n      var renderingStrategy = this.scheduler.getLayoutManager().getRenderingStrategyInstance();\n\n      if (renderingStrategy.needSeparateAppointment(allDay)) {\n        var longStartDateParts = [];\n        var resultDates = [];\n        gridAppointmentList.forEach(function (gridAppointment) {\n          var maxDate = new Date(dateRange[1]);\n          var endDateOfPart = renderingStrategy.normalizeEndDateByViewEnd(rawAppointment, gridAppointment.endDate);\n          longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\n            milliseconds: _this4.scheduler.getWorkSpace().getIntervalDuration(allDay)\n          });\n          var list = longStartDateParts.filter(function (startDatePart) {\n            return new Date(startDatePart) < maxDate;\n          }).map(function (date) {\n            return {\n              startDate: date,\n              endDate: new Date(new Date(date).setMilliseconds(appointment.duration)),\n              source: gridAppointment.source\n            };\n          });\n          resultDates = resultDates.concat(list);\n        });\n        gridAppointmentList = resultDates;\n      }\n\n      return gridAppointmentList;\n    }\n  }, {\n    key: \"_createGridAppointmentList\",\n    value: function _createGridAppointmentList(appointmentList, appointment) {\n      var _this5 = this;\n\n      return appointmentList.map(function (source) {\n        var offsetDifference = appointment.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\n\n        if (0 !== offsetDifference && _this5._canProcessNotNativeTimezoneDates(appointment)) {\n          source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\n          source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\n          source.exceptionDate = new Date(source.startDate);\n        }\n\n        var startDate = _this5.timeZoneCalculator.createDate(source.startDate, {\n          path: \"toGrid\"\n        });\n\n        var endDate = _this5.timeZoneCalculator.createDate(source.endDate, {\n          path: \"toGrid\"\n        });\n\n        return {\n          startDate: startDate,\n          endDate: endDate,\n          source: source\n        };\n      });\n    }\n  }, {\n    key: \"_createExtremeRecurrenceDates\",\n    value: function _createExtremeRecurrenceDates(rawAppointment) {\n      var dateRange = this.scheduler._workSpace.getDateRange();\n\n      var startViewDate = this.scheduler.appointmentTakesAllDay(rawAppointment) ? dateUtils.trimTime(dateRange[0]) : dateRange[0];\n      var endViewDate = dateRange[1];\n      var commonTimeZone = this.scheduler.option(\"timeZone\");\n\n      if (commonTimeZone) {\n        startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\n          path: \"fromGrid\"\n        });\n        endViewDate = this.timeZoneCalculator.createDate(endViewDate, {\n          path: \"fromGrid\"\n        });\n        var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDate);\n\n        if (daylightOffset) {\n          endViewDate = new Date(endViewDate.getTime() + daylightOffset);\n        }\n      }\n\n      return [startViewDate, endViewDate];\n    }\n  }, {\n    key: \"_createRecurrenceOptions\",\n    value: function _createRecurrenceOptions(appointment, groupIndex) {\n      var _this6 = this;\n\n      var _this$_createExtremeR = this._createExtremeRecurrenceDates(appointment.source(), groupIndex),\n          _this$_createExtremeR2 = _slicedToArray(_this$_createExtremeR, 2),\n          minRecurrenceDate = _this$_createExtremeR2[0],\n          maxRecurrenceDate = _this$_createExtremeR2[1];\n\n      return {\n        rule: appointment.recurrenceRule,\n        exception: appointment.recurrenceException,\n        min: minRecurrenceDate,\n        max: maxRecurrenceDate,\n        firstDayOfWeek: this.scheduler.getFirstDayOfWeek(),\n        start: appointment.startDate,\n        end: appointment.endDate,\n        getPostProcessedException: function getPostProcessedException(date) {\n          var timeZoneName = _this6.scheduler.option(\"timeZone\");\n\n          if (isEmptyObject(timeZoneName) || timeZoneUtils.isEqualLocalTimeZone(timeZoneName, date)) {\n            return date;\n          }\n\n          var appointmentOffset = _this6.timeZoneCalculator.getOffsets(appointment.startDate).common;\n\n          var exceptionAppointmentOffset = _this6.timeZoneCalculator.getOffsets(date).common;\n\n          var diff = appointmentOffset - exceptionAppointmentOffset;\n          diff = _this6._getProcessedNotNativeDateIfCrossDST(date, diff);\n          return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"));\n        }\n      };\n    }\n  }, {\n    key: \"_createRecurrenceAppointments\",\n    value: function _createRecurrenceAppointments(appointment, resources) {\n      var duration = appointment.duration;\n\n      var option = this._createRecurrenceOptions(appointment);\n\n      var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n      return generatedStartDates.map(function (date) {\n        var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n        utcDate.setTime(utcDate.getTime() + duration);\n        var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n        return {\n          startDate: new Date(date),\n          endDate: endDate\n        };\n      });\n    }\n  }, {\n    key: \"_cropAppointmentsByStartDayHour\",\n    value: function _cropAppointmentsByStartDayHour(appointments, rawAppointment, isAllDay) {\n      var _this7 = this;\n\n      return appointments.map(function (appointment) {\n        var startDate = new Date(appointment.startDate);\n\n        var firstViewDate = _this7._getAppointmentFirstViewDate(appointment, rawAppointment);\n\n        var startDayHour = _this7._getViewStartDayHour(firstViewDate);\n\n        appointment.startDate = _this7._getAppointmentResultDate({\n          appointment: appointment,\n          rawAppointment: rawAppointment,\n          startDate: startDate,\n          startDayHour: startDayHour,\n          firstViewDate: firstViewDate\n        });\n        return appointment;\n      });\n    }\n  }, {\n    key: \"_getAppointmentFirstViewDate\",\n    value: function _getAppointmentFirstViewDate() {\n      return this.scheduler.getStartViewDate();\n    }\n  }, {\n    key: \"_getViewStartDayHour\",\n    value: function _getViewStartDayHour() {\n      return this.scheduler._getCurrentViewOption(\"startDayHour\");\n    }\n  }, {\n    key: \"_getAppointmentResultDate\",\n    value: function _getAppointmentResultDate(options) {\n      var appointment = options.appointment,\n          rawAppointment = options.rawAppointment,\n          startDayHour = options.startDayHour,\n          firstViewDate = options.firstViewDate;\n      var startDate = options.startDate;\n      var resultDate = new Date(appointment.startDate);\n\n      if (this.scheduler.appointmentTakesAllDay(rawAppointment)) {\n        resultDate = dateUtils.normalizeDate(startDate, firstViewDate);\n      } else {\n        if (startDate < firstViewDate) {\n          startDate = firstViewDate;\n        }\n\n        resultDate = dateUtils.normalizeDate(appointment.startDate, startDate);\n      }\n\n      return dateUtils.roundDateByStartDayHour(resultDate, startDayHour);\n    }\n  }, {\n    key: \"createAppointmentInfos\",\n    value: function createAppointmentInfos(gridAppointments, resources, isAllDay, recurrent) {\n      var _this = this;\n\n      var result = [];\n\n      var _loop = function _loop(i) {\n        var appointment = gridAppointments[i];\n\n        var coordinates = _this.getCoordinates({\n          appointment: appointment,\n          resources: resources,\n          isAllDay: isAllDay,\n          recurrent: recurrent\n        });\n\n        coordinates.forEach(function (coordinate) {\n          extend(coordinate, {\n            info: {\n              appointment: gridAppointments[i],\n              sourceAppointment: gridAppointments[i].source\n            }\n          });\n        });\n        result = result.concat(coordinates);\n      };\n\n      for (var i = 0; i < gridAppointments.length; i++) {\n        _loop(i);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getCoordinates\",\n    value: function getCoordinates(options) {\n      var appointment = options.appointment,\n          resources = options.resources,\n          isAllDay = options.isAllDay;\n      return this.workspace.getCoordinatesByDateInGroup(appointment.startDate, resources, isAllDay);\n    }\n  }]);\n\n  return AppointmentSettingsGeneratorBaseStrategy;\n}();\nexport var AppointmentSettingsGeneratorVirtualStrategy = /*#__PURE__*/function (_AppointmentSettingsG) {\n  _inherits(AppointmentSettingsGeneratorVirtualStrategy, _AppointmentSettingsG);\n\n  var _super = _createSuper(AppointmentSettingsGeneratorVirtualStrategy);\n\n  function AppointmentSettingsGeneratorVirtualStrategy() {\n    _classCallCheck(this, AppointmentSettingsGeneratorVirtualStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AppointmentSettingsGeneratorVirtualStrategy, [{\n    key: \"viewDataProvider\",\n    get: function get() {\n      return this.workspace.viewDataProvider;\n    }\n  }, {\n    key: \"isVerticalGrouping\",\n    get: function get() {\n      return this.workspace._isVerticalGroupedWorkSpace();\n    }\n  }, {\n    key: \"createAppointmentInfos\",\n    value: function createAppointmentInfos(gridAppointments, resources, allDay, recurrent) {\n      var _this8 = this;\n\n      var appointments = allDay ? gridAppointments : gridAppointments.filter(function (_ref) {\n        var source = _ref.source,\n            startDate = _ref.startDate,\n            endDate = _ref.endDate;\n        var groupIndex = source.groupIndex;\n        return _this8.viewDataProvider.isGroupIntersectDateInterval(groupIndex, startDate, endDate);\n      });\n\n      if (recurrent) {\n        return this._createRecurrentAppointmentInfos(appointments, resources, allDay);\n      }\n\n      return _get(_getPrototypeOf(AppointmentSettingsGeneratorVirtualStrategy.prototype), \"createAppointmentInfos\", this).call(this, appointments, resources, allDay, recurrent);\n    }\n  }, {\n    key: \"getCoordinates\",\n    value: function getCoordinates(options) {\n      var appointment = options.appointment,\n          isAllDay = options.isAllDay,\n          resources = options.resources,\n          recurrent = options.recurrent;\n      var startDate = appointment.startDate;\n      var workspace = this.workspace;\n      var groupIndex = !recurrent ? appointment.source.groupIndex : void 0;\n      return workspace.getCoordinatesByDateInGroup(startDate, resources, isAllDay, groupIndex);\n    }\n  }, {\n    key: \"_createRecurrentAppointmentInfos\",\n    value: function _createRecurrentAppointmentInfos(gridAppointments, resources, allDay) {\n      var _this9 = this;\n\n      var result = [];\n      gridAppointments.forEach(function (appointment) {\n        var source = appointment.source;\n        var groupIndex = source.groupIndex;\n\n        var coordinate = _this9.workspace.getCoordinatesByDate(appointment.startDate, groupIndex, allDay);\n\n        if (coordinate) {\n          extend(coordinate, {\n            info: {\n              appointment: appointment,\n              sourceAppointment: source\n            }\n          });\n          result.push(coordinate);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"_cropAppointmentsByStartDayHour\",\n    value: function _cropAppointmentsByStartDayHour(appointments, rawAppointment, isAllDay) {\n      var _this10 = this;\n\n      return appointments.filter(function (appointment) {\n        var firstViewDate = _this10._getAppointmentFirstViewDate(appointment, rawAppointment);\n\n        if (!firstViewDate) {\n          return false;\n        }\n\n        var startDayHour = _this10._getViewStartDayHour(firstViewDate);\n\n        var startDate = new Date(appointment.startDate);\n        appointment.startDate = _this10._getAppointmentResultDate({\n          appointment: appointment,\n          rawAppointment: rawAppointment,\n          startDate: startDate,\n          startDayHour: startDayHour,\n          firstViewDate: firstViewDate\n        });\n        return !isAllDay ? appointment.endDate > appointment.startDate : true;\n      });\n    }\n  }, {\n    key: \"_createRecurrenceAppointments\",\n    value: function _createRecurrenceAppointments(appointment, resources) {\n      var _this11 = this;\n\n      var duration = appointment.duration;\n      var result = [];\n      var groupIndices = this.workspace._getGroupCount() ? this._getGroupIndices(resources) : [0];\n      groupIndices.forEach(function (groupIndex) {\n        var option = _this11._createRecurrenceOptions(appointment, groupIndex);\n\n        var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n        var recurrentInfo = generatedStartDates.map(function (date) {\n          var startDate = new Date(date);\n          var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n          utcDate.setTime(utcDate.getTime() + duration);\n          var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n          return {\n            startDate: startDate,\n            endDate: endDate,\n            groupIndex: groupIndex\n          };\n        });\n        result.push.apply(result, _toConsumableArray(recurrentInfo));\n      });\n      return result;\n    }\n  }, {\n    key: \"_getViewStartDayHour\",\n    value: function _getViewStartDayHour(firstViewDate) {\n      return firstViewDate.getHours();\n    }\n  }, {\n    key: \"_getAppointmentFirstViewDate\",\n    value: function _getAppointmentFirstViewDate(appointment, rawAppointment) {\n      var _this$scheduler$getWo = this.scheduler.getWorkSpace(),\n          viewDataProvider = _this$scheduler$getWo.viewDataProvider;\n\n      var groupIndex = appointment.source.groupIndex;\n      var startDate = appointment.startDate,\n          endDate = appointment.endDate;\n\n      var isAllDay = this._isAllDayAppointment(rawAppointment);\n\n      return viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay);\n    }\n  }, {\n    key: \"_updateGroupIndices\",\n    value: function _updateGroupIndices(appointments, itemResources) {\n      var _this12 = this;\n\n      var groupIndices = this._getGroupIndices(itemResources);\n\n      var result = [];\n      groupIndices.forEach(function (groupIndex) {\n        var groupStartDate = _this12.viewDataProvider.getGroupStartDate(groupIndex);\n\n        if (groupStartDate) {\n          appointments.forEach(function (appointment) {\n            var appointmentCopy = extend({}, appointment);\n            appointmentCopy.groupIndex = groupIndex;\n            result.push(appointmentCopy);\n          });\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"_getGroupIndices\",\n    value: function _getGroupIndices(resources) {\n      var _groupIndices;\n\n      var groupIndices = this.workspace._getGroupIndexes(resources);\n\n      var viewDataProvider = this.workspace.viewDataProvider;\n      var viewDataGroupIndices = viewDataProvider.getGroupIndices();\n\n      if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {\n        groupIndices = [0];\n      }\n\n      return groupIndices.filter(function (groupIndex) {\n        return -1 !== viewDataGroupIndices.indexOf(groupIndex);\n      });\n    }\n  }, {\n    key: \"_createAppointments\",\n    value: function _createAppointments(appointment, resources) {\n      var appointments = _get(_getPrototypeOf(AppointmentSettingsGeneratorVirtualStrategy.prototype), \"_createAppointments\", this).call(this, appointment, resources);\n\n      return !appointment.isRecurrent ? this._updateGroupIndices(appointments, resources) : appointments;\n    }\n  }]);\n\n  return AppointmentSettingsGeneratorVirtualStrategy;\n}(AppointmentSettingsGeneratorBaseStrategy);","map":{"version":3,"sources":["C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/devextreme/esm/ui/scheduler/appointmentSettingsGenerator.js"],"names":["_extends","dateUtils","isEmptyObject","extend","getRecurrenceProcessor","timeZoneUtils","toMs","dateToMilliseconds","AppointmentSettingsGenerator","scheduler","settingsStrategy","isVirtualScrolling","AppointmentSettingsGeneratorVirtualStrategy","AppointmentSettingsGeneratorBaseStrategy","rawAppointment","create","timeZoneCalculator","getWorkSpace","workspace","viewDataProvider","appointment","createAppointmentAdapter","itemResources","_resourcesManager","getResourcesFromItem","isAllDay","_isAllDayAppointment","appointmentList","_createAppointments","_getProcessedByAppointmentTimeZone","_canProcessNotNativeTimezoneDates","_getProcessedNotNativeTimezoneDates","gridAppointmentList","_createGridAppointmentList","_cropAppointmentsByStartDayHour","_getProcessedLongAppointmentsIfRequired","appointmentInfos","createAppointmentInfos","isRecurrent","hasAppointmentTimeZone","startDateTimeZone","endDateTimeZone","length","appointmentOffsets","startDate","getOffsets","endDate","forEach","a","sourceOffsets_startDate","sourceOffsets_endDate","startDateOffsetDiff","endDateOffsetDiff","Date","getTime","appointmentTakesAllDay","supportAllDayRow","resources","appointments","_createRecurrenceAppointments","push","map","item","_item$endDate","resultEndTime","setTime","exceptionDate","timeZoneName","option","isTimeZoneSet","isEqualLocalTimeZone","date","offset","newDate","newDateMinusOneHour","setHours","getHours","newDateOffset","common","newDateMinusOneHourOffset","startDateRange","endDateRange","startDateRangeOffset","endDateRangeOffset","isChangeOffsetInRange","diffStartDateOffset","diffEndDateOffset","_getProcessedNotNativeDateIfCrossDST","newStartDate","newEndDate","testNewStartDate","createDate","path","testNewEndDate","duration","source","allDay","dateRange","getDateRange","renderingStrategy","getLayoutManager","getRenderingStrategyInstance","needSeparateAppointment","longStartDateParts","resultDates","gridAppointment","maxDate","endDateOfPart","normalizeEndDateByViewEnd","getDatesOfInterval","milliseconds","getIntervalDuration","list","filter","startDatePart","setMilliseconds","concat","offsetDifference","getTimezoneOffset","_workSpace","startViewDate","trimTime","endViewDate","commonTimeZone","daylightOffset","getDaylightOffsetInMs","groupIndex","_createExtremeRecurrenceDates","minRecurrenceDate","maxRecurrenceDate","rule","recurrenceRule","exception","recurrenceException","min","max","firstDayOfWeek","getFirstDayOfWeek","start","end","getPostProcessedException","appointmentOffset","exceptionAppointmentOffset","diff","_createRecurrenceOptions","generatedStartDates","generateDates","utcDate","createUTCDateWithLocalOffset","createDateFromUTCWithLocalOffset","firstViewDate","_getAppointmentFirstViewDate","startDayHour","_getViewStartDayHour","_getAppointmentResultDate","getStartViewDate","_getCurrentViewOption","options","resultDate","normalizeDate","roundDateByStartDayHour","gridAppointments","recurrent","_this","result","_loop","i","coordinates","getCoordinates","coordinate","info","sourceAppointment","getCoordinatesByDateInGroup","_isVerticalGroupedWorkSpace","_ref","isGroupIntersectDateInterval","_createRecurrentAppointmentInfos","getCoordinatesByDate","groupIndices","_getGroupCount","_getGroupIndices","recurrentInfo","findGroupCellStartDate","groupStartDate","getGroupStartDate","appointmentCopy","_groupIndices","_getGroupIndexes","viewDataGroupIndices","getGroupIndices","indexOf","_updateGroupIndices"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/appointmentSettingsGenerator.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport dateUtils from \"../../core/utils/date\";\r\nimport {\r\n    isEmptyObject\r\n} from \"../../core/utils/type\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    getRecurrenceProcessor\r\n} from \"./recurrence\";\r\nimport timeZoneUtils from \"./utils.timeZone.js\";\r\nvar toMs = dateUtils.dateToMilliseconds;\r\nexport class AppointmentSettingsGenerator {\r\n    constructor(scheduler) {\r\n        this.scheduler = scheduler;\r\n        this.settingsStrategy = this.scheduler.isVirtualScrolling() ? new AppointmentSettingsGeneratorVirtualStrategy(this.scheduler) : new AppointmentSettingsGeneratorBaseStrategy(this.scheduler)\r\n    }\r\n    create(rawAppointment) {\r\n        return this.settingsStrategy.create(rawAppointment)\r\n    }\r\n}\r\nexport class AppointmentSettingsGeneratorBaseStrategy {\r\n    constructor(scheduler) {\r\n        this.scheduler = scheduler\r\n    }\r\n    get timeZoneCalculator() {\r\n        return this.scheduler.timeZoneCalculator\r\n    }\r\n    get workspace() {\r\n        return this.scheduler.getWorkSpace()\r\n    }\r\n    get viewDataProvider() {\r\n        return this.workspace.viewDataProvider\r\n    }\r\n    create(rawAppointment) {\r\n        var {\r\n            scheduler: scheduler\r\n        } = this;\r\n        var appointment = scheduler.createAppointmentAdapter(rawAppointment);\r\n        var itemResources = scheduler._resourcesManager.getResourcesFromItem(rawAppointment);\r\n        var isAllDay = this._isAllDayAppointment(rawAppointment);\r\n        var appointmentList = this._createAppointments(appointment, itemResources);\r\n        appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointment);\r\n        if (this._canProcessNotNativeTimezoneDates(appointment)) {\r\n            appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointment)\r\n        }\r\n        var gridAppointmentList = this._createGridAppointmentList(appointmentList, appointment);\r\n        gridAppointmentList = this._cropAppointmentsByStartDayHour(gridAppointmentList, rawAppointment, isAllDay);\r\n        gridAppointmentList = this._getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment);\r\n        var appointmentInfos = this.createAppointmentInfos(gridAppointmentList, itemResources, isAllDay, appointment.isRecurrent);\r\n        return appointmentInfos\r\n    }\r\n    _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\r\n        var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\r\n        if (appointmentList.length > 1 && hasAppointmentTimeZone) {\r\n            var appointmentOffsets = {\r\n                startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\r\n                endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\r\n            };\r\n            appointmentList.forEach(a => {\r\n                var sourceOffsets_startDate = this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\r\n                    sourceOffsets_endDate = this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\r\n                var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\r\n                var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\r\n                if (0 !== startDateOffsetDiff) {\r\n                    a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n                if (0 !== endDateOffsetDiff) {\r\n                    a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"))\r\n                }\r\n            })\r\n        }\r\n        return appointmentList\r\n    }\r\n    _isAllDayAppointment(rawAppointment) {\r\n        return this.scheduler.appointmentTakesAllDay(rawAppointment) && this.workspace.supportAllDayRow()\r\n    }\r\n    _createAppointments(appointment, resources) {\r\n        var appointments = this._createRecurrenceAppointments(appointment, resources);\r\n        if (!appointment.isRecurrent && 0 === appointments.length) {\r\n            appointments.push({\r\n                startDate: appointment.startDate,\r\n                endDate: appointment.endDate\r\n            })\r\n        }\r\n        appointments = appointments.map(item => {\r\n            var _item$endDate;\r\n            var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\r\n            if (item.startDate.getTime() === resultEndTime) {\r\n                item.endDate.setTime(resultEndTime + toMs(\"minute\"))\r\n            }\r\n            return _extends({}, item, {\r\n                exceptionDate: new Date(item.startDate)\r\n            })\r\n        });\r\n        return appointments\r\n    }\r\n    _canProcessNotNativeTimezoneDates(appointment) {\r\n        var timeZoneName = this.scheduler.option(\"timeZone\");\r\n        var isTimeZoneSet = !isEmptyObject(timeZoneName);\r\n        if (!isTimeZoneSet) {\r\n            return false\r\n        }\r\n        if (!appointment.isRecurrent) {\r\n            return false\r\n        }\r\n        return !timeZoneUtils.isEqualLocalTimeZone(timeZoneName, appointment.startDate)\r\n    }\r\n    _getProcessedNotNativeDateIfCrossDST(date, offset) {\r\n        if (offset < 0) {\r\n            var newDate = new Date(date);\r\n            var newDateMinusOneHour = new Date(newDate);\r\n            newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\r\n            var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\r\n            var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\r\n            if (newDateOffset !== newDateMinusOneHourOffset) {\r\n                return 0\r\n            }\r\n        }\r\n        return offset\r\n    }\r\n    _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\r\n        var startDateRange = appointment.startDate;\r\n        var endDateRange = appointmentList[appointmentList.length - 1].endDate;\r\n        var startDateRangeOffset = this.timeZoneCalculator.getOffsets(startDateRange).common;\r\n        var endDateRangeOffset = this.timeZoneCalculator.getOffsets(endDateRange).common;\r\n        var isChangeOffsetInRange = startDateRangeOffset !== endDateRangeOffset;\r\n        if (isChangeOffsetInRange) {\r\n            return appointmentList.map(item => {\r\n                var diffStartDateOffset = this.timeZoneCalculator.getOffsets(appointment.startDate).common - this.timeZoneCalculator.getOffsets(item.startDate).common;\r\n                var diffEndDateOffset = this.timeZoneCalculator.getOffsets(appointment.endDate).common - this.timeZoneCalculator.getOffsets(item.endDate).common;\r\n                diffStartDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\r\n                diffEndDateOffset = this._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\r\n                var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\r\n                var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\r\n                var testNewStartDate = this.timeZoneCalculator.createDate(newStartDate, {\r\n                    path: \"toGrid\"\r\n                });\r\n                var testNewEndDate = this.timeZoneCalculator.createDate(newEndDate, {\r\n                    path: \"toGrid\"\r\n                });\r\n                if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\r\n                    newEndDate = new Date(newStartDate.getTime() + appointment.duration)\r\n                }\r\n                return _extends({}, item, {\r\n                    startDate: newStartDate,\r\n                    endDate: newEndDate,\r\n                    exceptionDate: new Date(newStartDate)\r\n                })\r\n            })\r\n        }\r\n        return appointmentList\r\n    }\r\n    _getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment) {\r\n        var rawAppointment = appointment.source();\r\n        var allDay = this.scheduler.appointmentTakesAllDay(rawAppointment);\r\n        var dateRange = this.workspace.getDateRange();\r\n        var renderingStrategy = this.scheduler.getLayoutManager().getRenderingStrategyInstance();\r\n        if (renderingStrategy.needSeparateAppointment(allDay)) {\r\n            var longStartDateParts = [];\r\n            var resultDates = [];\r\n            gridAppointmentList.forEach(gridAppointment => {\r\n                var maxDate = new Date(dateRange[1]);\r\n                var endDateOfPart = renderingStrategy.normalizeEndDateByViewEnd(rawAppointment, gridAppointment.endDate);\r\n                longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\r\n                    milliseconds: this.scheduler.getWorkSpace().getIntervalDuration(allDay)\r\n                });\r\n                var list = longStartDateParts.filter(startDatePart => new Date(startDatePart) < maxDate).map(date => ({\r\n                    startDate: date,\r\n                    endDate: new Date(new Date(date).setMilliseconds(appointment.duration)),\r\n                    source: gridAppointment.source\r\n                }));\r\n                resultDates = resultDates.concat(list)\r\n            });\r\n            gridAppointmentList = resultDates\r\n        }\r\n        return gridAppointmentList\r\n    }\r\n    _createGridAppointmentList(appointmentList, appointment) {\r\n        return appointmentList.map(source => {\r\n            var offsetDifference = appointment.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\r\n            if (0 !== offsetDifference && this._canProcessNotNativeTimezoneDates(appointment)) {\r\n                source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\r\n                source.exceptionDate = new Date(source.startDate)\r\n            }\r\n            var startDate = this.timeZoneCalculator.createDate(source.startDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            var endDate = this.timeZoneCalculator.createDate(source.endDate, {\r\n                path: \"toGrid\"\r\n            });\r\n            return {\r\n                startDate: startDate,\r\n                endDate: endDate,\r\n                source: source\r\n            }\r\n        })\r\n    }\r\n    _createExtremeRecurrenceDates(rawAppointment) {\r\n        var dateRange = this.scheduler._workSpace.getDateRange();\r\n        var startViewDate = this.scheduler.appointmentTakesAllDay(rawAppointment) ? dateUtils.trimTime(dateRange[0]) : dateRange[0];\r\n        var endViewDate = dateRange[1];\r\n        var commonTimeZone = this.scheduler.option(\"timeZone\");\r\n        if (commonTimeZone) {\r\n            startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\r\n                path: \"fromGrid\"\r\n            });\r\n            endViewDate = this.timeZoneCalculator.createDate(endViewDate, {\r\n                path: \"fromGrid\"\r\n            });\r\n            var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDate);\r\n            if (daylightOffset) {\r\n                endViewDate = new Date(endViewDate.getTime() + daylightOffset)\r\n            }\r\n        }\r\n        return [startViewDate, endViewDate]\r\n    }\r\n    _createRecurrenceOptions(appointment, groupIndex) {\r\n        var [minRecurrenceDate, maxRecurrenceDate] = this._createExtremeRecurrenceDates(appointment.source(), groupIndex);\r\n        return {\r\n            rule: appointment.recurrenceRule,\r\n            exception: appointment.recurrenceException,\r\n            min: minRecurrenceDate,\r\n            max: maxRecurrenceDate,\r\n            firstDayOfWeek: this.scheduler.getFirstDayOfWeek(),\r\n            start: appointment.startDate,\r\n            end: appointment.endDate,\r\n            getPostProcessedException: date => {\r\n                var timeZoneName = this.scheduler.option(\"timeZone\");\r\n                if (isEmptyObject(timeZoneName) || timeZoneUtils.isEqualLocalTimeZone(timeZoneName, date)) {\r\n                    return date\r\n                }\r\n                var appointmentOffset = this.timeZoneCalculator.getOffsets(appointment.startDate).common;\r\n                var exceptionAppointmentOffset = this.timeZoneCalculator.getOffsets(date).common;\r\n                var diff = appointmentOffset - exceptionAppointmentOffset;\r\n                diff = this._getProcessedNotNativeDateIfCrossDST(date, diff);\r\n                return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"))\r\n            }\r\n        }\r\n    }\r\n    _createRecurrenceAppointments(appointment, resources) {\r\n        var {\r\n            duration: duration\r\n        } = appointment;\r\n        var option = this._createRecurrenceOptions(appointment);\r\n        var generatedStartDates = getRecurrenceProcessor().generateDates(option);\r\n        return generatedStartDates.map(date => {\r\n            var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\r\n            utcDate.setTime(utcDate.getTime() + duration);\r\n            var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\r\n            return {\r\n                startDate: new Date(date),\r\n                endDate: endDate\r\n            }\r\n        })\r\n    }\r\n    _cropAppointmentsByStartDayHour(appointments, rawAppointment, isAllDay) {\r\n        return appointments.map(appointment => {\r\n            var startDate = new Date(appointment.startDate);\r\n            var firstViewDate = this._getAppointmentFirstViewDate(appointment, rawAppointment);\r\n            var startDayHour = this._getViewStartDayHour(firstViewDate);\r\n            appointment.startDate = this._getAppointmentResultDate({\r\n                appointment: appointment,\r\n                rawAppointment: rawAppointment,\r\n                startDate: startDate,\r\n                startDayHour: startDayHour,\r\n                firstViewDate: firstViewDate\r\n            });\r\n            return appointment\r\n        })\r\n    }\r\n    _getAppointmentFirstViewDate() {\r\n        return this.scheduler.getStartViewDate()\r\n    }\r\n    _getViewStartDayHour() {\r\n        return this.scheduler._getCurrentViewOption(\"startDayHour\")\r\n    }\r\n    _getAppointmentResultDate(options) {\r\n        var {\r\n            appointment: appointment,\r\n            rawAppointment: rawAppointment,\r\n            startDayHour: startDayHour,\r\n            firstViewDate: firstViewDate\r\n        } = options;\r\n        var {\r\n            startDate: startDate\r\n        } = options;\r\n        var resultDate = new Date(appointment.startDate);\r\n        if (this.scheduler.appointmentTakesAllDay(rawAppointment)) {\r\n            resultDate = dateUtils.normalizeDate(startDate, firstViewDate)\r\n        } else {\r\n            if (startDate < firstViewDate) {\r\n                startDate = firstViewDate\r\n            }\r\n            resultDate = dateUtils.normalizeDate(appointment.startDate, startDate)\r\n        }\r\n        return dateUtils.roundDateByStartDayHour(resultDate, startDayHour)\r\n    }\r\n    createAppointmentInfos(gridAppointments, resources, isAllDay, recurrent) {\r\n        var _this = this;\r\n        var result = [];\r\n        var _loop = function(i) {\r\n            var appointment = gridAppointments[i];\r\n            var coordinates = _this.getCoordinates({\r\n                appointment: appointment,\r\n                resources: resources,\r\n                isAllDay: isAllDay,\r\n                recurrent: recurrent\r\n            });\r\n            coordinates.forEach(coordinate => {\r\n                extend(coordinate, {\r\n                    info: {\r\n                        appointment: gridAppointments[i],\r\n                        sourceAppointment: gridAppointments[i].source\r\n                    }\r\n                })\r\n            });\r\n            result = result.concat(coordinates)\r\n        };\r\n        for (var i = 0; i < gridAppointments.length; i++) {\r\n            _loop(i)\r\n        }\r\n        return result\r\n    }\r\n    getCoordinates(options) {\r\n        var {\r\n            appointment: appointment,\r\n            resources: resources,\r\n            isAllDay: isAllDay\r\n        } = options;\r\n        return this.workspace.getCoordinatesByDateInGroup(appointment.startDate, resources, isAllDay)\r\n    }\r\n}\r\nexport class AppointmentSettingsGeneratorVirtualStrategy extends AppointmentSettingsGeneratorBaseStrategy {\r\n    get viewDataProvider() {\r\n        return this.workspace.viewDataProvider\r\n    }\r\n    get isVerticalGrouping() {\r\n        return this.workspace._isVerticalGroupedWorkSpace()\r\n    }\r\n    createAppointmentInfos(gridAppointments, resources, allDay, recurrent) {\r\n        var appointments = allDay ? gridAppointments : gridAppointments.filter(_ref => {\r\n            var {\r\n                source: source,\r\n                startDate: startDate,\r\n                endDate: endDate\r\n            } = _ref;\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = source;\r\n            return this.viewDataProvider.isGroupIntersectDateInterval(groupIndex, startDate, endDate)\r\n        });\r\n        if (recurrent) {\r\n            return this._createRecurrentAppointmentInfos(appointments, resources, allDay)\r\n        }\r\n        return super.createAppointmentInfos(appointments, resources, allDay, recurrent)\r\n    }\r\n    getCoordinates(options) {\r\n        var {\r\n            appointment: appointment,\r\n            isAllDay: isAllDay,\r\n            resources: resources,\r\n            recurrent: recurrent\r\n        } = options;\r\n        var {\r\n            startDate: startDate\r\n        } = appointment;\r\n        var {\r\n            workspace: workspace\r\n        } = this;\r\n        var groupIndex = !recurrent ? appointment.source.groupIndex : void 0;\r\n        return workspace.getCoordinatesByDateInGroup(startDate, resources, isAllDay, groupIndex)\r\n    }\r\n    _createRecurrentAppointmentInfos(gridAppointments, resources, allDay) {\r\n        var result = [];\r\n        gridAppointments.forEach(appointment => {\r\n            var {\r\n                source: source\r\n            } = appointment;\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = source;\r\n            var coordinate = this.workspace.getCoordinatesByDate(appointment.startDate, groupIndex, allDay);\r\n            if (coordinate) {\r\n                extend(coordinate, {\r\n                    info: {\r\n                        appointment: appointment,\r\n                        sourceAppointment: source\r\n                    }\r\n                });\r\n                result.push(coordinate)\r\n            }\r\n        });\r\n        return result\r\n    }\r\n    _cropAppointmentsByStartDayHour(appointments, rawAppointment, isAllDay) {\r\n        return appointments.filter(appointment => {\r\n            var firstViewDate = this._getAppointmentFirstViewDate(appointment, rawAppointment);\r\n            if (!firstViewDate) {\r\n                return false\r\n            }\r\n            var startDayHour = this._getViewStartDayHour(firstViewDate);\r\n            var startDate = new Date(appointment.startDate);\r\n            appointment.startDate = this._getAppointmentResultDate({\r\n                appointment: appointment,\r\n                rawAppointment: rawAppointment,\r\n                startDate: startDate,\r\n                startDayHour: startDayHour,\r\n                firstViewDate: firstViewDate\r\n            });\r\n            return !isAllDay ? appointment.endDate > appointment.startDate : true\r\n        })\r\n    }\r\n    _createRecurrenceAppointments(appointment, resources) {\r\n        var {\r\n            duration: duration\r\n        } = appointment;\r\n        var result = [];\r\n        var groupIndices = this.workspace._getGroupCount() ? this._getGroupIndices(resources) : [0];\r\n        groupIndices.forEach(groupIndex => {\r\n            var option = this._createRecurrenceOptions(appointment, groupIndex);\r\n            var generatedStartDates = getRecurrenceProcessor().generateDates(option);\r\n            var recurrentInfo = generatedStartDates.map(date => {\r\n                var startDate = new Date(date);\r\n                var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\r\n                utcDate.setTime(utcDate.getTime() + duration);\r\n                var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\r\n                return {\r\n                    startDate: startDate,\r\n                    endDate: endDate,\r\n                    groupIndex: groupIndex\r\n                }\r\n            });\r\n            result.push(...recurrentInfo)\r\n        });\r\n        return result\r\n    }\r\n    _getViewStartDayHour(firstViewDate) {\r\n        return firstViewDate.getHours()\r\n    }\r\n    _getAppointmentFirstViewDate(appointment, rawAppointment) {\r\n        var {\r\n            viewDataProvider: viewDataProvider\r\n        } = this.scheduler.getWorkSpace();\r\n        var {\r\n            groupIndex: groupIndex\r\n        } = appointment.source;\r\n        var {\r\n            startDate: startDate,\r\n            endDate: endDate\r\n        } = appointment;\r\n        var isAllDay = this._isAllDayAppointment(rawAppointment);\r\n        return viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay)\r\n    }\r\n    _updateGroupIndices(appointments, itemResources) {\r\n        var groupIndices = this._getGroupIndices(itemResources);\r\n        var result = [];\r\n        groupIndices.forEach(groupIndex => {\r\n            var groupStartDate = this.viewDataProvider.getGroupStartDate(groupIndex);\r\n            if (groupStartDate) {\r\n                appointments.forEach(appointment => {\r\n                    var appointmentCopy = extend({}, appointment);\r\n                    appointmentCopy.groupIndex = groupIndex;\r\n                    result.push(appointmentCopy)\r\n                })\r\n            }\r\n        });\r\n        return result\r\n    }\r\n    _getGroupIndices(resources) {\r\n        var _groupIndices;\r\n        var groupIndices = this.workspace._getGroupIndexes(resources);\r\n        var {\r\n            viewDataProvider: viewDataProvider\r\n        } = this.workspace;\r\n        var viewDataGroupIndices = viewDataProvider.getGroupIndices();\r\n        if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {\r\n            groupIndices = [0]\r\n        }\r\n        return groupIndices.filter(groupIndex => -1 !== viewDataGroupIndices.indexOf(groupIndex))\r\n    }\r\n    _createAppointments(appointment, resources) {\r\n        var appointments = super._createAppointments(appointment, resources);\r\n        return !appointment.isRecurrent ? this._updateGroupIndices(appointments, resources) : appointments\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}