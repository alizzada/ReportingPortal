{"ast":null,"code":"import _slicedToArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\r\n * DevExtreme (esm/viz/funnel/label.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { Label } from \"../series/points/label\";\nimport { normalizeEnum } from \"../core/utils\";\nimport { extend } from \"../../core/utils/extend\";\nimport { noop } from \"../../core/utils/common\";\nvar OUTSIDE_POSITION = \"outside\";\nvar INSIDE_POSITION = \"inside\";\nvar OUTSIDE_LABEL_INDENT = 5;\nvar COLUMNS_LABEL_INDENT = 20;\nvar CONNECTOR_INDENT = 4;\nvar PREVENT_EMPTY_PIXEL_OFFSET = 1;\n\nfunction getLabelIndent(pos) {\n  pos = normalizeEnum(pos);\n\n  if (pos === OUTSIDE_POSITION) {\n    return OUTSIDE_LABEL_INDENT;\n  } else if (pos === INSIDE_POSITION) {\n    return 0;\n  }\n\n  return COLUMNS_LABEL_INDENT;\n}\n\nfunction isOutsidePosition(pos) {\n  pos = normalizeEnum(pos);\n  return pos === OUTSIDE_POSITION || pos !== INSIDE_POSITION;\n}\n\nfunction correctYForInverted(y, bBox, inverted) {\n  return inverted ? y - bBox.height : y;\n}\n\nfunction getOutsideRightLabelPosition(coords, bBox, options, inverted) {\n  return {\n    x: coords[2] + options.horizontalOffset + OUTSIDE_LABEL_INDENT,\n    y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\n  };\n}\n\nfunction getOutsideLeftLabelPosition(coords, bBox, options, inverted) {\n  return {\n    x: coords[0] - bBox.width - options.horizontalOffset - OUTSIDE_LABEL_INDENT,\n    y: correctYForInverted(coords[1] + options.verticalOffset, bBox, inverted)\n  };\n}\n\nfunction getInsideLabelPosition(coords, bBox, options) {\n  var width = coords[2] - coords[0];\n  var height = coords[7] - coords[1];\n  return {\n    x: coords[0] + width / 2 + options.horizontalOffset - bBox.width / 2,\n    y: coords[1] + options.verticalOffset + height / 2 - bBox.height / 2\n  };\n}\n\nfunction getColumnLabelRightPosition(labelRect, rect, textAlignment) {\n  return function (coords, bBox, options, inverted) {\n    return {\n      x: \"left\" === textAlignment ? rect[2] + options.horizontalOffset + COLUMNS_LABEL_INDENT : labelRect[2] - bBox.width,\n      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\n    };\n  };\n}\n\nfunction getColumnLabelLeftPosition(labelRect, rect, textAlignment) {\n  return function (coords, bBox, options, inverted) {\n    return {\n      x: \"left\" === textAlignment ? labelRect[0] : rect[0] - bBox.width - options.horizontalOffset - COLUMNS_LABEL_INDENT,\n      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\n    };\n  };\n}\n\nfunction getConnectorStrategy(options, inverted) {\n  var isLeftPos = \"left\" === options.horizontalAlignment;\n  var connectorIndent = isLeftPos ? CONNECTOR_INDENT : -CONNECTOR_INDENT;\n  var verticalCorrection = inverted ? -PREVENT_EMPTY_PIXEL_OFFSET : 0;\n\n  function getFigureCenter(figure) {\n    return isLeftPos ? [figure[0] + PREVENT_EMPTY_PIXEL_OFFSET, figure[1] + verticalCorrection] : [figure[2] - PREVENT_EMPTY_PIXEL_OFFSET, figure[3] + verticalCorrection];\n  }\n\n  return {\n    isLabelInside: function isLabelInside() {\n      return !isOutsidePosition(options.position);\n    },\n    getFigureCenter: getFigureCenter,\n    prepareLabelPoints: function prepareLabelPoints(bBox) {\n      var x = bBox.x + connectorIndent;\n      var y = bBox.y;\n      var x1 = x + bBox.width;\n      return _toConsumableArray(Array(bBox.height + 1)).map(function (_, i) {\n        return [x, y + i];\n      }).concat(_toConsumableArray(Array(bBox.height + 1)).map(function (_, i) {\n        return [x1, y + i];\n      }));\n    },\n    isHorizontal: function isHorizontal() {\n      return true;\n    },\n    findFigurePoint: function findFigurePoint(figure) {\n      return getFigureCenter(figure);\n    },\n    adjustPoints: function adjustPoints(points) {\n      return points.map(Math.round);\n    }\n  };\n}\n\nfunction getLabelOptions(labelOptions, defaultColor, defaultTextAlignment) {\n  var opt = labelOptions || {};\n  var labelFont = extend({}, opt.font) || {};\n  var labelBorder = opt.border || {};\n  var labelConnector = opt.connector || {};\n  var backgroundAttr = {\n    fill: opt.backgroundColor || defaultColor,\n    \"stroke-width\": labelBorder.visible ? labelBorder.width || 0 : 0,\n    stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : \"none\",\n    dashStyle: labelBorder.dashStyle\n  };\n  var connectorAttr = {\n    stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : \"none\",\n    \"stroke-width\": labelConnector.visible ? labelConnector.width || 0 : 0,\n    opacity: labelConnector.opacity\n  };\n  labelFont.color = \"none\" === opt.backgroundColor && \"#ffffff\" === normalizeEnum(labelFont.color) && \"inside\" !== opt.position ? defaultColor : labelFont.color;\n  return {\n    format: opt.format,\n    textAlignment: opt.textAlignment || (isOutsidePosition(opt.position) ? defaultTextAlignment : \"center\"),\n    customizeText: opt.customizeText,\n    attributes: {\n      font: labelFont\n    },\n    visible: 0 !== labelFont.size ? opt.visible : false,\n    showForZeroValues: opt.showForZeroValues,\n    horizontalOffset: opt.horizontalOffset,\n    verticalOffset: opt.verticalOffset,\n    background: backgroundAttr,\n    connector: connectorAttr,\n    wordWrap: labelOptions.wordWrap,\n    textOverflow: labelOptions.textOverflow\n  };\n}\n\nfunction correctLabelPosition(pos, bBox, rect) {\n  if (pos.x < rect[0]) {\n    pos.x = rect[0];\n  }\n\n  if (pos.x + bBox.width > rect[2]) {\n    pos.x = rect[2] - bBox.width;\n  }\n\n  if (pos.y < rect[1]) {\n    pos.y = rect[1];\n  }\n\n  if (pos.y + bBox.height > rect[3]) {\n    pos.y = rect[3] - bBox.height;\n  }\n\n  return pos;\n}\n\nfunction removeEmptySpace(labels, requiredSpace, startPoint) {\n  labels.reduce(function (requiredSpace, label, index, labels) {\n    var prevLabel = labels[index + 1];\n\n    if (requiredSpace > 0) {\n      var bBox = label.getBoundingRect();\n      var point = prevLabel ? prevLabel.getBoundingRect().y + prevLabel.getBoundingRect().height : startPoint;\n      var emptySpace = bBox.y - point;\n      var shift = Math.min(emptySpace, requiredSpace);\n      labels.slice(0, index + 1).forEach(function (label) {\n        var bBox = label.getBoundingRect();\n        label.shift(bBox.x, bBox.y - shift);\n      });\n      requiredSpace -= shift;\n    }\n\n    return requiredSpace;\n  }, requiredSpace);\n}\n\nexport var plugin = {\n  name: \"lables\",\n  init: noop,\n  dispose: noop,\n  extenders: {\n    _initCore: function _initCore() {\n      this._labelsGroup = this._renderer.g().attr({\n        class: this._rootClassPrefix + \"-labels\"\n      }).append(this._renderer.root);\n      this._labels = [];\n    },\n    _applySize: function _applySize() {\n      var options = this._getOption(\"label\");\n\n      var adaptiveLayout = this._getOption(\"adaptiveLayout\");\n\n      var rect = this._rect;\n      var labelWidth = 0;\n      var width = rect[2] - rect[0];\n      this._labelRect = rect.slice();\n\n      if (!this._labels.length || !isOutsidePosition(options.position)) {\n        if (normalizeEnum(\"none\" !== this._getOption(\"resolveLabelOverlapping\", true))) {\n          this._labels.forEach(function (l) {\n            return !l.isVisible() && l.draw(true);\n          });\n        }\n\n        return;\n      }\n\n      var groupWidth = this._labels.map(function (label) {\n        label.resetEllipsis();\n        return label.getBoundingRect().width;\n      }).reduce(function (max, width) {\n        return Math.max(max, width);\n      }, 0);\n\n      labelWidth = groupWidth + options.horizontalOffset + getLabelIndent(options.position);\n\n      if (!adaptiveLayout.keepLabels && width - labelWidth < adaptiveLayout.width) {\n        this._labels.forEach(function (label) {\n          label.draw(false);\n        });\n\n        return;\n      } else {\n        if (width - labelWidth < adaptiveLayout.width) {\n          labelWidth = width - adaptiveLayout.width;\n          labelWidth = labelWidth > 0 ? labelWidth : 0;\n        }\n\n        this._labels.forEach(function (label) {\n          label.draw(true);\n        });\n      }\n\n      if (\"left\" === options.horizontalAlignment) {\n        rect[0] += labelWidth;\n      } else {\n        rect[2] -= labelWidth;\n      }\n    },\n    _buildNodes: function _buildNodes() {\n      this._createLabels();\n    },\n    _change_TILING: function _change_TILING() {\n      var that = this;\n\n      var options = that._getOption(\"label\");\n\n      var getCoords = getInsideLabelPosition;\n\n      var inverted = that._getOption(\"inverted\", true);\n\n      var textAlignment;\n\n      if (isOutsidePosition(options.position)) {\n        if (normalizeEnum(options.position) === OUTSIDE_POSITION) {\n          getCoords = \"left\" === options.horizontalAlignment ? getOutsideLeftLabelPosition : getOutsideRightLabelPosition;\n        } else {\n          textAlignment = this._defaultLabelTextAlignment();\n          getCoords = \"left\" === options.horizontalAlignment ? getColumnLabelLeftPosition(this._labelRect, this._rect, textAlignment) : getColumnLabelRightPosition(this._labelRect, this._rect, textAlignment);\n        }\n      }\n\n      that._labels.forEach(function (label, index) {\n        var item = that._items[index];\n        var borderWidth = item.getNormalStyle()[\"stroke-width\"];\n        var halfBorderWidth = inverted ? borderWidth / 2 : -borderWidth / 2;\n        var coords = halfBorderWidth ? item.coords.map(function (coord, index) {\n          if (1 === index || 3 === index) {\n            return coord - halfBorderWidth;\n          } else if (2 === index) {\n            return coord - borderWidth;\n          } else if (0 === index) {\n            return coord + borderWidth;\n          }\n\n          return coord;\n        }) : item.coords;\n\n        if (!options.showForZeroValues && 0 === item.value) {\n          label.draw(false);\n          return;\n        }\n\n        if (isOutsidePosition(options.position)) {\n          that._correctLabelWidth(label, item.coords, options);\n        }\n\n        var bBox = label.getBoundingRect();\n        var pos = correctLabelPosition(getCoords(coords, bBox, options, inverted), bBox, that._labelRect);\n        label.setFigureToDrawConnector(coords);\n        label.shift(pos.x, pos.y);\n      });\n\n      that._resolveLabelOverlapping();\n    }\n  },\n  members: {\n    _resolveLabelOverlapping: function _resolveLabelOverlapping() {\n      var that = this;\n      var resolveLabelOverlapping = normalizeEnum(that._getOption(\"resolveLabelOverlapping\", true));\n      var labels = this._getOption(\"inverted\", true) ? that._labels.slice().reverse() : that._labels;\n\n      if (\"hide\" === resolveLabelOverlapping) {\n        labels.reduce(function (height, label) {\n          if (label.getBoundingRect().y < height) {\n            label.hide();\n          } else {\n            height = label.getBoundingRect().y + label.getBoundingRect().height;\n          }\n\n          return height;\n        }, 0);\n      } else if (\"shift\" === resolveLabelOverlapping) {\n        var maxHeight = this._labelRect[3];\n        labels.reduce(function (_ref, label, index, labels) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              height = _ref2[0],\n              emptySpace = _ref2[1];\n\n          var bBox = label.getBoundingRect();\n          var y = bBox.y;\n\n          if (bBox.y < height) {\n            label.shift(bBox.x, height);\n            y = height;\n          }\n\n          if (y - height > 0) {\n            emptySpace += y - height;\n          }\n\n          if (y + bBox.height > maxHeight) {\n            if (emptySpace && emptySpace > y + bBox.height - maxHeight) {\n              removeEmptySpace(labels.slice(0, index).reverse(), y + bBox.height - maxHeight, that._labelRect[1]);\n              emptySpace -= y + bBox.height - maxHeight;\n              label.shift(bBox.x, y - (y + bBox.height - maxHeight));\n              height = y - (y + bBox.height - maxHeight) + bBox.height;\n            } else {\n              label.hide();\n            }\n          } else {\n            height = y + bBox.height;\n          }\n\n          return [height, emptySpace];\n        }, [this._labelRect[1], 0]);\n      }\n    },\n    _defaultLabelTextAlignment: function _defaultLabelTextAlignment() {\n      return this._getOption(\"rtlEnabled\", true) ? \"right\" : \"left\";\n    },\n    _correctLabelWidth: function _correctLabelWidth(label, item, options) {\n      var isLeftPos = \"left\" === options.horizontalAlignment;\n      var minX = isLeftPos ? this._labelRect[0] : item[2];\n      var maxX = isLeftPos ? item[0] : this._labelRect[2];\n      var maxWidth = maxX - minX;\n\n      if (label.getBoundingRect().width > maxWidth) {\n        label.fit(maxWidth);\n      }\n    },\n    _createLabels: function _createLabels() {\n      var that = this;\n\n      var labelOptions = that._getOption(\"label\");\n\n      var connectorStrategy = getConnectorStrategy(labelOptions, that._getOption(\"inverted\", true));\n\n      this._labelsGroup.clear();\n\n      if (!labelOptions.visible) {\n        return;\n      }\n\n      this._labels = that._items.map(function (item) {\n        var label = new Label({\n          renderer: that._renderer,\n          labelsGroup: that._labelsGroup,\n          strategy: connectorStrategy\n        });\n        label.setOptions(getLabelOptions(labelOptions, item.color, that._defaultLabelTextAlignment()));\n        label.setData({\n          item: item,\n          value: item.value,\n          percent: item.percent\n        });\n        label.draw(true);\n        return label;\n      });\n\n      if (this._labels.length && isOutsidePosition(labelOptions.position)) {\n        this._requestChange([\"LAYOUT\"]);\n      }\n    }\n  },\n  customize: function customize(constructor) {\n    constructor.prototype._proxyData.push(function (x, y) {\n      var that = this;\n      var data;\n\n      that._labels.forEach(function (label, index) {\n        var rect = label.getBoundingRect();\n\n        if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {\n          var pos = isOutsidePosition(that._getOption(\"label\").position) ? \"outside\" : \"inside\";\n          data = {\n            id: index,\n            type: pos + \"-label\"\n          };\n          return true;\n        }\n      });\n\n      return data;\n    });\n\n    [\"label\", \"resolveLabelOverlapping\"].forEach(function (optionName) {\n      constructor.addChange({\n        code: optionName.toUpperCase(),\n        handler: function handler() {\n          this._createLabels();\n\n          this._requestChange([\"LAYOUT\"]);\n        },\n        isThemeDependent: true,\n        isOptionChange: true,\n        option: optionName\n      });\n    });\n  },\n  fontFields: [\"label.font\"]\n};","map":{"version":3,"sources":["C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/devextreme/esm/viz/funnel/label.js"],"names":["Label","normalizeEnum","extend","noop","OUTSIDE_POSITION","INSIDE_POSITION","OUTSIDE_LABEL_INDENT","COLUMNS_LABEL_INDENT","CONNECTOR_INDENT","PREVENT_EMPTY_PIXEL_OFFSET","getLabelIndent","pos","isOutsidePosition","correctYForInverted","y","bBox","inverted","height","getOutsideRightLabelPosition","coords","options","x","horizontalOffset","verticalOffset","getOutsideLeftLabelPosition","width","getInsideLabelPosition","getColumnLabelRightPosition","labelRect","rect","textAlignment","getColumnLabelLeftPosition","getConnectorStrategy","isLeftPos","horizontalAlignment","connectorIndent","verticalCorrection","getFigureCenter","figure","isLabelInside","position","prepareLabelPoints","x1","Array","map","_","i","concat","isHorizontal","findFigurePoint","adjustPoints","points","Math","round","getLabelOptions","labelOptions","defaultColor","defaultTextAlignment","opt","labelFont","font","labelBorder","border","labelConnector","connector","backgroundAttr","fill","backgroundColor","visible","stroke","color","dashStyle","connectorAttr","opacity","format","customizeText","attributes","size","showForZeroValues","background","wordWrap","textOverflow","correctLabelPosition","removeEmptySpace","labels","requiredSpace","startPoint","reduce","label","index","prevLabel","getBoundingRect","point","emptySpace","shift","min","slice","forEach","plugin","name","init","dispose","extenders","_initCore","_labelsGroup","_renderer","g","attr","class","_rootClassPrefix","append","root","_labels","_applySize","_getOption","adaptiveLayout","_rect","labelWidth","_labelRect","length","l","isVisible","draw","groupWidth","resetEllipsis","max","keepLabels","_buildNodes","_createLabels","_change_TILING","that","getCoords","_defaultLabelTextAlignment","item","_items","borderWidth","getNormalStyle","halfBorderWidth","coord","value","_correctLabelWidth","setFigureToDrawConnector","_resolveLabelOverlapping","members","resolveLabelOverlapping","reverse","hide","maxHeight","_ref","minX","maxX","maxWidth","fit","connectorStrategy","clear","renderer","labelsGroup","strategy","setOptions","setData","percent","_requestChange","customize","constructor","prototype","_proxyData","push","data","id","type","optionName","addChange","code","toUpperCase","handler","isThemeDependent","isOptionChange","option","fontFields"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/viz/funnel/label.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    Label\r\n} from \"../series/points/label\";\r\nimport {\r\n    normalizeEnum\r\n} from \"../core/utils\";\r\nimport {\r\n    extend\r\n} from \"../../core/utils/extend\";\r\nimport {\r\n    noop\r\n} from \"../../core/utils/common\";\r\nvar OUTSIDE_POSITION = \"outside\";\r\nvar INSIDE_POSITION = \"inside\";\r\nvar OUTSIDE_LABEL_INDENT = 5;\r\nvar COLUMNS_LABEL_INDENT = 20;\r\nvar CONNECTOR_INDENT = 4;\r\nvar PREVENT_EMPTY_PIXEL_OFFSET = 1;\r\n\r\nfunction getLabelIndent(pos) {\r\n    pos = normalizeEnum(pos);\r\n    if (pos === OUTSIDE_POSITION) {\r\n        return OUTSIDE_LABEL_INDENT\r\n    } else if (pos === INSIDE_POSITION) {\r\n        return 0\r\n    }\r\n    return COLUMNS_LABEL_INDENT\r\n}\r\n\r\nfunction isOutsidePosition(pos) {\r\n    pos = normalizeEnum(pos);\r\n    return pos === OUTSIDE_POSITION || pos !== INSIDE_POSITION\r\n}\r\n\r\nfunction correctYForInverted(y, bBox, inverted) {\r\n    return inverted ? y - bBox.height : y\r\n}\r\n\r\nfunction getOutsideRightLabelPosition(coords, bBox, options, inverted) {\r\n    return {\r\n        x: coords[2] + options.horizontalOffset + OUTSIDE_LABEL_INDENT,\r\n        y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\r\n    }\r\n}\r\n\r\nfunction getOutsideLeftLabelPosition(coords, bBox, options, inverted) {\r\n    return {\r\n        x: coords[0] - bBox.width - options.horizontalOffset - OUTSIDE_LABEL_INDENT,\r\n        y: correctYForInverted(coords[1] + options.verticalOffset, bBox, inverted)\r\n    }\r\n}\r\n\r\nfunction getInsideLabelPosition(coords, bBox, options) {\r\n    var width = coords[2] - coords[0];\r\n    var height = coords[7] - coords[1];\r\n    return {\r\n        x: coords[0] + width / 2 + options.horizontalOffset - bBox.width / 2,\r\n        y: coords[1] + options.verticalOffset + height / 2 - bBox.height / 2\r\n    }\r\n}\r\n\r\nfunction getColumnLabelRightPosition(labelRect, rect, textAlignment) {\r\n    return function(coords, bBox, options, inverted) {\r\n        return {\r\n            x: \"left\" === textAlignment ? rect[2] + options.horizontalOffset + COLUMNS_LABEL_INDENT : labelRect[2] - bBox.width,\r\n            y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\r\n        }\r\n    }\r\n}\r\n\r\nfunction getColumnLabelLeftPosition(labelRect, rect, textAlignment) {\r\n    return function(coords, bBox, options, inverted) {\r\n        return {\r\n            x: \"left\" === textAlignment ? labelRect[0] : rect[0] - bBox.width - options.horizontalOffset - COLUMNS_LABEL_INDENT,\r\n            y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\r\n        }\r\n    }\r\n}\r\n\r\nfunction getConnectorStrategy(options, inverted) {\r\n    var isLeftPos = \"left\" === options.horizontalAlignment;\r\n    var connectorIndent = isLeftPos ? CONNECTOR_INDENT : -CONNECTOR_INDENT;\r\n    var verticalCorrection = inverted ? -PREVENT_EMPTY_PIXEL_OFFSET : 0;\r\n\r\n    function getFigureCenter(figure) {\r\n        return isLeftPos ? [figure[0] + PREVENT_EMPTY_PIXEL_OFFSET, figure[1] + verticalCorrection] : [figure[2] - PREVENT_EMPTY_PIXEL_OFFSET, figure[3] + verticalCorrection]\r\n    }\r\n    return {\r\n        isLabelInside: function() {\r\n            return !isOutsidePosition(options.position)\r\n        },\r\n        getFigureCenter: getFigureCenter,\r\n        prepareLabelPoints: function(bBox) {\r\n            var x = bBox.x + connectorIndent;\r\n            var y = bBox.y;\r\n            var x1 = x + bBox.width;\r\n            return [...Array(bBox.height + 1)].map((_, i) => [x, y + i]).concat([...Array(bBox.height + 1)].map((_, i) => [x1, y + i]))\r\n        },\r\n        isHorizontal: function() {\r\n            return true\r\n        },\r\n        findFigurePoint: function(figure) {\r\n            return getFigureCenter(figure)\r\n        },\r\n        adjustPoints: function(points) {\r\n            return points.map(Math.round)\r\n        }\r\n    }\r\n}\r\n\r\nfunction getLabelOptions(labelOptions, defaultColor, defaultTextAlignment) {\r\n    var opt = labelOptions || {};\r\n    var labelFont = extend({}, opt.font) || {};\r\n    var labelBorder = opt.border || {};\r\n    var labelConnector = opt.connector || {};\r\n    var backgroundAttr = {\r\n        fill: opt.backgroundColor || defaultColor,\r\n        \"stroke-width\": labelBorder.visible ? labelBorder.width || 0 : 0,\r\n        stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : \"none\",\r\n        dashStyle: labelBorder.dashStyle\r\n    };\r\n    var connectorAttr = {\r\n        stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : \"none\",\r\n        \"stroke-width\": labelConnector.visible ? labelConnector.width || 0 : 0,\r\n        opacity: labelConnector.opacity\r\n    };\r\n    labelFont.color = \"none\" === opt.backgroundColor && \"#ffffff\" === normalizeEnum(labelFont.color) && \"inside\" !== opt.position ? defaultColor : labelFont.color;\r\n    return {\r\n        format: opt.format,\r\n        textAlignment: opt.textAlignment || (isOutsidePosition(opt.position) ? defaultTextAlignment : \"center\"),\r\n        customizeText: opt.customizeText,\r\n        attributes: {\r\n            font: labelFont\r\n        },\r\n        visible: 0 !== labelFont.size ? opt.visible : false,\r\n        showForZeroValues: opt.showForZeroValues,\r\n        horizontalOffset: opt.horizontalOffset,\r\n        verticalOffset: opt.verticalOffset,\r\n        background: backgroundAttr,\r\n        connector: connectorAttr,\r\n        wordWrap: labelOptions.wordWrap,\r\n        textOverflow: labelOptions.textOverflow\r\n    }\r\n}\r\n\r\nfunction correctLabelPosition(pos, bBox, rect) {\r\n    if (pos.x < rect[0]) {\r\n        pos.x = rect[0]\r\n    }\r\n    if (pos.x + bBox.width > rect[2]) {\r\n        pos.x = rect[2] - bBox.width\r\n    }\r\n    if (pos.y < rect[1]) {\r\n        pos.y = rect[1]\r\n    }\r\n    if (pos.y + bBox.height > rect[3]) {\r\n        pos.y = rect[3] - bBox.height\r\n    }\r\n    return pos\r\n}\r\n\r\nfunction removeEmptySpace(labels, requiredSpace, startPoint) {\r\n    labels.reduce((requiredSpace, label, index, labels) => {\r\n        var prevLabel = labels[index + 1];\r\n        if (requiredSpace > 0) {\r\n            var bBox = label.getBoundingRect();\r\n            var point = prevLabel ? prevLabel.getBoundingRect().y + prevLabel.getBoundingRect().height : startPoint;\r\n            var emptySpace = bBox.y - point;\r\n            var shift = Math.min(emptySpace, requiredSpace);\r\n            labels.slice(0, index + 1).forEach(label => {\r\n                var bBox = label.getBoundingRect();\r\n                label.shift(bBox.x, bBox.y - shift)\r\n            });\r\n            requiredSpace -= shift\r\n        }\r\n        return requiredSpace\r\n    }, requiredSpace)\r\n}\r\nexport var plugin = {\r\n    name: \"lables\",\r\n    init: noop,\r\n    dispose: noop,\r\n    extenders: {\r\n        _initCore: function() {\r\n            this._labelsGroup = this._renderer.g().attr({\r\n                class: this._rootClassPrefix + \"-labels\"\r\n            }).append(this._renderer.root);\r\n            this._labels = []\r\n        },\r\n        _applySize: function() {\r\n            var options = this._getOption(\"label\");\r\n            var adaptiveLayout = this._getOption(\"adaptiveLayout\");\r\n            var rect = this._rect;\r\n            var labelWidth = 0;\r\n            var width = rect[2] - rect[0];\r\n            this._labelRect = rect.slice();\r\n            if (!this._labels.length || !isOutsidePosition(options.position)) {\r\n                if (normalizeEnum(\"none\" !== this._getOption(\"resolveLabelOverlapping\", true))) {\r\n                    this._labels.forEach(l => !l.isVisible() && l.draw(true))\r\n                }\r\n                return\r\n            }\r\n            var groupWidth = this._labels.map((function(label) {\r\n                label.resetEllipsis();\r\n                return label.getBoundingRect().width\r\n            })).reduce((function(max, width) {\r\n                return Math.max(max, width)\r\n            }), 0);\r\n            labelWidth = groupWidth + options.horizontalOffset + getLabelIndent(options.position);\r\n            if (!adaptiveLayout.keepLabels && width - labelWidth < adaptiveLayout.width) {\r\n                this._labels.forEach((function(label) {\r\n                    label.draw(false)\r\n                }));\r\n                return\r\n            } else {\r\n                if (width - labelWidth < adaptiveLayout.width) {\r\n                    labelWidth = width - adaptiveLayout.width;\r\n                    labelWidth = labelWidth > 0 ? labelWidth : 0\r\n                }\r\n                this._labels.forEach((function(label) {\r\n                    label.draw(true)\r\n                }))\r\n            }\r\n            if (\"left\" === options.horizontalAlignment) {\r\n                rect[0] += labelWidth\r\n            } else {\r\n                rect[2] -= labelWidth\r\n            }\r\n        },\r\n        _buildNodes: function() {\r\n            this._createLabels()\r\n        },\r\n        _change_TILING: function() {\r\n            var that = this;\r\n            var options = that._getOption(\"label\");\r\n            var getCoords = getInsideLabelPosition;\r\n            var inverted = that._getOption(\"inverted\", true);\r\n            var textAlignment;\r\n            if (isOutsidePosition(options.position)) {\r\n                if (normalizeEnum(options.position) === OUTSIDE_POSITION) {\r\n                    getCoords = \"left\" === options.horizontalAlignment ? getOutsideLeftLabelPosition : getOutsideRightLabelPosition\r\n                } else {\r\n                    textAlignment = this._defaultLabelTextAlignment();\r\n                    getCoords = \"left\" === options.horizontalAlignment ? getColumnLabelLeftPosition(this._labelRect, this._rect, textAlignment) : getColumnLabelRightPosition(this._labelRect, this._rect, textAlignment)\r\n                }\r\n            }\r\n            that._labels.forEach((function(label, index) {\r\n                var item = that._items[index];\r\n                var borderWidth = item.getNormalStyle()[\"stroke-width\"];\r\n                var halfBorderWidth = inverted ? borderWidth / 2 : -borderWidth / 2;\r\n                var coords = halfBorderWidth ? item.coords.map((function(coord, index) {\r\n                    if (1 === index || 3 === index) {\r\n                        return coord - halfBorderWidth\r\n                    } else if (2 === index) {\r\n                        return coord - borderWidth\r\n                    } else if (0 === index) {\r\n                        return coord + borderWidth\r\n                    }\r\n                    return coord\r\n                })) : item.coords;\r\n                if (!options.showForZeroValues && 0 === item.value) {\r\n                    label.draw(false);\r\n                    return\r\n                }\r\n                if (isOutsidePosition(options.position)) {\r\n                    that._correctLabelWidth(label, item.coords, options)\r\n                }\r\n                var bBox = label.getBoundingRect();\r\n                var pos = correctLabelPosition(getCoords(coords, bBox, options, inverted), bBox, that._labelRect);\r\n                label.setFigureToDrawConnector(coords);\r\n                label.shift(pos.x, pos.y)\r\n            }));\r\n            that._resolveLabelOverlapping()\r\n        }\r\n    },\r\n    members: {\r\n        _resolveLabelOverlapping() {\r\n            var that = this;\r\n            var resolveLabelOverlapping = normalizeEnum(that._getOption(\"resolveLabelOverlapping\", true));\r\n            var labels = this._getOption(\"inverted\", true) ? that._labels.slice().reverse() : that._labels;\r\n            if (\"hide\" === resolveLabelOverlapping) {\r\n                labels.reduce((height, label) => {\r\n                    if (label.getBoundingRect().y < height) {\r\n                        label.hide()\r\n                    } else {\r\n                        height = label.getBoundingRect().y + label.getBoundingRect().height\r\n                    }\r\n                    return height\r\n                }, 0)\r\n            } else if (\"shift\" === resolveLabelOverlapping) {\r\n                var maxHeight = this._labelRect[3];\r\n                labels.reduce((_ref, label, index, labels) => {\r\n                    var [height, emptySpace] = _ref;\r\n                    var bBox = label.getBoundingRect();\r\n                    var y = bBox.y;\r\n                    if (bBox.y < height) {\r\n                        label.shift(bBox.x, height);\r\n                        y = height\r\n                    }\r\n                    if (y - height > 0) {\r\n                        emptySpace += y - height\r\n                    }\r\n                    if (y + bBox.height > maxHeight) {\r\n                        if (emptySpace && emptySpace > y + bBox.height - maxHeight) {\r\n                            removeEmptySpace(labels.slice(0, index).reverse(), y + bBox.height - maxHeight, that._labelRect[1]);\r\n                            emptySpace -= y + bBox.height - maxHeight;\r\n                            label.shift(bBox.x, y - (y + bBox.height - maxHeight));\r\n                            height = y - (y + bBox.height - maxHeight) + bBox.height\r\n                        } else {\r\n                            label.hide()\r\n                        }\r\n                    } else {\r\n                        height = y + bBox.height\r\n                    }\r\n                    return [height, emptySpace]\r\n                }, [this._labelRect[1], 0])\r\n            }\r\n        },\r\n        _defaultLabelTextAlignment: function() {\r\n            return this._getOption(\"rtlEnabled\", true) ? \"right\" : \"left\"\r\n        },\r\n        _correctLabelWidth: function(label, item, options) {\r\n            var isLeftPos = \"left\" === options.horizontalAlignment;\r\n            var minX = isLeftPos ? this._labelRect[0] : item[2];\r\n            var maxX = isLeftPos ? item[0] : this._labelRect[2];\r\n            var maxWidth = maxX - minX;\r\n            if (label.getBoundingRect().width > maxWidth) {\r\n                label.fit(maxWidth)\r\n            }\r\n        },\r\n        _createLabels: function() {\r\n            var that = this;\r\n            var labelOptions = that._getOption(\"label\");\r\n            var connectorStrategy = getConnectorStrategy(labelOptions, that._getOption(\"inverted\", true));\r\n            this._labelsGroup.clear();\r\n            if (!labelOptions.visible) {\r\n                return\r\n            }\r\n            this._labels = that._items.map((function(item) {\r\n                var label = new Label({\r\n                    renderer: that._renderer,\r\n                    labelsGroup: that._labelsGroup,\r\n                    strategy: connectorStrategy\r\n                });\r\n                label.setOptions(getLabelOptions(labelOptions, item.color, that._defaultLabelTextAlignment()));\r\n                label.setData({\r\n                    item: item,\r\n                    value: item.value,\r\n                    percent: item.percent\r\n                });\r\n                label.draw(true);\r\n                return label\r\n            }));\r\n            if (this._labels.length && isOutsidePosition(labelOptions.position)) {\r\n                this._requestChange([\"LAYOUT\"])\r\n            }\r\n        }\r\n    },\r\n    customize: function(constructor) {\r\n        constructor.prototype._proxyData.push((function(x, y) {\r\n            var that = this;\r\n            var data;\r\n            that._labels.forEach((function(label, index) {\r\n                var rect = label.getBoundingRect();\r\n                if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {\r\n                    var pos = isOutsidePosition(that._getOption(\"label\").position) ? \"outside\" : \"inside\";\r\n                    data = {\r\n                        id: index,\r\n                        type: pos + \"-label\"\r\n                    };\r\n                    return true\r\n                }\r\n            }));\r\n            return data\r\n        }));\r\n        [\"label\", \"resolveLabelOverlapping\"].forEach(optionName => {\r\n            constructor.addChange({\r\n                code: optionName.toUpperCase(),\r\n                handler: function() {\r\n                    this._createLabels();\r\n                    this._requestChange([\"LAYOUT\"])\r\n                },\r\n                isThemeDependent: true,\r\n                isOptionChange: true,\r\n                option: optionName\r\n            })\r\n        })\r\n    },\r\n    fontFields: [\"label.font\"]\r\n};\r\n"]},"metadata":{},"sourceType":"module"}