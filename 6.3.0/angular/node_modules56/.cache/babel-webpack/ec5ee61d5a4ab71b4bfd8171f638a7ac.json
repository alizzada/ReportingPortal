{"ast":null,"code":"import _toConsumableArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\r\n * DevExtreme (esm/ui/form/ui.form.layout_manager.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport Guid from \"../../core/guid\";\nimport { default as FormItemsRunTimeInfo } from \"./ui.form.items_runtime_info\";\nimport registerComponent from \"../../core/component_registrator\";\nimport { isDefined, isEmptyObject, isFunction, isObject, type } from \"../../core/utils/type\";\nimport { getPublicElement } from \"../../core/element\";\nimport variableWrapper from \"../../core/utils/variable_wrapper\";\nimport { getCurrentScreenFactor, hasWindow } from \"../../core/utils/window\";\nimport { format } from \"../../core/utils/string\";\nimport { each } from \"../../core/utils/iterator\";\nimport { extend } from \"../../core/utils/extend\";\nimport { inArray, normalizeIndexes } from \"../../core/utils/array\";\nimport { compileGetter } from \"../../core/utils/data\";\nimport { removeEvent } from \"../../core/remove_event\";\nimport { name as clickEventName } from \"../../events/click\";\nimport errors from \"../widget/ui.errors\";\nimport messageLocalization from \"../../localization/message\";\nimport { styleProp } from \"../../core/utils/style\";\nimport { captionize } from \"../../core/utils/inflector\";\nimport Widget from \"../widget/ui.widget\";\nimport Validator from \"../validator\";\nimport ResponsiveBox from \"../responsive_box\";\nimport { isMaterial } from \"../themes\";\nimport { FIELD_ITEM_CLASS, FLEX_LAYOUT_CLASS, LAYOUT_MANAGER_ONE_COLUMN, FIELD_ITEM_OPTIONAL_MARK_CLASS, FIELD_ITEM_REQUIRED_MARK_CLASS, FIELD_ITEM_OPTIONAL_CLASS, FIELD_ITEM_REQUIRED_CLASS, FIELD_ITEM_LABEL_TEXT_CLASS, FIELD_ITEM_LABEL_CONTENT_CLASS, FIELD_ITEM_HELP_TEXT_CLASS, FIELD_ITEM_CONTENT_WRAPPER_CLASS, FORM_LAYOUT_MANAGER_CLASS, LABEL_VERTICAL_ALIGNMENT_CLASS, LABEL_HORIZONTAL_ALIGNMENT_CLASS, FIELD_ITEM_LABEL_LOCATION_CLASS, FIELD_ITEM_LABEL_ALIGN_CLASS, FIELD_ITEM_LABEL_CLASS, FIELD_ITEM_CONTENT_LOCATION_CLASS, FIELD_ITEM_CONTENT_CLASS, FIELD_EMPTY_ITEM_CLASS, FIELD_BUTTON_ITEM_CLASS, SINGLE_COLUMN_ITEM_CONTENT, ROOT_SIMPLE_ITEM_CLASS } from \"./constants\";\nimport \"../text_box\";\nimport \"../number_box\";\nimport \"../check_box\";\nimport \"../date_box\";\nimport \"../button\";\nvar FORM_EDITOR_BY_DEFAULT = \"dxTextBox\";\nvar LAYOUT_MANAGER_FIRST_ROW_CLASS = \"dx-first-row\";\nvar LAYOUT_MANAGER_LAST_ROW_CLASS = \"dx-last-row\";\nvar LAYOUT_MANAGER_FIRST_COL_CLASS = \"dx-first-col\";\nvar LAYOUT_MANAGER_LAST_COL_CLASS = \"dx-last-col\";\nvar INVALID_CLASS = \"dx-invalid\";\nvar LAYOUT_STRATEGY_FLEX = \"flex\";\nvar LAYOUT_STRATEGY_FALLBACK = \"fallback\";\nvar SIMPLE_ITEM_TYPE = \"simple\";\nvar TEMPLATE_WRAPPER_CLASS = \"dx-template-wrapper\";\nvar DATA_OPTIONS = [\"dataSource\", \"items\"];\nvar EDITORS_WITH_ARRAY_VALUE = [\"dxTagBox\", \"dxRangeSlider\"];\nvar LayoutManager = Widget.inherit({\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      layoutData: {},\n      readOnly: false,\n      colCount: 1,\n      colCountByScreen: void 0,\n      labelLocation: \"left\",\n      onFieldDataChanged: null,\n      onEditorEnterKey: null,\n      customizeItem: null,\n      alignItemLabels: true,\n      minColWidth: 200,\n      showRequiredMark: true,\n      screenByWidth: null,\n      showOptionalMark: false,\n      requiredMark: \"*\",\n      optionalMark: messageLocalization.format(\"dxForm-optionalMark\"),\n      requiredMessage: messageLocalization.getFormatter(\"dxForm-requiredMessage\")\n    });\n  },\n  _setOptionsByReference: function _setOptionsByReference() {\n    this.callBase();\n    extend(this._optionsByReference, {\n      layoutData: true,\n      validationGroup: true\n    });\n  },\n  _init: function _init() {\n    var layoutData = this.option(\"layoutData\");\n    this.callBase();\n    this._itemWatchers = [];\n    this._itemsRunTimeInfo = new FormItemsRunTimeInfo();\n\n    this._updateReferencedOptions(layoutData);\n\n    this._initDataAndItems(layoutData);\n  },\n  _dispose: function _dispose() {\n    this.callBase();\n\n    this._cleanItemWatchers();\n  },\n  _initDataAndItems: function _initDataAndItems(initialData) {\n    this._syncDataWithItems();\n\n    this._updateItems(initialData);\n  },\n  _syncDataWithItems: function _syncDataWithItems() {\n    var _this = this;\n\n    var layoutData = this.option(\"layoutData\");\n    var userItems = this.option(\"items\");\n\n    if (isDefined(userItems)) {\n      userItems.forEach(function (item) {\n        if (item.dataField && void 0 === _this._getDataByField(item.dataField)) {\n          var value;\n\n          if (item.editorOptions) {\n            value = item.editorOptions.value;\n          }\n\n          if (isDefined(value) || item.dataField in layoutData) {\n            _this._updateFieldValue(item.dataField, value);\n          }\n        }\n      });\n    }\n  },\n  _getDataByField: function _getDataByField(dataField) {\n    return dataField ? this.option(\"layoutData.\" + dataField) : null;\n  },\n  _isCheckboxUndefinedStateEnabled: function _isCheckboxUndefinedStateEnabled(editorOption) {\n    if (true === editorOption.allowIndeterminateState && \"dxCheckBox\" === editorOption.editorType) {\n      var nameParts = [\"layoutData\"].concat(_toConsumableArray(editorOption.dataField.split(\".\")));\n      var propertyName = nameParts.pop();\n      var layoutData = this.option(nameParts.join(\".\"));\n      return layoutData && propertyName in layoutData;\n    }\n\n    return false;\n  },\n  _updateFieldValue: function _updateFieldValue(dataField, value) {\n    var layoutData = this.option(\"layoutData\");\n    var newValue = value;\n\n    if (!variableWrapper.isWrapped(layoutData[dataField]) && isDefined(dataField)) {\n      this.option(\"layoutData.\" + dataField, newValue);\n    } else if (variableWrapper.isWritableWrapped(layoutData[dataField])) {\n      newValue = isFunction(newValue) ? newValue() : newValue;\n      layoutData[dataField](newValue);\n    }\n\n    this._triggerOnFieldDataChanged({\n      dataField: dataField,\n      value: newValue\n    });\n  },\n  _triggerOnFieldDataChanged: function _triggerOnFieldDataChanged(args) {\n    this._createActionByOption(\"onFieldDataChanged\")(args);\n  },\n  _updateItems: function _updateItems(layoutData) {\n    var that = this;\n    var userItems = this.option(\"items\");\n    var isUserItemsExist = isDefined(userItems);\n    var customizeItem = that.option(\"customizeItem\");\n    var items = isUserItemsExist ? userItems : this._generateItemsByData(layoutData);\n\n    if (isDefined(items)) {\n      var processedItems = [];\n      each(items, function (index, item) {\n        if (that._isAcceptableItem(item)) {\n          item = that._processItem(item);\n          customizeItem && customizeItem(item);\n\n          if (isObject(item) && false !== variableWrapper.unwrap(item.visible)) {\n            processedItems.push(item);\n          }\n        }\n      });\n\n      if (!that._itemWatchers.length || !isUserItemsExist) {\n        that._updateItemWatchers(items);\n      }\n\n      this._setItems(processedItems);\n\n      this._sortItems();\n    }\n  },\n  _cleanItemWatchers: function _cleanItemWatchers() {\n    this._itemWatchers.forEach(function (dispose) {\n      dispose();\n    });\n\n    this._itemWatchers = [];\n  },\n  _updateItemWatchers: function _updateItemWatchers(items) {\n    var that = this;\n\n    var watch = that._getWatch();\n\n    items.forEach(function (item) {\n      if (isObject(item) && isDefined(item.visible) && isFunction(watch)) {\n        that._itemWatchers.push(watch(function () {\n          return variableWrapper.unwrap(item.visible);\n        }, function () {\n          that._updateItems(that.option(\"layoutData\"));\n\n          that.repaint();\n        }, {\n          skipImmediate: true\n        }));\n      }\n    });\n  },\n  _generateItemsByData: function _generateItemsByData(layoutData) {\n    var result = [];\n\n    if (isDefined(layoutData)) {\n      each(layoutData, function (dataField) {\n        result.push({\n          dataField: dataField\n        });\n      });\n    }\n\n    return result;\n  },\n  _isAcceptableItem: function _isAcceptableItem(item) {\n    var itemField = item.dataField || item;\n\n    var itemData = this._getDataByField(itemField);\n\n    return !(isFunction(itemData) && !variableWrapper.isWrapped(itemData));\n  },\n  _processItem: function _processItem(item) {\n    if (\"string\" === typeof item) {\n      item = {\n        dataField: item\n      };\n    }\n\n    if (\"object\" === typeof item && !item.itemType) {\n      item.itemType = SIMPLE_ITEM_TYPE;\n    }\n\n    if (!isDefined(item.editorType) && isDefined(item.dataField)) {\n      var value = this._getDataByField(item.dataField);\n\n      item.editorType = isDefined(value) ? this._getEditorTypeByDataType(type(value)) : FORM_EDITOR_BY_DEFAULT;\n    }\n\n    if (\"dxCheckBox\" === item.editorType) {\n      var _item$allowIndetermin;\n\n      item.allowIndeterminateState = null !== (_item$allowIndetermin = item.allowIndeterminateState) && void 0 !== _item$allowIndetermin ? _item$allowIndetermin : true;\n    }\n\n    return item;\n  },\n  _getEditorTypeByDataType: function _getEditorTypeByDataType(dataType) {\n    switch (dataType) {\n      case \"number\":\n        return \"dxNumberBox\";\n\n      case \"date\":\n        return \"dxDateBox\";\n\n      case \"boolean\":\n        return \"dxCheckBox\";\n\n      default:\n        return \"dxTextBox\";\n    }\n  },\n  _sortItems: function _sortItems() {\n    normalizeIndexes(this._items, \"visibleIndex\");\n\n    this._sortIndexes();\n  },\n  _sortIndexes: function _sortIndexes() {\n    this._items.sort(function (itemA, itemB) {\n      var indexA = itemA.visibleIndex;\n      var indexB = itemB.visibleIndex;\n      var result;\n\n      if (indexA > indexB) {\n        result = 1;\n      } else if (indexA < indexB) {\n        result = -1;\n      } else {\n        result = 0;\n      }\n\n      return result;\n    });\n  },\n  _initMarkup: function _initMarkup() {\n    this._itemsRunTimeInfo.clear();\n\n    this.$element().addClass(FORM_LAYOUT_MANAGER_CLASS);\n    this.callBase();\n\n    this._renderResponsiveBox();\n  },\n  _hasBrowserFlex: function _hasBrowserFlex() {\n    return styleProp(LAYOUT_STRATEGY_FLEX) === LAYOUT_STRATEGY_FLEX;\n  },\n  _renderResponsiveBox: function _renderResponsiveBox() {\n    var templatesInfo = [];\n\n    if (this._items && this._items.length) {\n      var colCount = this._getColCount();\n\n      var $container = $(\"<div>\").appendTo(this.$element());\n\n      this._prepareItemsWithMerging(colCount);\n\n      var layoutItems = this._generateLayoutItems();\n\n      this._responsiveBox = this._createComponent($container, ResponsiveBox, this._getResponsiveBoxConfig(layoutItems, colCount, templatesInfo));\n\n      if (!hasWindow()) {\n        this._renderTemplates(templatesInfo);\n      }\n    }\n  },\n  _itemStateChangedHandler: function _itemStateChangedHandler(e) {\n    this._refresh();\n  },\n  _renderTemplate: function _renderTemplate($container, item) {\n    switch (item.itemType) {\n      case \"empty\":\n        this._renderEmptyItem($container);\n\n        break;\n\n      case \"button\":\n        this._renderButtonItem(item, $container);\n\n        break;\n\n      default:\n        this._renderFieldItem(item, $container);\n\n    }\n  },\n  _renderTemplates: function _renderTemplates(templatesInfo) {\n    var that = this;\n    each(templatesInfo, function (index, info) {\n      that._renderTemplate(info.container, info.formItem);\n    });\n  },\n  _getResponsiveBoxConfig: function _getResponsiveBoxConfig(layoutItems, colCount, templatesInfo) {\n    var that = this;\n    var colCountByScreen = that.option(\"colCountByScreen\");\n    var xsColCount = colCountByScreen && colCountByScreen.xs;\n    return {\n      onItemStateChanged: this._itemStateChangedHandler.bind(this),\n      _layoutStrategy: that._hasBrowserFlex() ? LAYOUT_STRATEGY_FLEX : LAYOUT_STRATEGY_FALLBACK,\n      onLayoutChanged: function onLayoutChanged() {\n        var onLayoutChanged = that.option(\"onLayoutChanged\");\n        var isSingleColumnMode = that.isSingleColumnMode();\n\n        if (onLayoutChanged) {\n          that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, isSingleColumnMode);\n          onLayoutChanged(isSingleColumnMode);\n        }\n      },\n      onContentReady: function onContentReady(e) {\n        if (hasWindow()) {\n          that._renderTemplates(templatesInfo);\n        }\n\n        if (that.option(\"onLayoutChanged\")) {\n          that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, that.isSingleColumnMode(e.component));\n        }\n      },\n      itemTemplate: function itemTemplate(e, itemData, itemElement) {\n        if (!e.location) {\n          return;\n        }\n\n        var $itemElement = $(itemElement);\n        var itemRenderedCountInPreviousRows = e.location.row * colCount;\n        var item = that._items[e.location.col + itemRenderedCountInPreviousRows];\n        var $fieldItem = $(\"<div>\").addClass(item.cssClass).appendTo($itemElement);\n        templatesInfo.push({\n          container: $fieldItem,\n          formItem: item\n        });\n        $itemElement.toggleClass(SINGLE_COLUMN_ITEM_CONTENT, that.isSingleColumnMode(this));\n\n        if (0 === e.location.row) {\n          $fieldItem.addClass(LAYOUT_MANAGER_FIRST_ROW_CLASS);\n        }\n\n        if (0 === e.location.col) {\n          $fieldItem.addClass(LAYOUT_MANAGER_FIRST_COL_CLASS);\n        }\n\n        if (item.itemType === SIMPLE_ITEM_TYPE && that.option(\"isRoot\")) {\n          $itemElement.addClass(ROOT_SIMPLE_ITEM_CLASS);\n        }\n\n        var isLastColumn = e.location.col === colCount - 1 || e.location.col + e.location.colspan === colCount;\n\n        var rowsCount = that._getRowsCount();\n\n        var isLastRow = e.location.row === rowsCount - 1;\n\n        if (isLastColumn) {\n          $fieldItem.addClass(LAYOUT_MANAGER_LAST_COL_CLASS);\n        }\n\n        if (isLastRow) {\n          $fieldItem.addClass(LAYOUT_MANAGER_LAST_ROW_CLASS);\n        }\n      },\n      cols: that._generateRatio(colCount),\n      rows: that._generateRatio(that._getRowsCount(), true),\n      dataSource: layoutItems,\n      screenByWidth: that.option(\"screenByWidth\"),\n      singleColumnScreen: xsColCount ? false : \"xs\"\n    };\n  },\n  _getColCount: function _getColCount() {\n    var colCount = this.option(\"colCount\");\n    var colCountByScreen = this.option(\"colCountByScreen\");\n\n    if (colCountByScreen) {\n      var screenFactor = this.option(\"form\").getTargetScreenFactor();\n\n      if (!screenFactor) {\n        screenFactor = hasWindow() ? getCurrentScreenFactor(this.option(\"screenByWidth\")) : \"lg\";\n      }\n\n      colCount = colCountByScreen[screenFactor] || colCount;\n    }\n\n    if (\"auto\" === colCount) {\n      if (this._cashedColCount) {\n        return this._cashedColCount;\n      }\n\n      this._cashedColCount = colCount = this._getMaxColCount();\n    }\n\n    return colCount < 1 ? 1 : colCount;\n  },\n  _getMaxColCount: function _getMaxColCount() {\n    if (!hasWindow()) {\n      return 1;\n    }\n\n    var minColWidth = this.option(\"minColWidth\");\n    var width = this.$element().width();\n    var itemsCount = this._items.length;\n    var maxColCount = Math.floor(width / minColWidth) || 1;\n    return itemsCount < maxColCount ? itemsCount : maxColCount;\n  },\n  isCachedColCountObsolete: function isCachedColCountObsolete() {\n    return this._cashedColCount && this._getMaxColCount() !== this._cashedColCount;\n  },\n  _prepareItemsWithMerging: function _prepareItemsWithMerging(colCount) {\n    var items = this._items.slice(0);\n\n    var item;\n    var itemsMergedByCol;\n    var result = [];\n    var j;\n    var i;\n\n    for (i = 0; i < items.length; i++) {\n      item = items[i];\n      result.push(item);\n\n      if (this.option(\"alignItemLabels\") || item.alignItemLabels || item.colSpan) {\n        item.col = this._getColByIndex(result.length - 1, colCount);\n      }\n\n      if (item.colSpan > 1 && item.col + item.colSpan <= colCount) {\n        itemsMergedByCol = [];\n\n        for (j = 0; j < item.colSpan - 1; j++) {\n          itemsMergedByCol.push({\n            merged: true\n          });\n        }\n\n        result = result.concat(itemsMergedByCol);\n      } else {\n        delete item.colSpan;\n      }\n    }\n\n    this._setItems(result);\n  },\n  _getColByIndex: function _getColByIndex(index, colCount) {\n    return index % colCount;\n  },\n  _setItems: function _setItems(items) {\n    this._items = items;\n    this._cashedColCount = null;\n  },\n  _generateLayoutItems: function _generateLayoutItems() {\n    var items = this._items;\n\n    var colCount = this._getColCount();\n\n    var result = [];\n    var item;\n    var i;\n\n    for (i = 0; i < items.length; i++) {\n      item = items[i];\n\n      if (!item.merged) {\n        var generatedItem = {\n          location: {\n            row: parseInt(i / colCount),\n            col: this._getColByIndex(i, colCount)\n          }\n        };\n\n        if (isDefined(item.disabled)) {\n          generatedItem.disabled = item.disabled;\n        }\n\n        if (isDefined(item.visible)) {\n          generatedItem.visible = item.visible;\n        }\n\n        if (isDefined(item.colSpan)) {\n          generatedItem.location.colspan = item.colSpan;\n        }\n\n        if (isDefined(item.rowSpan)) {\n          generatedItem.location.rowspan = item.rowSpan;\n        }\n\n        result.push(generatedItem);\n      }\n    }\n\n    return result;\n  },\n  _renderEmptyItem: function _renderEmptyItem($container) {\n    return $container.addClass(FIELD_EMPTY_ITEM_CLASS).html(\"&nbsp;\");\n  },\n  _getButtonHorizontalAlignment: function _getButtonHorizontalAlignment(item) {\n    if (isDefined(item.horizontalAlignment)) {\n      return item.horizontalAlignment;\n    }\n\n    return \"right\";\n  },\n  _getButtonVerticalAlignment: function _getButtonVerticalAlignment(item) {\n    switch (item.verticalAlignment) {\n      case \"center\":\n        return \"center\";\n\n      case \"bottom\":\n        return \"flex-end\";\n\n      default:\n        return \"flex-start\";\n    }\n  },\n  _renderButtonItem: function _renderButtonItem(item, $container) {\n    var $button = $(\"<div>\").appendTo($container);\n    var defaultOptions = {\n      validationGroup: this.option(\"validationGroup\")\n    };\n    $container.addClass(FIELD_BUTTON_ITEM_CLASS).css(\"textAlign\", this._getButtonHorizontalAlignment(item));\n    $container.parent().css(\"justifyContent\", this._getButtonVerticalAlignment(item));\n\n    var instance = this._createComponent($button, \"dxButton\", extend(defaultOptions, item.buttonOptions));\n\n    this._itemsRunTimeInfo.add({\n      item: item,\n      widgetInstance: instance,\n      guid: item.guid,\n      $itemContainer: $container\n    });\n\n    this._addItemClasses($container, item.col);\n\n    return $button;\n  },\n  _addItemClasses: function _addItemClasses($item, column) {\n    $item.addClass(FIELD_ITEM_CLASS).addClass(this.option(\"cssItemClass\")).addClass(isDefined(column) ? \"dx-col-\" + column : \"\");\n  },\n  _renderFieldItem: function _renderFieldItem(item, $container) {\n    var name = this._getName(item);\n\n    var id = this.getItemID(name);\n    var isRequired = isDefined(item.isRequired) ? item.isRequired : !!this._hasRequiredRuleInSet(item.validationRules);\n\n    var labelOptions = this._getLabelOptions(item, id, isRequired);\n\n    var $editor = $(\"<div>\");\n    var helpID = item.helpText ? \"dx-\" + new Guid() : null;\n    var $label;\n\n    this._addItemClasses($container, item.col);\n\n    $container.addClass(isRequired ? FIELD_ITEM_REQUIRED_CLASS : FIELD_ITEM_OPTIONAL_CLASS);\n\n    if (labelOptions.visible && labelOptions.text) {\n      $label = this._renderLabel(labelOptions).appendTo($container);\n    }\n\n    if (item.itemType === SIMPLE_ITEM_TYPE) {\n      if (this._isLabelNeedBaselineAlign(item) && \"top\" !== labelOptions.location) {\n        $container.addClass(FIELD_ITEM_LABEL_ALIGN_CLASS);\n      }\n\n      this._hasBrowserFlex() && $container.addClass(FLEX_LAYOUT_CLASS);\n    }\n\n    $editor.data(\"dx-form-item\", item);\n\n    this._appendEditorToField({\n      $fieldItem: $container,\n      $label: $label,\n      $editor: $editor,\n      labelOptions: labelOptions\n    });\n\n    var instance = this._renderEditor({\n      $container: $editor,\n      dataField: item.dataField,\n      name: item.name,\n      editorType: item.editorType,\n      editorOptions: item.editorOptions,\n      template: this._getTemplateByFieldItem(item),\n      isRequired: isRequired,\n      helpID: helpID,\n      labelID: labelOptions.labelID,\n      id: id,\n      validationBoundary: this.option(\"validationBoundary\"),\n      allowIndeterminateState: item.allowIndeterminateState\n    });\n\n    this._itemsRunTimeInfo.add({\n      item: item,\n      widgetInstance: instance,\n      guid: item.guid,\n      $itemContainer: $container\n    });\n\n    var editorElem = $editor.children().first();\n    var $validationTarget = editorElem.hasClass(TEMPLATE_WRAPPER_CLASS) ? editorElem.children().first() : editorElem;\n    var validationTargetInstance = $validationTarget && $validationTarget.data(\"dx-validation-target\");\n\n    if (validationTargetInstance) {\n      this._renderValidator($validationTarget, item);\n\n      if (isMaterial()) {\n        this._addWrapperInvalidClass(validationTargetInstance);\n      }\n    }\n\n    this._renderHelpText(item, $editor, helpID);\n\n    this._attachClickHandler($label, $editor, item.editorType);\n  },\n  _hasRequiredRuleInSet: function _hasRequiredRuleInSet(rules) {\n    var hasRequiredRule;\n\n    if (rules && rules.length) {\n      each(rules, function (index, rule) {\n        if (\"required\" === rule.type) {\n          hasRequiredRule = true;\n          return false;\n        }\n      });\n    }\n\n    return hasRequiredRule;\n  },\n  _getName: function _getName(item) {\n    return item.dataField || item.name;\n  },\n  _isLabelNeedBaselineAlign: function _isLabelNeedBaselineAlign(item) {\n    return !!item.helpText && !this._hasBrowserFlex() || -1 !== inArray(item.editorType, [\"dxTextArea\", \"dxRadioGroup\", \"dxCalendar\", \"dxHtmlEditor\"]);\n  },\n  _isLabelNeedId: function _isLabelNeedId(item) {\n    return -1 !== inArray(item.editorType, [\"dxRadioGroup\", \"dxCheckBox\", \"dxLookup\", \"dxSlider\", \"dxRangeSlider\", \"dxSwitch\", \"dxHtmlEditor\"]);\n  },\n  _getLabelOptions: function _getLabelOptions(item, id, isRequired) {\n    var labelOptions = extend({\n      showColon: this.option(\"showColonAfterLabel\"),\n      location: this.option(\"labelLocation\"),\n      id: id,\n      visible: true,\n      isRequired: isRequired\n    }, item ? item.label : {});\n\n    if (this._isLabelNeedId(item)) {\n      labelOptions.labelID = \"dx-label-\".concat(new Guid());\n    }\n\n    if (!labelOptions.text && item.dataField) {\n      labelOptions.text = captionize(item.dataField);\n    }\n\n    if (labelOptions.text) {\n      labelOptions.text += labelOptions.showColon ? \":\" : \"\";\n    }\n\n    return labelOptions;\n  },\n  _renderLabel: function _renderLabel(options) {\n    var text = options.text,\n        id = options.id,\n        location = options.location,\n        alignment = options.alignment,\n        isRequired = options.isRequired,\n        _options$labelID = options.labelID,\n        labelID = _options$labelID === void 0 ? null : _options$labelID;\n\n    if (isDefined(text) && text.length > 0) {\n      var labelClasses = FIELD_ITEM_LABEL_CLASS + \" \" + FIELD_ITEM_LABEL_LOCATION_CLASS + location;\n      var $label = $(\"<label>\").addClass(labelClasses).attr(\"for\", id).attr(\"id\", labelID);\n      var $labelContent = $(\"<span>\").addClass(FIELD_ITEM_LABEL_CONTENT_CLASS).appendTo($label);\n      $(\"<span>\").addClass(FIELD_ITEM_LABEL_TEXT_CLASS).text(text).appendTo($labelContent);\n\n      if (alignment) {\n        $label.css(\"textAlign\", alignment);\n      }\n\n      $labelContent.append(this._renderLabelMark(isRequired));\n      return $label;\n    }\n  },\n  _renderLabelMark: function _renderLabelMark(isRequired) {\n    var $mark;\n\n    var requiredMarksConfig = this._getRequiredMarksConfig();\n\n    var isRequiredMark = requiredMarksConfig.showRequiredMark && isRequired;\n    var isOptionalMark = requiredMarksConfig.showOptionalMark && !isRequired;\n\n    if (isRequiredMark || isOptionalMark) {\n      var markClass = isRequiredMark ? FIELD_ITEM_REQUIRED_MARK_CLASS : FIELD_ITEM_OPTIONAL_MARK_CLASS;\n      var markText = isRequiredMark ? requiredMarksConfig.requiredMark : requiredMarksConfig.optionalMark;\n      $mark = $(\"<span>\").addClass(markClass).html(\"&nbsp\" + markText);\n    }\n\n    return $mark;\n  },\n  _getRequiredMarksConfig: function _getRequiredMarksConfig() {\n    if (!this._cashedRequiredConfig) {\n      this._cashedRequiredConfig = {\n        showRequiredMark: this.option(\"showRequiredMark\"),\n        showOptionalMark: this.option(\"showOptionalMark\"),\n        requiredMark: this.option(\"requiredMark\"),\n        optionalMark: this.option(\"optionalMark\")\n      };\n    }\n\n    return this._cashedRequiredConfig;\n  },\n  _renderEditor: function _renderEditor(options) {\n    var dataValue = this._getDataByField(options.dataField);\n\n    var defaultEditorOptions = void 0 !== dataValue || this._isCheckboxUndefinedStateEnabled(options) ? {\n      value: dataValue\n    } : {};\n\n    if (-1 !== EDITORS_WITH_ARRAY_VALUE.indexOf(options.editorType)) {\n      defaultEditorOptions.value = defaultEditorOptions.value || [];\n    }\n\n    var formInstance = this.option(\"form\");\n    var editorOptions = extend(true, defaultEditorOptions, options.editorOptions, {\n      inputAttr: {\n        id: options.id\n      },\n      validationBoundary: options.validationBoundary,\n      stylingMode: formInstance && formInstance.option(\"stylingMode\")\n    });\n\n    this._replaceDataOptions(options.editorOptions, editorOptions);\n\n    var renderOptions = {\n      editorType: options.editorType,\n      dataField: options.dataField,\n      template: options.template,\n      name: options.name,\n      helpID: options.helpID,\n      labelID: options.labelID,\n      isRequired: options.isRequired\n    };\n    return this._createEditor(options.$container, renderOptions, editorOptions);\n  },\n  _replaceDataOptions: function _replaceDataOptions(originalOptions, resultOptions) {\n    if (originalOptions) {\n      DATA_OPTIONS.forEach(function (item) {\n        if (resultOptions[item]) {\n          resultOptions[item] = originalOptions[item];\n        }\n      });\n    }\n  },\n  _renderValidator: function _renderValidator($editor, item) {\n    var fieldName = this._getFieldLabelName(item);\n\n    var validationRules = this._prepareValidationRules(item.validationRules, item.isRequired, item.itemType, fieldName);\n\n    if (Array.isArray(validationRules) && validationRules.length) {\n      this._createComponent($editor, Validator, {\n        validationRules: validationRules,\n        validationGroup: this.option(\"validationGroup\"),\n        dataGetter: function dataGetter() {\n          return {\n            formItem: item\n          };\n        }\n      });\n    }\n  },\n  _getFieldLabelName: function _getFieldLabelName(item) {\n    var isItemHaveCustomLabel = item.label && item.label.text;\n    var itemName = isItemHaveCustomLabel ? null : this._getName(item);\n    return isItemHaveCustomLabel ? item.label.text : itemName && captionize(itemName);\n  },\n  _prepareValidationRules: function _prepareValidationRules(userValidationRules, isItemRequired, itemType, itemName) {\n    var isSimpleItem = itemType === SIMPLE_ITEM_TYPE;\n    var validationRules;\n\n    if (isSimpleItem) {\n      if (userValidationRules) {\n        validationRules = userValidationRules;\n      } else {\n        var requiredMessage = format(this.option(\"requiredMessage\"), itemName || \"\");\n        validationRules = isItemRequired ? [{\n          type: \"required\",\n          message: requiredMessage\n        }] : null;\n      }\n    }\n\n    return validationRules;\n  },\n  _addWrapperInvalidClass: function _addWrapperInvalidClass(editorInstance) {\n    var wrapperClass = \".\" + FIELD_ITEM_CONTENT_WRAPPER_CLASS;\n\n    var toggleInvalidClass = function toggleInvalidClass(e) {\n      $(e.element).parents(wrapperClass).toggleClass(INVALID_CLASS, e.component._isFocused() && false === e.component.option(\"isValid\"));\n    };\n\n    editorInstance.on(\"focusIn\", toggleInvalidClass).on(\"focusOut\", toggleInvalidClass).on(\"enterKey\", toggleInvalidClass);\n  },\n  _createEditor: function _createEditor($container, renderOptions, editorOptions) {\n    var template = renderOptions.template;\n    var editorInstance;\n\n    if (renderOptions.dataField && !editorOptions.name) {\n      editorOptions.name = renderOptions.dataField;\n    }\n\n    this._addItemContentClasses($container);\n\n    if (template) {\n      var data = {\n        dataField: renderOptions.dataField,\n        editorType: renderOptions.editorType,\n        editorOptions: editorOptions,\n        component: this._getComponentOwner(),\n        name: renderOptions.name\n      };\n      template.render({\n        model: data,\n        container: getPublicElement($container)\n      });\n    } else {\n      var $editor = $(\"<div>\").appendTo($container);\n\n      try {\n        editorInstance = this._createComponent($editor, renderOptions.editorType, editorOptions);\n        editorInstance.setAria(\"describedby\", renderOptions.helpID);\n        editorInstance.setAria(\"labelledby\", renderOptions.labelID);\n        editorInstance.setAria(\"required\", renderOptions.isRequired);\n\n        if (renderOptions.dataField) {\n          this._bindDataField(editorInstance, renderOptions, $container);\n        }\n      } catch (e) {\n        errors.log(\"E1035\", e.message);\n      }\n    }\n\n    return editorInstance;\n  },\n  _getComponentOwner: function _getComponentOwner() {\n    return this.option(\"form\") || this;\n  },\n  _bindDataField: function _bindDataField(editorInstance, renderOptions, $container) {\n    var componentOwner = this._getComponentOwner();\n\n    editorInstance.on(\"enterKey\", function (args) {\n      componentOwner._createActionByOption(\"onEditorEnterKey\")(extend(args, {\n        dataField: renderOptions.dataField\n      }));\n    });\n\n    this._createWatcher(editorInstance, $container, renderOptions);\n\n    this.linkEditorToDataField(editorInstance, renderOptions.dataField, renderOptions.editorType);\n  },\n  _createWatcher: function _createWatcher(editorInstance, $container, renderOptions) {\n    var that = this;\n\n    var watch = that._getWatch();\n\n    if (!isFunction(watch)) {\n      return;\n    }\n\n    var dispose = watch(function () {\n      return that._getDataByField(renderOptions.dataField);\n    }, function () {\n      editorInstance.option(\"value\", that._getDataByField(renderOptions.dataField));\n    }, {\n      deep: true,\n      skipImmediate: true\n    });\n    eventsEngine.on($container, removeEvent, dispose);\n  },\n  _getWatch: function _getWatch() {\n    if (!isDefined(this._watch)) {\n      var formInstance = this.option(\"form\");\n      this._watch = formInstance && formInstance.option(\"integrationOptions.watchMethod\");\n    }\n\n    return this._watch;\n  },\n  _addItemContentClasses: function _addItemContentClasses($itemContent) {\n    var locationSpecificClass = this._getItemContentLocationSpecificClass();\n\n    $itemContent.addClass([FIELD_ITEM_CONTENT_CLASS, locationSpecificClass].join(\" \"));\n  },\n  _getItemContentLocationSpecificClass: function _getItemContentLocationSpecificClass() {\n    var labelLocation = this.option(\"labelLocation\");\n    return FIELD_ITEM_CONTENT_LOCATION_CLASS + {\n      right: \"left\",\n      left: \"right\",\n      top: \"bottom\"\n    }[labelLocation];\n  },\n  _createComponent: function _createComponent($editor, type, editorOptions) {\n    var readOnlyState = this.option(\"readOnly\");\n    var instance = this.callBase($editor, type, editorOptions);\n    readOnlyState && instance.option(\"readOnly\", readOnlyState);\n    this.on(\"optionChanged\", function (args) {\n      if (\"readOnly\" === args.name && !isDefined(editorOptions.readOnly)) {\n        instance.option(args.name, args.value);\n      }\n    });\n    return instance;\n  },\n  _getTemplateByFieldItem: function _getTemplateByFieldItem(fieldItem) {\n    return fieldItem.template ? this._getTemplate(fieldItem.template) : null;\n  },\n  _appendEditorToField: function _appendEditorToField(params) {\n    if (params.$label) {\n      var location = params.labelOptions.location;\n\n      if (\"top\" === location || \"left\" === location) {\n        params.$fieldItem.append(params.$editor);\n      }\n\n      if (\"right\" === location) {\n        params.$fieldItem.prepend(params.$editor);\n      }\n\n      this._addInnerItemAlignmentClass(params.$fieldItem, location);\n    } else {\n      params.$fieldItem.append(params.$editor);\n    }\n  },\n  _addInnerItemAlignmentClass: function _addInnerItemAlignmentClass($fieldItem, location) {\n    if (\"top\" === location) {\n      $fieldItem.addClass(LABEL_VERTICAL_ALIGNMENT_CLASS);\n    } else {\n      $fieldItem.addClass(LABEL_HORIZONTAL_ALIGNMENT_CLASS);\n    }\n  },\n  _renderHelpText: function _renderHelpText(fieldItem, $editor, helpID) {\n    var helpText = fieldItem.helpText;\n    var isSimpleItem = fieldItem.itemType === SIMPLE_ITEM_TYPE;\n\n    if (helpText && isSimpleItem) {\n      var $editorWrapper = $(\"<div>\").addClass(FIELD_ITEM_CONTENT_WRAPPER_CLASS);\n      $editor.wrap($editorWrapper);\n      $(\"<div>\").addClass(FIELD_ITEM_HELP_TEXT_CLASS).attr(\"id\", helpID).text(helpText).appendTo($editor.parent());\n    }\n  },\n  _attachClickHandler: function _attachClickHandler($label, $editor, editorType) {\n    var isBooleanEditors = \"dxCheckBox\" === editorType || \"dxSwitch\" === editorType;\n\n    if ($label && isBooleanEditors) {\n      eventsEngine.on($label, clickEventName, function () {\n        eventsEngine.trigger($editor.children(), clickEventName);\n      });\n    }\n  },\n  _generateRatio: function _generateRatio(count, isAutoSize) {\n    var result = [];\n    var ratio;\n    var i;\n\n    for (i = 0; i < count; i++) {\n      ratio = {\n        ratio: 1\n      };\n\n      if (isAutoSize) {\n        ratio.baseSize = \"auto\";\n      }\n\n      result.push(ratio);\n    }\n\n    return result;\n  },\n  _getRowsCount: function _getRowsCount() {\n    return Math.ceil(this._items.length / this._getColCount());\n  },\n  _updateReferencedOptions: function _updateReferencedOptions(newLayoutData) {\n    var _this2 = this;\n\n    var layoutData = this.option(\"layoutData\");\n\n    if (isObject(layoutData)) {\n      Object.getOwnPropertyNames(layoutData).forEach(function (property) {\n        return delete _this2._optionsByReference[\"layoutData.\" + property];\n      });\n    }\n\n    if (isObject(newLayoutData)) {\n      Object.getOwnPropertyNames(newLayoutData).forEach(function (property) {\n        return _this2._optionsByReference[\"layoutData.\" + property] = true;\n      });\n    }\n  },\n  _resetWidget: function _resetWidget(instance) {\n    this._disableEditorValueChangedHandler = true;\n    instance.reset();\n    this._disableEditorValueChangedHandler = false;\n    instance.option(\"isValid\", true);\n  },\n  _optionChanged: function _optionChanged(args) {\n    var _this3 = this;\n\n    if (0 === args.fullName.search(\"layoutData.\")) {\n      return;\n    }\n\n    switch (args.name) {\n      case \"showRequiredMark\":\n      case \"showOptionalMark\":\n      case \"requiredMark\":\n      case \"optionalMark\":\n        this._cashedRequiredConfig = null;\n\n        this._invalidate();\n\n        break;\n\n      case \"layoutData\":\n        this._updateReferencedOptions(args.value);\n\n        if (this.option(\"items\")) {\n          if (!isEmptyObject(args.value)) {\n            this._itemsRunTimeInfo.each(function (_, itemRunTimeInfo) {\n              if (isDefined(itemRunTimeInfo.item)) {\n                var dataField = itemRunTimeInfo.item.dataField;\n\n                if (dataField && isDefined(itemRunTimeInfo.widgetInstance)) {\n                  var valueGetter = compileGetter(dataField);\n                  var dataValue = valueGetter(args.value);\n\n                  if (void 0 !== dataValue || _this3._isCheckboxUndefinedStateEnabled(itemRunTimeInfo.item)) {\n                    itemRunTimeInfo.widgetInstance.option(\"value\", dataValue);\n                  } else {\n                    _this3._resetWidget(itemRunTimeInfo.widgetInstance);\n                  }\n                }\n              }\n            });\n          }\n        } else {\n          this._initDataAndItems(args.value);\n\n          this._invalidate();\n        }\n\n        break;\n\n      case \"items\":\n        this._cleanItemWatchers();\n\n        this._initDataAndItems(args.value);\n\n        this._invalidate();\n\n        break;\n\n      case \"alignItemLabels\":\n      case \"labelLocation\":\n      case \"requiredMessage\":\n        this._invalidate();\n\n        break;\n\n      case \"customizeItem\":\n        this._updateItems(this.option(\"layoutData\"));\n\n        this._invalidate();\n\n        break;\n\n      case \"colCount\":\n        this._resetColCount();\n\n        break;\n\n      case \"minColWidth\":\n        if (\"auto\" === this.option(\"colCount\")) {\n          this._resetColCount();\n        }\n\n        break;\n\n      case \"readOnly\":\n        break;\n\n      case \"width\":\n        this.callBase(args);\n\n        if (\"auto\" === this.option(\"colCount\")) {\n          this._resetColCount();\n        }\n\n        break;\n\n      case \"onFieldDataChanged\":\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _resetColCount: function _resetColCount() {\n    this._cashedColCount = null;\n\n    this._invalidate();\n  },\n  linkEditorToDataField: function linkEditorToDataField(editorInstance, dataField) {\n    var _this4 = this;\n\n    this.on(\"optionChanged\", function (args) {\n      if (args.fullName === \"layoutData.\".concat(dataField)) {\n        editorInstance._setOptionWithoutOptionChange(\"value\", args.value);\n      }\n    });\n    editorInstance.on(\"valueChanged\", function (args) {\n      var isValueReferenceType = isObject(args.value) || Array.isArray(args.value);\n\n      if (!_this4._disableEditorValueChangedHandler && !(isValueReferenceType && args.value === args.previousValue)) {\n        _this4._updateFieldValue(dataField, args.value);\n      }\n    });\n  },\n  _dimensionChanged: function _dimensionChanged() {\n    if (\"auto\" === this.option(\"colCount\") && this.isCachedColCountObsolete()) {\n      this._eventsStrategy.fireEvent(\"autoColCountChanged\");\n    }\n  },\n  getItemID: function getItemID(name) {\n    var formInstance = this.option(\"form\");\n    return formInstance && formInstance.getItemID(name);\n  },\n  updateData: function updateData(data, value) {\n    var that = this;\n\n    if (isObject(data)) {\n      each(data, function (dataField, fieldValue) {\n        that._updateFieldValue(dataField, fieldValue);\n      });\n    } else if (\"string\" === typeof data) {\n      that._updateFieldValue(data, value);\n    }\n  },\n  getEditor: function getEditor(field) {\n    return this._itemsRunTimeInfo.findWidgetInstanceByDataField(field) || this._itemsRunTimeInfo.findWidgetInstanceByName(field);\n  },\n  isSingleColumnMode: function isSingleColumnMode(component) {\n    var responsiveBox = this._responsiveBox || component;\n\n    if (responsiveBox) {\n      return responsiveBox.option(\"currentScreenFactor\") === responsiveBox.option(\"singleColumnScreen\");\n    }\n  },\n  getItemsRunTimeInfo: function getItemsRunTimeInfo() {\n    return this._itemsRunTimeInfo;\n  }\n});\nregisterComponent(\"dxLayoutManager\", LayoutManager);\nexport default LayoutManager;","map":null,"metadata":{},"sourceType":"module"}