{"ast":null,"code":"import _classCallCheck from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/appointment_model.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport config from \"../../core/config\";\nimport { map, each } from \"../../core/utils/iterator\";\nimport dateSerialization from \"../../core/utils/date_serialization\";\nimport { getRecurrenceProcessor } from \"./recurrence\";\nimport dateUtils from \"../../core/utils/date\";\nimport { equalByValue } from \"../../core/utils/common\";\nimport { isFunction, isDefined, isString } from \"../../core/utils/type\";\nimport { inArray, wrapToArray } from \"../../core/utils/array\";\nimport { extend } from \"../../core/utils/extend\";\nimport query from \"../../data/query\";\nimport { Deferred } from \"../../core/utils/deferred\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar DATE_FILTER_POSITION = 0;\nvar USER_FILTER_POSITION = 1;\n\nvar FilterMaker = /*#__PURE__*/function () {\n  function FilterMaker(dataAccessors) {\n    _classCallCheck(this, FilterMaker);\n\n    this._filterRegistry = null;\n    this._dataAccessors = dataAccessors;\n  }\n\n  _createClass(FilterMaker, [{\n    key: \"isRegistered\",\n    value: function isRegistered() {\n      return !!this._filterRegistry;\n    }\n  }, {\n    key: \"clearRegistry\",\n    value: function clearRegistry() {\n      delete this._filterRegistry;\n    }\n  }, {\n    key: \"make\",\n    value: function make(type, args) {\n      if (!this._filterRegistry) {\n        this._filterRegistry = {};\n      }\n\n      this._make(type).apply(this, args);\n    }\n  }, {\n    key: \"_make\",\n    value: function _make(type) {\n      var _this = this;\n\n      switch (type) {\n        case \"date\":\n          return function (min, max, useAccessors) {\n            var startDate = useAccessors ? _this._dataAccessors.getter.startDate : _this._dataAccessors.expr.startDateExpr;\n            var endDate = useAccessors ? _this._dataAccessors.getter.endDate : _this._dataAccessors.expr.endDateExpr;\n            var recurrenceRule = _this._dataAccessors.expr.recurrenceRuleExpr;\n            _this._filterRegistry.date = [[[endDate, \">\", min], [startDate, \"<\", max]], \"or\", [recurrenceRule, \"startswith\", \"freq\"], \"or\", [[endDate, min], [startDate, min]]];\n\n            if (!recurrenceRule) {\n              _this._filterRegistry.date.splice(1, 2);\n            }\n          };\n\n        case \"user\":\n          return function (userFilter) {\n            _this._filterRegistry.user = userFilter;\n          };\n      }\n    }\n  }, {\n    key: \"combine\",\n    value: function combine() {\n      var filter = [];\n      this._filterRegistry.date && filter.push(this._filterRegistry.date);\n      this._filterRegistry.user && filter.push(this._filterRegistry.user);\n      return filter;\n    }\n  }, {\n    key: \"dateFilter\",\n    value: function dateFilter() {\n      return this._filterRegistry.date;\n    }\n  }]);\n\n  return FilterMaker;\n}();\n\nvar compareDateWithStartDayHour = function compareDateWithStartDayHour(startDate, endDate, startDayHour, allDay, severalDays) {\n  var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\n  var result = startDate.getHours() >= startTime.hours && startDate.getMinutes() >= startTime.minutes || endDate.getHours() === startTime.hours && endDate.getMinutes() > startTime.minutes || endDate.getHours() > startTime.hours || severalDays || allDay;\n  return result;\n};\n\nvar compareDateWithEndDayHour = function compareDateWithEndDayHour(options) {\n  var startDate = options.startDate,\n      endDate = options.endDate,\n      startDayHour = options.startDayHour,\n      endDayHour = options.endDayHour,\n      viewStartDayHour = options.viewStartDayHour,\n      viewEndDayHour = options.viewEndDayHour,\n      allDay = options.allDay,\n      severalDays = options.severalDays,\n      min = options.min,\n      max = options.max,\n      checkIntersectViewport = options.checkIntersectViewport;\n  var hiddenInterval = (24 - viewEndDayHour + viewStartDayHour) * toMs(\"hour\");\n  var apptDuration = endDate.getTime() - startDate.getTime();\n  var delta = (hiddenInterval - apptDuration) / toMs(\"hour\");\n  var apptStartHour = startDate.getHours();\n  var apptStartMinutes = startDate.getMinutes();\n  var result;\n  var endTime = dateUtils.dateTimeFromDecimal(endDayHour);\n  var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\n  var apptIntersectViewport = startDate < max && endDate > min;\n  result = checkIntersectViewport && apptIntersectViewport || apptStartHour < endTime.hours || apptStartHour === endTime.hours && apptStartMinutes < endTime.minutes || allDay && startDate <= max || severalDays && apptIntersectViewport && (apptStartHour < endTime.hours || 60 * endDate.getHours() + endDate.getMinutes() > 60 * startTime.hours);\n\n  if (apptDuration < hiddenInterval) {\n    if (apptStartHour > endTime.hours && apptStartMinutes > endTime.minutes && delta <= apptStartHour - endDayHour) {\n      result = false;\n    }\n  }\n\n  return result;\n};\n\nvar AppointmentModel = /*#__PURE__*/function () {\n  function AppointmentModel(dataSource, dataAccessors, baseAppointmentDuration) {\n    _classCallCheck(this, AppointmentModel);\n\n    this.setDataAccessors(dataAccessors);\n    this.setDataSource(dataSource);\n    this._updatedAppointmentKeys = [];\n    this._filterMaker = new FilterMaker(dataAccessors);\n    this._baseAppointmentDuration = baseAppointmentDuration;\n  }\n\n  _createClass(AppointmentModel, [{\n    key: \"keyName\",\n    get: function get() {\n      var store = this._dataSource.store();\n\n      return store.key();\n    }\n  }, {\n    key: \"_createFilter\",\n    value: function _createFilter(min, max, remoteFiltering, dateSerializationFormat) {\n      this._filterMaker.make(\"date\", [min, max]);\n\n      var userFilterPosition = this._excessFiltering() ? this._dataSource.filter()[USER_FILTER_POSITION] : this._dataSource.filter();\n\n      this._filterMaker.make(\"user\", [userFilterPosition]);\n\n      if (remoteFiltering) {\n        this._dataSource.filter(this._combineRemoteFilter(dateSerializationFormat));\n      }\n    }\n  }, {\n    key: \"_excessFiltering\",\n    value: function _excessFiltering() {\n      var dateFilter = this._filterMaker.dateFilter();\n\n      var dataSourceFilter = this._dataSource.filter();\n\n      return dataSourceFilter && (equalByValue(dataSourceFilter, dateFilter) || dataSourceFilter.length && equalByValue(dataSourceFilter[DATE_FILTER_POSITION], dateFilter));\n    }\n  }, {\n    key: \"_combineFilter\",\n    value: function _combineFilter() {\n      return this._filterMaker.combine();\n    }\n  }, {\n    key: \"_getStoreKey\",\n    value: function _getStoreKey(target) {\n      var store = this._dataSource.store();\n\n      return store.keyOf(target);\n    }\n  }, {\n    key: \"_filterAppointmentByResources\",\n    value: function _filterAppointmentByResources(appointment, resources) {\n      var _this2 = this;\n\n      var checkAppointmentResourceValues = function checkAppointmentResourceValues(resourceName, resourceIndex) {\n        var resourceGetter = _this2._dataAccessors.getter.resources[resourceName];\n        var resource;\n\n        if (isFunction(resourceGetter)) {\n          resource = resourceGetter(appointment);\n        }\n\n        var appointmentResourceValues = wrapToArray(resource);\n        var resourceData = map(resources[resourceIndex].items, function (item) {\n          return item.id;\n        });\n\n        for (var j = 0; j < appointmentResourceValues.length; j++) {\n          if (inArray(appointmentResourceValues[j], resourceData) > -1) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      var result = false;\n\n      for (var i = 0; i < resources.length; i++) {\n        var resourceName = resources[i].name;\n        result = checkAppointmentResourceValues(resourceName, i);\n\n        if (!result) {\n          return false;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_filterAppointmentByRRule\",\n    value: function _filterAppointmentByRRule(appointment, min, max, startDayHour, endDayHour, firstDayOfWeek) {\n      var recurrenceRule = appointment.recurrenceRule;\n      var recurrenceException = appointment.recurrenceException;\n      var allDay = appointment.allDay;\n      var result = true;\n      var appointmentStartDate = appointment.startDate;\n      var appointmentEndDate = appointment.endDate;\n      var recurrenceProcessor = getRecurrenceProcessor();\n\n      if (allDay || this._appointmentPartInInterval(appointmentStartDate, appointmentEndDate, startDayHour, endDayHour)) {\n        var trimmedDates = this._trimDates(min, max);\n\n        min = trimmedDates.min;\n        max = new Date(trimmedDates.max.getTime() - toMs(\"minute\"));\n      }\n\n      if (recurrenceRule && !recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {\n        result = appointmentEndDate > min && appointmentStartDate <= max;\n      }\n\n      if (result && recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {\n        result = recurrenceProcessor.hasRecurrence({\n          rule: recurrenceRule,\n          exception: recurrenceException,\n          start: appointmentStartDate,\n          end: appointmentEndDate,\n          min: min,\n          max: max,\n          firstDayOfWeek: firstDayOfWeek\n        });\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_appointmentPartInInterval\",\n    value: function _appointmentPartInInterval(startDate, endDate, startDayHour, endDayHour) {\n      var apptStartDayHour = startDate.getHours();\n      var apptEndDayHour = endDate.getHours();\n      return apptStartDayHour <= startDayHour && apptEndDayHour <= endDayHour && apptEndDayHour >= startDayHour || apptEndDayHour >= endDayHour && apptStartDayHour <= endDayHour && apptStartDayHour >= startDayHour;\n    }\n  }, {\n    key: \"_createAllDayAppointmentFilter\",\n    value: function _createAllDayAppointmentFilter(filterOptions) {\n      var viewStartDayHour = filterOptions.viewStartDayHour,\n          viewEndDayHour = filterOptions.viewEndDayHour;\n      var that = this;\n      return [[function (appointment) {\n        return that.appointmentTakesAllDay(appointment, viewStartDayHour, viewEndDayHour);\n      }]];\n    }\n  }, {\n    key: \"_createCombinedFilter\",\n    value: function _createCombinedFilter(filterOptions, timeZoneCalculator) {\n      var dataAccessors = this._dataAccessors;\n      var min = new Date(filterOptions.min);\n      var max = new Date(filterOptions.max);\n      var getRecurrenceException = filterOptions.recurrenceException;\n      var startDayHour = filterOptions.startDayHour,\n          endDayHour = filterOptions.endDayHour,\n          viewStartDayHour = filterOptions.viewStartDayHour,\n          viewEndDayHour = filterOptions.viewEndDayHour,\n          resources = filterOptions.resources,\n          firstDayOfWeek = filterOptions.firstDayOfWeek,\n          checkIntersectViewport = filterOptions.checkIntersectViewport;\n      var that = this;\n      return [[function (appointment) {\n        var result = true;\n        var startDate = new Date(dataAccessors.getter.startDate(appointment));\n        var endDate = new Date(dataAccessors.getter.endDate(appointment));\n        var appointmentTakesAllDay = that.appointmentTakesAllDay(appointment, viewStartDayHour, viewEndDayHour);\n        var appointmentTakesSeveralDays = that.appointmentTakesSeveralDays(appointment);\n        var isAllDay = dataAccessors.getter.allDay(appointment);\n        var appointmentIsLong = appointmentTakesSeveralDays || appointmentTakesAllDay;\n        var useRecurrence = isDefined(dataAccessors.getter.recurrenceRule);\n        var recurrenceRule;\n\n        if (useRecurrence) {\n          recurrenceRule = dataAccessors.getter.recurrenceRule(appointment);\n        }\n\n        if (resources && resources.length) {\n          result = that._filterAppointmentByResources(appointment, resources);\n        }\n\n        if (appointmentTakesAllDay && false === filterOptions.allDay) {\n          result = false;\n        }\n\n        var startDateTimeZone = dataAccessors.getter.startDateTimeZone(appointment);\n        var endDateTimeZone = dataAccessors.getter.endDateTimeZone(appointment);\n        var comparableStartDate = timeZoneCalculator.createDate(startDate, {\n          appointmentTimeZone: startDateTimeZone,\n          path: \"toGrid\"\n        });\n        var comparableEndDate = timeZoneCalculator.createDate(endDate, {\n          appointmentTimeZone: endDateTimeZone,\n          path: \"toGrid\"\n        });\n\n        if (result && useRecurrence) {\n          var recurrenceException = getRecurrenceException ? getRecurrenceException(appointment) : dataAccessors.getter.recurrenceException(appointment);\n          result = that._filterAppointmentByRRule({\n            startDate: comparableStartDate,\n            endDate: comparableEndDate,\n            recurrenceRule: recurrenceRule,\n            recurrenceException: recurrenceException,\n            allDay: appointmentTakesAllDay\n          }, min, max, startDayHour, endDayHour, firstDayOfWeek);\n        }\n\n        if (result && comparableEndDate < min && appointmentIsLong && !isAllDay && (!useRecurrence || useRecurrence && !recurrenceRule)) {\n          result = false;\n        }\n\n        if (result && isDefined(startDayHour) && (!useRecurrence || !filterOptions.isVirtualScrolling)) {\n          result = compareDateWithStartDayHour(comparableStartDate, comparableEndDate, startDayHour, appointmentTakesAllDay, appointmentTakesSeveralDays);\n        }\n\n        if (result && isDefined(endDayHour)) {\n          result = compareDateWithEndDayHour({\n            startDate: comparableStartDate,\n            endDate: comparableEndDate,\n            startDayHour: startDayHour,\n            endDayHour: endDayHour,\n            viewStartDayHour: viewStartDayHour,\n            viewEndDayHour: viewEndDayHour,\n            allDay: appointmentTakesAllDay,\n            severalDays: appointmentTakesSeveralDays,\n            min: min,\n            max: max,\n            checkIntersectViewport: checkIntersectViewport\n          });\n        }\n\n        if (result && useRecurrence && !recurrenceRule) {\n          if (comparableEndDate < min && !isAllDay) {\n            result = false;\n          }\n        }\n\n        return result;\n      }]];\n    }\n  }, {\n    key: \"setDataSource\",\n    value: function setDataSource(dataSource) {\n      this._dataSource = dataSource;\n      this.cleanModelState();\n\n      this._initStoreChangeHandlers();\n\n      this._filterMaker && this._filterMaker.clearRegistry();\n    }\n  }, {\n    key: \"_initStoreChangeHandlers\",\n    value: function _initStoreChangeHandlers() {\n      var _this3 = this;\n\n      var dataSource = this._dataSource;\n      var store = null === dataSource || void 0 === dataSource ? void 0 : dataSource.store();\n\n      if (store) {\n        store.on(\"updating\", function (newItem) {\n          _this3._updatedAppointment = newItem;\n        });\n        store.on(\"push\", function (pushItems) {\n          var items = dataSource.items();\n          var keyName = store.key();\n          pushItems.forEach(function (pushItem) {\n            var itemExists = 0 !== items.filter(function (item) {\n              return item[keyName] === pushItem.key;\n            }).length;\n\n            if (itemExists) {\n              _this3._updatedAppointmentKeys.push({\n                key: keyName,\n                value: pushItem.key\n              });\n            } else {\n              var data = pushItem.data;\n              data && items.push(data);\n            }\n          });\n          dataSource.load();\n        });\n      }\n    }\n  }, {\n    key: \"getUpdatedAppointment\",\n    value: function getUpdatedAppointment() {\n      return this._updatedAppointment;\n    }\n  }, {\n    key: \"getUpdatedAppointmentKeys\",\n    value: function getUpdatedAppointmentKeys() {\n      return this._updatedAppointmentKeys;\n    }\n  }, {\n    key: \"cleanModelState\",\n    value: function cleanModelState() {\n      this._updatedAppointment = null;\n      this._updatedAppointmentKeys = [];\n    }\n  }, {\n    key: \"setDataAccessors\",\n    value: function setDataAccessors(dataAccessors) {\n      this._dataAccessors = dataAccessors;\n      this._filterMaker = new FilterMaker(dataAccessors);\n    }\n  }, {\n    key: \"filterByDate\",\n    value: function filterByDate(min, max, remoteFiltering, dateSerializationFormat) {\n      if (!this._dataSource) {\n        return;\n      }\n\n      var trimmedDates = this._trimDates(min, max);\n\n      if (!this._filterMaker.isRegistered()) {\n        this._createFilter(trimmedDates.min, trimmedDates.max, remoteFiltering, dateSerializationFormat);\n      } else {\n        var _this$_dataSource$fil;\n\n        this._filterMaker.make(\"date\", [trimmedDates.min, trimmedDates.max]);\n\n        if ((null === (_this$_dataSource$fil = this._dataSource.filter()) || void 0 === _this$_dataSource$fil ? void 0 : _this$_dataSource$fil.length) > 1) {\n          var userFilter = this._serializeRemoteFilter([this._dataSource.filter()[1]], dateSerializationFormat);\n\n          this._filterMaker.make(\"user\", userFilter);\n        }\n\n        if (remoteFiltering) {\n          this._dataSource.filter(this._combineRemoteFilter(dateSerializationFormat));\n        }\n      }\n    }\n  }, {\n    key: \"_combineRemoteFilter\",\n    value: function _combineRemoteFilter(dateSerializationFormat) {\n      var combinedFilter = this._filterMaker.combine();\n\n      return this._serializeRemoteFilter(combinedFilter, dateSerializationFormat);\n    }\n  }, {\n    key: \"_serializeRemoteFilter\",\n    value: function _serializeRemoteFilter(filter, dateSerializationFormat) {\n      if (!Array.isArray(filter)) {\n        return filter;\n      }\n\n      filter = extend([], filter);\n      var startDate = this._dataAccessors.expr.startDateExpr;\n      var endDate = this._dataAccessors.expr.endDateExpr;\n\n      if (isString(filter[0])) {\n        if (config().forceIsoDateParsing && filter.length > 1) {\n          if (filter[0] === startDate || filter[0] === endDate) {\n            filter[filter.length - 1] = dateSerialization.serializeDate(new Date(filter[filter.length - 1]), dateSerializationFormat);\n          }\n        }\n      }\n\n      for (var i = 0; i < filter.length; i++) {\n        filter[i] = this._serializeRemoteFilter(filter[i], dateSerializationFormat);\n      }\n\n      return filter;\n    }\n  }, {\n    key: \"_createAppointmentFilter\",\n    value: function _createAppointmentFilter(filterOptions, timeZoneCalculator) {\n      var combinedFilter = this._createCombinedFilter(filterOptions, timeZoneCalculator);\n\n      if (this._filterMaker.isRegistered()) {\n        this._filterMaker.make(\"user\", void 0);\n\n        var trimmedDates = this._trimDates(filterOptions.min, filterOptions.max);\n\n        this._filterMaker.make(\"date\", [trimmedDates.min, trimmedDates.max, true]);\n\n        var dateFilter = this.customizeDateFilter(this._filterMaker.combine(), timeZoneCalculator);\n        combinedFilter.push([dateFilter]);\n      }\n\n      return combinedFilter;\n    }\n  }, {\n    key: \"filterLoadedAppointments\",\n    value: function filterLoadedAppointments(filterOption, timeZoneCalculator) {\n      var combinedFilter = this._createAppointmentFilter(filterOption, timeZoneCalculator);\n\n      return query(this.getPreparedDataItems()).filter(combinedFilter).toArray();\n    }\n  }, {\n    key: \"filterAllDayAppointments\",\n    value: function filterAllDayAppointments(filterOption) {\n      var combinedFilter = this._createAllDayAppointmentFilter(filterOption);\n\n      return query(this.getPreparedDataItems()).filter(combinedFilter).toArray();\n    }\n  }, {\n    key: \"getPreparedDataItems\",\n    value: function getPreparedDataItems() {\n      var _this4 = this;\n\n      var _this$_dataSource;\n\n      var dataItems = null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.items();\n\n      if (!dataItems) {\n        return [];\n      }\n\n      return map(dataItems, function (item) {\n        var startDate = new Date(_this4._dataAccessors.getter.startDate(item));\n        var endDate = new Date(_this4._dataAccessors.getter.endDate(item));\n\n        _this4.replaceWrongEndDate(item, startDate, endDate);\n\n        return item;\n      });\n    }\n  }, {\n    key: \"replaceWrongEndDate\",\n    value: function replaceWrongEndDate(appointment, startDate, endDate) {\n      if (this._isEndDateWrong(startDate, endDate)) {\n        var isAllDay = this._dataAccessors.getter.allDay(appointment);\n\n        var calculatedEndDate = this._calculateAppointmentEndDate(isAllDay, startDate);\n\n        this._dataAccessors.setter.endDate(appointment, calculatedEndDate);\n      }\n    }\n  }, {\n    key: \"filterLoadedVirtualAppointments\",\n    value: function filterLoadedVirtualAppointments(filterOptions, timeZoneCalculator, groupCount) {\n      var _this5 = this;\n\n      var combinedFilters = [];\n      var itemsToFilter = this.getPreparedDataItems();\n      var needPreFilter = groupCount > 0;\n\n      if (needPreFilter) {\n        itemsToFilter = itemsToFilter.filter(function (item) {\n          for (var i = 0; i < filterOptions.length; ++i) {\n            var resources = filterOptions[i].resources;\n\n            if (_this5._filterAppointmentByResources(item, resources)) {\n              return true;\n            }\n          }\n        });\n      }\n\n      filterOptions.forEach(function (filterOption) {\n        combinedFilters.length && combinedFilters.push(\"or\");\n\n        var filter = _this5._createAppointmentFilter(filterOption, timeZoneCalculator);\n\n        combinedFilters.push(filter);\n      });\n      return query(itemsToFilter).filter(combinedFilters).toArray();\n    }\n  }, {\n    key: \"_trimDates\",\n    value: function _trimDates(min, max) {\n      var minCopy = dateUtils.trimTime(new Date(min));\n      var maxCopy = dateUtils.trimTime(new Date(max));\n      maxCopy.setDate(maxCopy.getDate() + 1);\n      return {\n        min: minCopy,\n        max: maxCopy\n      };\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function hasAllDayAppointments(items, startDayHour, endDayHour) {\n      if (!items) {\n        return false;\n      }\n\n      var that = this;\n      var result = false;\n      each(items, function (index, item) {\n        if (that.appointmentTakesAllDay(item, startDayHour, endDayHour)) {\n          result = true;\n          return false;\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"appointmentTakesAllDay\",\n    value: function appointmentTakesAllDay(appointment, startDayHour, endDayHour) {\n      var dataAccessors = this._dataAccessors;\n      var startDate = dataAccessors.getter.startDate(appointment);\n      var endDate = dataAccessors.getter.endDate(appointment);\n      var allDay = dataAccessors.getter.allDay(appointment);\n      return allDay || this._appointmentHasAllDayDuration(startDate, endDate, startDayHour, endDayHour);\n    }\n  }, {\n    key: \"_appointmentHasAllDayDuration\",\n    value: function _appointmentHasAllDayDuration(startDate, endDate, startDayHour, endDayHour) {\n      startDate = new Date(startDate);\n      endDate = new Date(endDate);\n\n      var appointmentDurationInHours = this._getAppointmentDurationInHours(startDate, endDate);\n\n      return appointmentDurationInHours >= 24 || this._appointmentHasShortDayDuration(startDate, endDate, startDayHour, endDayHour);\n    }\n  }, {\n    key: \"_appointmentHasShortDayDuration\",\n    value: function _appointmentHasShortDayDuration(startDate, endDate, startDayHour, endDayHour) {\n      var appointmentDurationInHours = this._getAppointmentDurationInHours(startDate, endDate);\n\n      var shortDayDurationInHours = endDayHour - startDayHour;\n      return appointmentDurationInHours >= shortDayDurationInHours && startDate.getHours() === startDayHour && endDate.getHours() === endDayHour;\n    }\n  }, {\n    key: \"_getAppointmentDurationInHours\",\n    value: function _getAppointmentDurationInHours(startDate, endDate) {\n      return (endDate.getTime() - startDate.getTime()) / toMs(\"hour\");\n    }\n  }, {\n    key: \"appointmentTakesSeveralDays\",\n    value: function appointmentTakesSeveralDays(appointment) {\n      var dataAccessors = this._dataAccessors;\n      var startDate = new Date(dataAccessors.getter.startDate(appointment));\n      var endDate = new Date(dataAccessors.getter.endDate(appointment));\n      return !dateUtils.sameDate(startDate, endDate);\n    }\n  }, {\n    key: \"customizeDateFilter\",\n    value: function customizeDateFilter(dateFilter, timeZoneCalculator) {\n      var _this6 = this;\n\n      var currentFilter = extend(true, [], dateFilter);\n      return function (appointment) {\n        var startDate = new Date(_this6._dataAccessors.getter.startDate(appointment));\n        var endDate = new Date(_this6._dataAccessors.getter.endDate(appointment));\n        appointment = extend(true, {}, appointment);\n\n        var startDateTimeZone = _this6._dataAccessors.getter.startDateTimeZone(appointment);\n\n        var endDateTimeZone = _this6._dataAccessors.getter.endDateTimeZone(appointment);\n\n        var comparableStartDate = timeZoneCalculator.createDate(startDate, {\n          appointmentTimeZone: startDateTimeZone,\n          path: \"toGrid\"\n        });\n        var comparableEndDate = timeZoneCalculator.createDate(endDate, {\n          appointmentTimeZone: endDateTimeZone,\n          path: \"toGrid\"\n        });\n\n        _this6._dataAccessors.setter.startDate(appointment, comparableStartDate);\n\n        _this6._dataAccessors.setter.endDate(appointment, comparableEndDate);\n\n        return query([appointment]).filter(currentFilter).toArray().length > 0;\n      }.bind(this);\n    }\n  }, {\n    key: \"_calculateAppointmentEndDate\",\n    value: function _calculateAppointmentEndDate(isAllDay, startDate) {\n      if (isAllDay) {\n        return dateUtils.setToDayEnd(new Date(startDate));\n      }\n\n      return new Date(startDate.getTime() + this._baseAppointmentDuration * toMs(\"minute\"));\n    }\n  }, {\n    key: \"_isEndDateWrong\",\n    value: function _isEndDateWrong(startDate, endDate) {\n      return !endDate || isNaN(endDate.getTime()) || startDate.getTime() > endDate.getTime();\n    }\n  }, {\n    key: \"add\",\n    value: function add(rawAppointment) {\n      var _this7 = this;\n\n      return this._dataSource.store().insert(rawAppointment).done(function () {\n        return _this7._dataSource.load();\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(target, data) {\n      var _this8 = this;\n\n      var key = this._getStoreKey(target);\n\n      var d = new Deferred();\n\n      this._dataSource.store().update(key, data).done(function (result) {\n        return _this8._dataSource.load().done(function () {\n          return d.resolve(result);\n        }).fail(d.reject);\n      }).fail(d.reject);\n\n      return d.promise();\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(rawAppointment) {\n      var _this9 = this;\n\n      var key = this._getStoreKey(rawAppointment);\n\n      return this._dataSource.store().remove(key).done(function () {\n        return _this9._dataSource.load();\n      });\n    }\n  }]);\n\n  return AppointmentModel;\n}();\n\nexport default AppointmentModel;","map":null,"metadata":{},"sourceType":"module"}