{"ast":null,"code":"import _toConsumableArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _get from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/appointmentSettingsGenerator.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../core/utils/date\";\nimport { isEmptyObject } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { getRecurrenceProcessor } from \"./recurrence\";\nimport timeZoneUtils from \"./utils.timeZone.js\";\nvar toMs = dateUtils.dateToMilliseconds;\nexport var AppointmentSettingsGenerator = /*#__PURE__*/function () {\n  function AppointmentSettingsGenerator(scheduler) {\n    _classCallCheck(this, AppointmentSettingsGenerator);\n\n    this.scheduler = scheduler;\n    this.settingsStrategy = this.scheduler.isVirtualScrolling() ? new AppointmentSettingsGeneratorVirtualStrategy(this.scheduler) : new AppointmentSettingsGeneratorBaseStrategy(this.scheduler);\n  }\n\n  _createClass(AppointmentSettingsGenerator, [{\n    key: \"create\",\n    value: function create(rawAppointment) {\n      return this.settingsStrategy.create(rawAppointment);\n    }\n  }]);\n\n  return AppointmentSettingsGenerator;\n}();\nexport var AppointmentSettingsGeneratorBaseStrategy = /*#__PURE__*/function () {\n  function AppointmentSettingsGeneratorBaseStrategy(scheduler) {\n    _classCallCheck(this, AppointmentSettingsGeneratorBaseStrategy);\n\n    this.scheduler = scheduler;\n  }\n\n  _createClass(AppointmentSettingsGeneratorBaseStrategy, [{\n    key: \"timeZoneCalculator\",\n    get: function get() {\n      return this.scheduler.timeZoneCalculator;\n    }\n  }, {\n    key: \"workspace\",\n    get: function get() {\n      return this.scheduler.getWorkSpace();\n    }\n  }, {\n    key: \"viewDataProvider\",\n    get: function get() {\n      return this.workspace.viewDataProvider;\n    }\n  }, {\n    key: \"create\",\n    value: function create(rawAppointment) {\n      var scheduler = this.scheduler;\n      var appointment = scheduler.createAppointmentAdapter(rawAppointment);\n\n      var itemResources = scheduler._resourcesManager.getResourcesFromItem(rawAppointment);\n\n      var isAllDay = this._isAllDayAppointment(rawAppointment);\n\n      var appointmentList = this._createAppointments(appointment, itemResources);\n\n      appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointment);\n\n      if (this._canProcessNotNativeTimezoneDates(appointment)) {\n        appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointment);\n      }\n\n      var gridAppointmentList = this._createGridAppointmentList(appointmentList, appointment);\n\n      gridAppointmentList = this._cropAppointmentsByStartDayHour(gridAppointmentList, rawAppointment, isAllDay);\n      gridAppointmentList = this._getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment);\n      var appointmentInfos = this.createAppointmentInfos(gridAppointmentList, itemResources, isAllDay, appointment.isRecurrent);\n      return appointmentInfos;\n    }\n  }, {\n    key: \"_getProcessedByAppointmentTimeZone\",\n    value: function _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\n      var _this2 = this;\n\n      var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\n\n      if (appointmentList.length > 1 && hasAppointmentTimeZone) {\n        var appointmentOffsets = {\n          startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\n          endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\n        };\n        appointmentList.forEach(function (a) {\n          var sourceOffsets_startDate = _this2.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\n              sourceOffsets_endDate = _this2.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\n\n          var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\n          var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\n\n          if (0 !== startDateOffsetDiff) {\n            a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"));\n          }\n\n          if (0 !== endDateOffsetDiff) {\n            a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"));\n          }\n        });\n      }\n\n      return appointmentList;\n    }\n  }, {\n    key: \"_isAllDayAppointment\",\n    value: function _isAllDayAppointment(rawAppointment) {\n      return this.scheduler.appointmentTakesAllDay(rawAppointment) && this.workspace.supportAllDayRow();\n    }\n  }, {\n    key: \"_createAppointments\",\n    value: function _createAppointments(appointment, resources) {\n      var appointments = this._createRecurrenceAppointments(appointment, resources);\n\n      if (!appointment.isRecurrent && 0 === appointments.length) {\n        appointments.push({\n          startDate: appointment.startDate,\n          endDate: appointment.endDate\n        });\n      }\n\n      appointments = appointments.map(function (item) {\n        var _item$endDate;\n\n        var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\n\n        if (item.startDate.getTime() === resultEndTime) {\n          item.endDate.setTime(resultEndTime + toMs(\"minute\"));\n        }\n\n        return _extends({}, item, {\n          exceptionDate: new Date(item.startDate)\n        });\n      });\n      return appointments;\n    }\n  }, {\n    key: \"_canProcessNotNativeTimezoneDates\",\n    value: function _canProcessNotNativeTimezoneDates(appointment) {\n      var timeZoneName = this.scheduler.option(\"timeZone\");\n      var isTimeZoneSet = !isEmptyObject(timeZoneName);\n\n      if (!isTimeZoneSet) {\n        return false;\n      }\n\n      if (!appointment.isRecurrent) {\n        return false;\n      }\n\n      return !timeZoneUtils.isEqualLocalTimeZone(timeZoneName, appointment.startDate);\n    }\n  }, {\n    key: \"_getProcessedNotNativeDateIfCrossDST\",\n    value: function _getProcessedNotNativeDateIfCrossDST(date, offset) {\n      if (offset < 0) {\n        var newDate = new Date(date);\n        var newDateMinusOneHour = new Date(newDate);\n        newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\n        var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\n        var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\n\n        if (newDateOffset !== newDateMinusOneHourOffset) {\n          return 0;\n        }\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"_getProcessedNotNativeTimezoneDates\",\n    value: function _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\n      var _this3 = this;\n\n      var startDateRange = appointment.startDate;\n      var endDateRange = appointmentList[appointmentList.length - 1].endDate;\n      var startDateRangeOffset = this.timeZoneCalculator.getOffsets(startDateRange).common;\n      var endDateRangeOffset = this.timeZoneCalculator.getOffsets(endDateRange).common;\n      var isChangeOffsetInRange = startDateRangeOffset !== endDateRangeOffset;\n\n      if (isChangeOffsetInRange) {\n        return appointmentList.map(function (item) {\n          var diffStartDateOffset = _this3.timeZoneCalculator.getOffsets(appointment.startDate).common - _this3.timeZoneCalculator.getOffsets(item.startDate).common;\n\n          var diffEndDateOffset = _this3.timeZoneCalculator.getOffsets(appointment.endDate).common - _this3.timeZoneCalculator.getOffsets(item.endDate).common;\n\n          diffStartDateOffset = _this3._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\n          diffEndDateOffset = _this3._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\n          var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\n          var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\n\n          var testNewStartDate = _this3.timeZoneCalculator.createDate(newStartDate, {\n            path: \"toGrid\"\n          });\n\n          var testNewEndDate = _this3.timeZoneCalculator.createDate(newEndDate, {\n            path: \"toGrid\"\n          });\n\n          if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\n            newEndDate = new Date(newStartDate.getTime() + appointment.duration);\n          }\n\n          return _extends({}, item, {\n            startDate: newStartDate,\n            endDate: newEndDate,\n            exceptionDate: new Date(newStartDate)\n          });\n        });\n      }\n\n      return appointmentList;\n    }\n  }, {\n    key: \"_getProcessedLongAppointmentsIfRequired\",\n    value: function _getProcessedLongAppointmentsIfRequired(gridAppointmentList, appointment) {\n      var _this4 = this;\n\n      var rawAppointment = appointment.source();\n      var allDay = this.scheduler.appointmentTakesAllDay(rawAppointment);\n      var dateRange = this.workspace.getDateRange();\n      var renderingStrategy = this.scheduler.getLayoutManager().getRenderingStrategyInstance();\n\n      if (renderingStrategy.needSeparateAppointment(allDay)) {\n        var longStartDateParts = [];\n        var resultDates = [];\n        gridAppointmentList.forEach(function (gridAppointment) {\n          var maxDate = new Date(dateRange[1]);\n          var endDateOfPart = renderingStrategy.normalizeEndDateByViewEnd(rawAppointment, gridAppointment.endDate);\n          longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\n            milliseconds: _this4.scheduler.getWorkSpace().getIntervalDuration(allDay)\n          });\n          var list = longStartDateParts.filter(function (startDatePart) {\n            return new Date(startDatePart) < maxDate;\n          }).map(function (date) {\n            return {\n              startDate: date,\n              endDate: new Date(new Date(date).setMilliseconds(appointment.duration)),\n              source: gridAppointment.source\n            };\n          });\n          resultDates = resultDates.concat(list);\n        });\n        gridAppointmentList = resultDates;\n      }\n\n      return gridAppointmentList;\n    }\n  }, {\n    key: \"_createGridAppointmentList\",\n    value: function _createGridAppointmentList(appointmentList, appointment) {\n      var _this5 = this;\n\n      return appointmentList.map(function (source) {\n        var offsetDifference = appointment.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\n\n        if (0 !== offsetDifference && _this5._canProcessNotNativeTimezoneDates(appointment)) {\n          source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\n          source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\n          source.exceptionDate = new Date(source.startDate);\n        }\n\n        var startDate = _this5.timeZoneCalculator.createDate(source.startDate, {\n          path: \"toGrid\"\n        });\n\n        var endDate = _this5.timeZoneCalculator.createDate(source.endDate, {\n          path: \"toGrid\"\n        });\n\n        return {\n          startDate: startDate,\n          endDate: endDate,\n          source: source\n        };\n      });\n    }\n  }, {\n    key: \"_createExtremeRecurrenceDates\",\n    value: function _createExtremeRecurrenceDates(rawAppointment) {\n      var dateRange = this.scheduler._workSpace.getDateRange();\n\n      var startViewDate = this.scheduler.appointmentTakesAllDay(rawAppointment) ? dateUtils.trimTime(dateRange[0]) : dateRange[0];\n      var endViewDate = dateRange[1];\n      var commonTimeZone = this.scheduler.option(\"timeZone\");\n\n      if (commonTimeZone) {\n        startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\n          path: \"fromGrid\"\n        });\n        endViewDate = this.timeZoneCalculator.createDate(endViewDate, {\n          path: \"fromGrid\"\n        });\n        var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDate);\n\n        if (daylightOffset) {\n          endViewDate = new Date(endViewDate.getTime() + daylightOffset);\n        }\n      }\n\n      return [startViewDate, endViewDate];\n    }\n  }, {\n    key: \"_createRecurrenceOptions\",\n    value: function _createRecurrenceOptions(appointment, groupIndex) {\n      var _this6 = this;\n\n      var _this$_createExtremeR = this._createExtremeRecurrenceDates(appointment.source(), groupIndex),\n          _this$_createExtremeR2 = _slicedToArray(_this$_createExtremeR, 2),\n          minRecurrenceDate = _this$_createExtremeR2[0],\n          maxRecurrenceDate = _this$_createExtremeR2[1];\n\n      return {\n        rule: appointment.recurrenceRule,\n        exception: appointment.recurrenceException,\n        min: minRecurrenceDate,\n        max: maxRecurrenceDate,\n        firstDayOfWeek: this.scheduler.getFirstDayOfWeek(),\n        start: appointment.startDate,\n        end: appointment.endDate,\n        getPostProcessedException: function getPostProcessedException(date) {\n          var timeZoneName = _this6.scheduler.option(\"timeZone\");\n\n          if (isEmptyObject(timeZoneName) || timeZoneUtils.isEqualLocalTimeZone(timeZoneName, date)) {\n            return date;\n          }\n\n          var appointmentOffset = _this6.timeZoneCalculator.getOffsets(appointment.startDate).common;\n\n          var exceptionAppointmentOffset = _this6.timeZoneCalculator.getOffsets(date).common;\n\n          var diff = appointmentOffset - exceptionAppointmentOffset;\n          diff = _this6._getProcessedNotNativeDateIfCrossDST(date, diff);\n          return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"));\n        }\n      };\n    }\n  }, {\n    key: \"_createRecurrenceAppointments\",\n    value: function _createRecurrenceAppointments(appointment, resources) {\n      var duration = appointment.duration;\n\n      var option = this._createRecurrenceOptions(appointment);\n\n      var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n      return generatedStartDates.map(function (date) {\n        var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n        utcDate.setTime(utcDate.getTime() + duration);\n        var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n        return {\n          startDate: new Date(date),\n          endDate: endDate\n        };\n      });\n    }\n  }, {\n    key: \"_cropAppointmentsByStartDayHour\",\n    value: function _cropAppointmentsByStartDayHour(appointments, rawAppointment, isAllDay) {\n      var _this7 = this;\n\n      return appointments.map(function (appointment) {\n        var startDate = new Date(appointment.startDate);\n\n        var firstViewDate = _this7._getAppointmentFirstViewDate(appointment, rawAppointment);\n\n        var startDayHour = _this7._getViewStartDayHour(firstViewDate);\n\n        appointment.startDate = _this7._getAppointmentResultDate({\n          appointment: appointment,\n          rawAppointment: rawAppointment,\n          startDate: startDate,\n          startDayHour: startDayHour,\n          firstViewDate: firstViewDate\n        });\n        return appointment;\n      });\n    }\n  }, {\n    key: \"_getAppointmentFirstViewDate\",\n    value: function _getAppointmentFirstViewDate() {\n      return this.scheduler.getStartViewDate();\n    }\n  }, {\n    key: \"_getViewStartDayHour\",\n    value: function _getViewStartDayHour() {\n      return this.scheduler._getCurrentViewOption(\"startDayHour\");\n    }\n  }, {\n    key: \"_getAppointmentResultDate\",\n    value: function _getAppointmentResultDate(options) {\n      var appointment = options.appointment,\n          rawAppointment = options.rawAppointment,\n          startDayHour = options.startDayHour,\n          firstViewDate = options.firstViewDate;\n      var startDate = options.startDate;\n      var resultDate = new Date(appointment.startDate);\n\n      if (this.scheduler.appointmentTakesAllDay(rawAppointment)) {\n        resultDate = dateUtils.normalizeDate(startDate, firstViewDate);\n      } else {\n        if (startDate < firstViewDate) {\n          startDate = firstViewDate;\n        }\n\n        resultDate = dateUtils.normalizeDate(appointment.startDate, startDate);\n      }\n\n      return dateUtils.roundDateByStartDayHour(resultDate, startDayHour);\n    }\n  }, {\n    key: \"createAppointmentInfos\",\n    value: function createAppointmentInfos(gridAppointments, resources, isAllDay, recurrent) {\n      var _this = this;\n\n      var result = [];\n\n      var _loop = function _loop(i) {\n        var appointment = gridAppointments[i];\n\n        var coordinates = _this.getCoordinates({\n          appointment: appointment,\n          resources: resources,\n          isAllDay: isAllDay,\n          recurrent: recurrent\n        });\n\n        coordinates.forEach(function (coordinate) {\n          extend(coordinate, {\n            info: {\n              appointment: gridAppointments[i],\n              sourceAppointment: gridAppointments[i].source\n            }\n          });\n        });\n        result = result.concat(coordinates);\n      };\n\n      for (var i = 0; i < gridAppointments.length; i++) {\n        _loop(i);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getCoordinates\",\n    value: function getCoordinates(options) {\n      var appointment = options.appointment,\n          resources = options.resources,\n          isAllDay = options.isAllDay;\n      return this.workspace.getCoordinatesByDateInGroup(appointment.startDate, resources, isAllDay);\n    }\n  }]);\n\n  return AppointmentSettingsGeneratorBaseStrategy;\n}();\nexport var AppointmentSettingsGeneratorVirtualStrategy = /*#__PURE__*/function (_AppointmentSettingsG) {\n  _inherits(AppointmentSettingsGeneratorVirtualStrategy, _AppointmentSettingsG);\n\n  var _super = _createSuper(AppointmentSettingsGeneratorVirtualStrategy);\n\n  function AppointmentSettingsGeneratorVirtualStrategy() {\n    _classCallCheck(this, AppointmentSettingsGeneratorVirtualStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AppointmentSettingsGeneratorVirtualStrategy, [{\n    key: \"viewDataProvider\",\n    get: function get() {\n      return this.workspace.viewDataProvider;\n    }\n  }, {\n    key: \"isVerticalGrouping\",\n    get: function get() {\n      return this.workspace._isVerticalGroupedWorkSpace();\n    }\n  }, {\n    key: \"createAppointmentInfos\",\n    value: function createAppointmentInfos(gridAppointments, resources, allDay, recurrent) {\n      var _this8 = this;\n\n      var appointments = allDay ? gridAppointments : gridAppointments.filter(function (_ref) {\n        var source = _ref.source,\n            startDate = _ref.startDate,\n            endDate = _ref.endDate;\n        var groupIndex = source.groupIndex;\n        return _this8.viewDataProvider.isGroupIntersectDateInterval(groupIndex, startDate, endDate);\n      });\n\n      if (recurrent) {\n        return this._createRecurrentAppointmentInfos(appointments, resources, allDay);\n      }\n\n      return _get(_getPrototypeOf(AppointmentSettingsGeneratorVirtualStrategy.prototype), \"createAppointmentInfos\", this).call(this, appointments, resources, allDay, recurrent);\n    }\n  }, {\n    key: \"getCoordinates\",\n    value: function getCoordinates(options) {\n      var appointment = options.appointment,\n          isAllDay = options.isAllDay,\n          resources = options.resources,\n          recurrent = options.recurrent;\n      var startDate = appointment.startDate;\n      var workspace = this.workspace;\n      var groupIndex = !recurrent ? appointment.source.groupIndex : void 0;\n      return workspace.getCoordinatesByDateInGroup(startDate, resources, isAllDay, groupIndex);\n    }\n  }, {\n    key: \"_createRecurrentAppointmentInfos\",\n    value: function _createRecurrentAppointmentInfos(gridAppointments, resources, allDay) {\n      var _this9 = this;\n\n      var result = [];\n      gridAppointments.forEach(function (appointment) {\n        var source = appointment.source;\n        var groupIndex = source.groupIndex;\n\n        var coordinate = _this9.workspace.getCoordinatesByDate(appointment.startDate, groupIndex, allDay);\n\n        if (coordinate) {\n          extend(coordinate, {\n            info: {\n              appointment: appointment,\n              sourceAppointment: source\n            }\n          });\n          result.push(coordinate);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"_cropAppointmentsByStartDayHour\",\n    value: function _cropAppointmentsByStartDayHour(appointments, rawAppointment, isAllDay) {\n      var _this10 = this;\n\n      return appointments.filter(function (appointment) {\n        var firstViewDate = _this10._getAppointmentFirstViewDate(appointment, rawAppointment);\n\n        if (!firstViewDate) {\n          return false;\n        }\n\n        var startDayHour = _this10._getViewStartDayHour(firstViewDate);\n\n        var startDate = new Date(appointment.startDate);\n        appointment.startDate = _this10._getAppointmentResultDate({\n          appointment: appointment,\n          rawAppointment: rawAppointment,\n          startDate: startDate,\n          startDayHour: startDayHour,\n          firstViewDate: firstViewDate\n        });\n        return !isAllDay ? appointment.endDate > appointment.startDate : true;\n      });\n    }\n  }, {\n    key: \"_createRecurrenceAppointments\",\n    value: function _createRecurrenceAppointments(appointment, resources) {\n      var _this11 = this;\n\n      var duration = appointment.duration;\n      var result = [];\n      var groupIndices = this.workspace._getGroupCount() ? this._getGroupIndices(resources) : [0];\n      groupIndices.forEach(function (groupIndex) {\n        var option = _this11._createRecurrenceOptions(appointment, groupIndex);\n\n        var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n        var recurrentInfo = generatedStartDates.map(function (date) {\n          var startDate = new Date(date);\n          var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n          utcDate.setTime(utcDate.getTime() + duration);\n          var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n          return {\n            startDate: startDate,\n            endDate: endDate,\n            groupIndex: groupIndex\n          };\n        });\n        result.push.apply(result, _toConsumableArray(recurrentInfo));\n      });\n      return result;\n    }\n  }, {\n    key: \"_getViewStartDayHour\",\n    value: function _getViewStartDayHour(firstViewDate) {\n      return firstViewDate.getHours();\n    }\n  }, {\n    key: \"_getAppointmentFirstViewDate\",\n    value: function _getAppointmentFirstViewDate(appointment, rawAppointment) {\n      var _this$scheduler$getWo = this.scheduler.getWorkSpace(),\n          viewDataProvider = _this$scheduler$getWo.viewDataProvider;\n\n      var groupIndex = appointment.source.groupIndex;\n      var startDate = appointment.startDate,\n          endDate = appointment.endDate;\n\n      var isAllDay = this._isAllDayAppointment(rawAppointment);\n\n      return viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay);\n    }\n  }, {\n    key: \"_updateGroupIndices\",\n    value: function _updateGroupIndices(appointments, itemResources) {\n      var _this12 = this;\n\n      var groupIndices = this._getGroupIndices(itemResources);\n\n      var result = [];\n      groupIndices.forEach(function (groupIndex) {\n        var groupStartDate = _this12.viewDataProvider.getGroupStartDate(groupIndex);\n\n        if (groupStartDate) {\n          appointments.forEach(function (appointment) {\n            var appointmentCopy = extend({}, appointment);\n            appointmentCopy.groupIndex = groupIndex;\n            result.push(appointmentCopy);\n          });\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"_getGroupIndices\",\n    value: function _getGroupIndices(resources) {\n      var _groupIndices;\n\n      var groupIndices = this.workspace._getGroupIndexes(resources);\n\n      var viewDataProvider = this.workspace.viewDataProvider;\n      var viewDataGroupIndices = viewDataProvider.getGroupIndices();\n\n      if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {\n        groupIndices = [0];\n      }\n\n      return groupIndices.filter(function (groupIndex) {\n        return -1 !== viewDataGroupIndices.indexOf(groupIndex);\n      });\n    }\n  }, {\n    key: \"_createAppointments\",\n    value: function _createAppointments(appointment, resources) {\n      var appointments = _get(_getPrototypeOf(AppointmentSettingsGeneratorVirtualStrategy.prototype), \"_createAppointments\", this).call(this, appointment, resources);\n\n      return !appointment.isRecurrent ? this._updateGroupIndices(appointments, resources) : appointments;\n    }\n  }]);\n\n  return AppointmentSettingsGeneratorVirtualStrategy;\n}(AppointmentSettingsGeneratorBaseStrategy);","map":null,"metadata":{},"sourceType":"module"}