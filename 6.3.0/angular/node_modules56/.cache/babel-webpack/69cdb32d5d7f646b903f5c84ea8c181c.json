{"ast":null,"code":"import _toConsumableArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_data_provider.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { HORIZONTAL_GROUP_ORIENTATION } from \"../constants\";\n\nvar ViewDataGenerator = /*#__PURE__*/function () {\n  function ViewDataGenerator(workspace) {\n    _classCallCheck(this, ViewDataGenerator);\n\n    this.workspace = workspace;\n  }\n\n  _createClass(ViewDataGenerator, [{\n    key: \"workspace\",\n    get: function get() {\n      return this._workspace;\n    },\n    set: function set(value) {\n      this._workspace = value;\n    }\n  }, {\n    key: \"isVerticalGroupedWorkspace\",\n    get: function get() {\n      return this.workspace._isVerticalGroupedWorkSpace();\n    }\n  }, {\n    key: \"isStandaloneAllDayPanel\",\n    get: function get() {\n      return !this.isVerticalGroupedWorkspace && this.workspace.isAllDayPanelVisible;\n    }\n  }, {\n    key: \"_getCompleteViewDataMap\",\n    value: function _getCompleteViewDataMap(options) {\n      var _viewDataMap;\n\n      var rowCountInGroup = options.rowCountInGroup,\n          cellCountInGroupRow = options.cellCountInGroupRow,\n          groupsList = options.groupsList,\n          groupByDate = options.groupByDate,\n          isHorizontalGrouping = options.isHorizontalGrouping,\n          isVerticalGrouping = options.isVerticalGrouping,\n          totalCellCount = options.totalCellCount,\n          groupCount = options.groupCount;\n      var viewDataMap = [];\n      var step = groupByDate ? groupCount : 1;\n\n      var allDayPanelData = this._generateAllDayPanelData(options, cellCountInGroupRow, step);\n\n      var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, step);\n\n      allDayPanelData && viewDataMap.push(allDayPanelData);\n\n      (_viewDataMap = viewDataMap).push.apply(_viewDataMap, _toConsumableArray(viewCellsData));\n\n      if (isHorizontalGrouping && !groupByDate) {\n        viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList);\n      }\n\n      if (isVerticalGrouping) {\n        viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList);\n      }\n\n      if (groupByDate) {\n        viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList);\n      }\n\n      var completeViewDataMap = this._addKeysToCells(viewDataMap, totalCellCount);\n\n      return completeViewDataMap;\n    }\n  }, {\n    key: \"_transformViewDataMapForHorizontalGrouping\",\n    value: function _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\n      var result = viewDataMap.map(function (row) {\n        return row.slice();\n      });\n      groupsList.slice(1).forEach(function (groups, index) {\n        var groupIndex = index + 1;\n        viewDataMap.forEach(function (row, rowIndex) {\n          var _result$rowIndex;\n\n          var nextGroupRow = row.map(function (cellData) {\n            return _extends({}, cellData, {\n              groups: groups,\n              groupIndex: groupIndex\n            });\n          });\n\n          (_result$rowIndex = result[rowIndex]).push.apply(_result$rowIndex, _toConsumableArray(nextGroupRow));\n        });\n      });\n      return result;\n    }\n  }, {\n    key: \"_transformViewDataMapForVerticalGrouping\",\n    value: function _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\n      var result = viewDataMap.map(function (row) {\n        return row.slice();\n      });\n      groupsList.slice(1).forEach(function (groups, index) {\n        var groupIndex = index + 1;\n        var nextGroupMap = viewDataMap.map(function (cellsRow) {\n          var nextRow = cellsRow.map(function (cellData) {\n            return _extends({}, cellData, {\n              groupIndex: groupIndex,\n              groups: groups\n            });\n          });\n          return nextRow;\n        });\n        result.push.apply(result, _toConsumableArray(nextGroupMap));\n      });\n      return result;\n    }\n  }, {\n    key: \"_transformViewDataMapForGroupingByDate\",\n    value: function _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\n      var correctedGroupList = groupsList.slice(1);\n      var correctedGroupCount = correctedGroupList.length;\n      var result = viewDataMap.map(function (cellsRow) {\n        var groupedByDateCellsRow = cellsRow.reduce(function (currentRow, cell) {\n          var rowWithCurrentCell = [].concat(_toConsumableArray(currentRow), [_extends({}, cell, {\n            isFirstGroupCell: true,\n            isLastGroupCell: 0 === correctedGroupCount\n          })], _toConsumableArray(correctedGroupList.map(function (groups, index) {\n            return _extends({}, cell, {\n              groups: groups,\n              groupIndex: index + 1,\n              isFirstGroupCell: false,\n              isLastGroupCell: index === correctedGroupCount - 1\n            });\n          })));\n          return rowWithCurrentCell;\n        }, []);\n        return groupedByDateCellsRow;\n      });\n      return result;\n    }\n  }, {\n    key: \"_addKeysToCells\",\n    value: function _addKeysToCells(viewDataMap, totalColumnCount) {\n      var _viewDataMap$reduce = viewDataMap.reduce(function (_ref, row, rowIndex) {\n        var allDayPanelsCount = _ref.allDayPanelsCount,\n            currentViewDataMap = _ref.currentViewDataMap;\n        var isAllDay = row[0].allDay;\n        var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\n        var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\n        currentViewDataMap[rowIndex].forEach(function (cell, cellIndex) {\n          cell.key = keyBase + cellIndex;\n        });\n        return {\n          allDayPanelsCount: currentAllDayPanelsCount,\n          currentViewDataMap: currentViewDataMap\n        };\n      }, {\n        allDayPanelsCount: 0,\n        currentViewDataMap: viewDataMap\n      }),\n          result = _viewDataMap$reduce.currentViewDataMap;\n\n      return result;\n    }\n  }, {\n    key: \"_getCompleteDateHeaderMap\",\n    value: function _getCompleteDateHeaderMap(options, completeViewDataMap) {\n      var isGenerateWeekDaysHeaderData = options.isGenerateWeekDaysHeaderData;\n      var result = [];\n\n      if (isGenerateWeekDaysHeaderData) {\n        var weekDaysRow = this._generateWeekDaysHeaderRowMap(options, completeViewDataMap);\n\n        result.push(weekDaysRow);\n      }\n\n      var dateRow = this._generateHeaderDateRow(options, completeViewDataMap);\n\n      result.push(dateRow);\n      return result;\n    }\n  }, {\n    key: \"_generateWeekDaysHeaderRowMap\",\n    value: function _generateWeekDaysHeaderRowMap(options, completeViewDataMap) {\n      var groupByDate = options.groupByDate,\n          horizontalGroupCount = options.horizontalGroupCount,\n          cellCountInDay = options.cellCountInDay,\n          getWeekDaysHeaderText = options.getWeekDaysHeaderText,\n          daysInView = options.daysInView;\n      var index = completeViewDataMap[0][0].allDay ? 1 : 0;\n      var colSpan = groupByDate ? horizontalGroupCount * cellCountInDay : cellCountInDay;\n      var weekDaysRow = [];\n\n      for (var dayIndex = 0; dayIndex < daysInView; dayIndex += 1) {\n        var cell = completeViewDataMap[index][dayIndex * cellCountInDay];\n        weekDaysRow.push(_extends({}, cell, {\n          colSpan: colSpan,\n          text: getWeekDaysHeaderText(cell.startDate),\n          isFirstGroupCell: false,\n          isLastGroupCell: false\n        }));\n      }\n\n      return weekDaysRow;\n    }\n  }, {\n    key: \"_generateHeaderDateRow\",\n    value: function _generateHeaderDateRow(options, completeViewDataMap) {\n      var getDateHeaderText = options.getDateHeaderText,\n          today = options.today,\n          groupByDate = options.groupByDate,\n          horizontalGroupCount = options.horizontalGroupCount,\n          cellCountInGroupRow = options.cellCountInGroupRow,\n          groupOrientation = options.groupOrientation,\n          getDateHeaderDate = options.getDateHeaderDate;\n      var dates = [];\n\n      for (var dateIndex = 0; dateIndex < cellCountInGroupRow; dateIndex += 1) {\n        dates.push(getDateHeaderDate(dateIndex));\n      }\n\n      var index = completeViewDataMap[0][0].allDay ? 1 : 0;\n      var columnCount = completeViewDataMap[index].length;\n      var dateHeaderColumnCount = groupByDate ? columnCount / horizontalGroupCount : columnCount;\n      var colSpan = groupByDate ? horizontalGroupCount : 1;\n      var isVerticalGrouping = \"vertical\" === groupOrientation;\n      var slicedByColumnsData = completeViewDataMap[index].slice(0, dateHeaderColumnCount);\n      return slicedByColumnsData.map(function (_ref2, index) {\n        var startDate = _ref2.startDate,\n            isFirstGroupCell = _ref2.isFirstGroupCell,\n            isLastGroupCell = _ref2.isLastGroupCell,\n            restProps = _objectWithoutPropertiesLoose(_ref2, [\"startDate\", \"endDate\", \"isFirstGroupCell\", \"isLastGroupCell\"]);\n\n        return _extends({}, restProps, {\n          startDate: dates[index % cellCountInGroupRow],\n          text: getDateHeaderText(index % cellCountInGroupRow),\n          today: dateUtils.sameDate(startDate, today),\n          colSpan: colSpan,\n          isFirstGroupCell: groupByDate || isFirstGroupCell && !isVerticalGrouping,\n          isLastGroupCell: groupByDate || isLastGroupCell && !isVerticalGrouping\n        });\n      });\n    }\n  }, {\n    key: \"_getCompleteTimePanelMap\",\n    value: function _getCompleteTimePanelMap(options, completeViewDataMap) {\n      var rowCountInGroup = options.rowCountInGroup,\n          getTimeCellDate = options.getTimeCellDate;\n      var times = [];\n\n      for (var rowIndex = 0; rowIndex < rowCountInGroup; rowIndex += 1) {\n        times.push(getTimeCellDate(rowIndex));\n      }\n\n      var allDayRowsCount = 0;\n      return completeViewDataMap.map(function (row, index) {\n        var _row$ = row[0],\n            allDay = _row$.allDay,\n            startDate = _row$.startDate,\n            restCellProps = _objectWithoutPropertiesLoose(_row$, [\"allDay\", \"startDate\", \"endDate\"]);\n\n        if (allDay) {\n          allDayRowsCount += 1;\n        }\n\n        var timeIndex = (index - allDayRowsCount) % rowCountInGroup;\n        return _extends({}, restCellProps, {\n          allDay: allDay,\n          startDate: allDay ? startDate : times[timeIndex]\n        });\n      });\n    }\n  }, {\n    key: \"_generateViewDataMap\",\n    value: function _generateViewDataMap(completeViewDataMap, options) {\n      var rowCount = options.rowCount,\n          startCellIndex = options.startCellIndex,\n          cellCount = options.cellCount;\n      var startRowIndex = options.startRowIndex;\n\n      var sliceCells = function sliceCells(row, rowIndex, startIndex, count) {\n        return row.slice(startIndex, startIndex + count).map(function (cellData, cellIndex) {\n          return {\n            cellData: cellData,\n            position: {\n              rowIndex: rowIndex,\n              cellIndex: cellIndex\n            }\n          };\n        });\n      };\n\n      var correctedStartRowIndex = startRowIndex;\n      var allDayPanelMap = [];\n\n      if (this.isStandaloneAllDayPanel) {\n        correctedStartRowIndex++;\n        allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount);\n      }\n\n      var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount).map(function (row, rowIndex) {\n        return sliceCells(row, rowIndex, startCellIndex, cellCount);\n      });\n      return {\n        allDayPanelMap: allDayPanelMap,\n        dateTableMap: dateTableMap\n      };\n    }\n  }, {\n    key: \"_generateDateHeaderData\",\n    value: function _generateDateHeaderData(completeDateHeaderMap, options) {\n      var isGenerateWeekDaysHeaderData = options.isGenerateWeekDaysHeaderData,\n          cellCountInDay = options.cellCountInDay,\n          cellWidth = options.cellWidth,\n          isProvideVirtualCellsWidth = options.isProvideVirtualCellsWidth;\n      var dataMap = [];\n      var weekDayRowConfig = {};\n      var validCellWidth = cellWidth || 0;\n\n      if (isGenerateWeekDaysHeaderData) {\n        weekDayRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, cellCountInDay, 0, validCellWidth);\n        dataMap.push(weekDayRowConfig.dateRow);\n      }\n\n      var datesRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, 1, isGenerateWeekDaysHeaderData ? 1 : 0, validCellWidth);\n\n      dataMap.push(datesRowConfig.dateRow);\n      return {\n        dataMap: dataMap,\n        leftVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.leftVirtualCellWidth : void 0,\n        rightVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.rightVirtualCellWidth : void 0,\n        leftVirtualCellCount: datesRowConfig.leftVirtualCellCount,\n        rightVirtualCellCount: datesRowConfig.rightVirtualCellCount,\n        weekDayLeftVirtualCellWidth: weekDayRowConfig.leftVirtualCellWidth,\n        weekDayRightVirtualCellWidth: weekDayRowConfig.rightVirtualCellWidth,\n        weekDayLeftVirtualCellCount: weekDayRowConfig.leftVirtualCellCount,\n        weekDayRightVirtualCellCount: weekDayRowConfig.rightVirtualCellCount\n      };\n    }\n  }, {\n    key: \"_generateDateHeaderDataRow\",\n    value: function _generateDateHeaderDataRow(options, completeDateHeaderMap, baseColSpan, rowIndex, cellWidth) {\n      var groupByDate = options.groupByDate,\n          horizontalGroupCount = options.horizontalGroupCount,\n          startCellIndex = options.startCellIndex,\n          cellCount = options.cellCount,\n          totalCellCount = options.totalCellCount,\n          isProvideVirtualCellsWidth = options.isProvideVirtualCellsWidth;\n      var colSpan = groupByDate ? horizontalGroupCount * baseColSpan : baseColSpan;\n      var leftVirtualCellCount = Math.floor(startCellIndex / colSpan);\n      var actualCellCount = Math.ceil((startCellIndex + cellCount) / colSpan);\n      var dateRow = completeDateHeaderMap[rowIndex].slice(leftVirtualCellCount, actualCellCount);\n      var finalLeftVirtualCellCount = leftVirtualCellCount * colSpan;\n      var finalLeftVirtualCellWidth = finalLeftVirtualCellCount * cellWidth;\n      var finalRightVirtualCellCount = totalCellCount - actualCellCount * colSpan;\n      var finalRightVirtualCellWidth = finalRightVirtualCellCount * cellWidth;\n      return {\n        dateRow: dateRow,\n        leftVirtualCellCount: finalLeftVirtualCellCount,\n        leftVirtualCellWidth: isProvideVirtualCellsWidth ? finalLeftVirtualCellWidth : void 0,\n        rightVirtualCellCount: finalRightVirtualCellCount,\n        rightVirtualCellWidth: isProvideVirtualCellsWidth ? finalRightVirtualCellWidth : void 0\n      };\n    }\n  }, {\n    key: \"_generateTimePanelData\",\n    value: function _generateTimePanelData(completeTimePanelMap, options) {\n      var startRowIndex = options.startRowIndex,\n          rowCount = options.rowCount,\n          topVirtualRowHeight = options.topVirtualRowHeight,\n          bottomVirtualRowHeight = options.bottomVirtualRowHeight,\n          cellCountInGroupRow = options.cellCountInGroupRow;\n      var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();\n      var showAllDayPanel = this.workspace.isAllDayPanelVisible;\n      var indexDifference = this.isVerticalGroupedWorkspace || !showAllDayPanel ? 0 : 1;\n      var correctedStartRowIndex = startRowIndex + indexDifference;\n      var timePanelMap = completeTimePanelMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount);\n      var timePanelData = {\n        topVirtualRowHeight: topVirtualRowHeight,\n        bottomVirtualRowHeight: bottomVirtualRowHeight,\n        isGroupedAllDayPanel: isGroupedAllDayPanel,\n        cellCountInGroupRow: cellCountInGroupRow\n      };\n\n      var _this$_generateTimePa = this._generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel),\n          groupedData = _this$_generateTimePa.previousGroupedData;\n\n      timePanelData.groupedData = groupedData;\n      return timePanelData;\n    }\n  }, {\n    key: \"_generateTimePanelDataFromMap\",\n    value: function _generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel) {\n      return timePanelMap.reduce(function (_ref3, cellData) {\n        var previousGroupIndex = _ref3.previousGroupIndex,\n            previousGroupedData = _ref3.previousGroupedData;\n        var currentGroupIndex = cellData.groupIndex;\n\n        if (currentGroupIndex !== previousGroupIndex) {\n          previousGroupedData.push({\n            dateTable: [],\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\n            groupIndex: currentGroupIndex\n          });\n        }\n\n        if (cellData.allDay) {\n          previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellData;\n        } else {\n          previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellData);\n        }\n\n        return {\n          previousGroupIndex: currentGroupIndex,\n          previousGroupedData: previousGroupedData\n        };\n      }, {\n        previousGroupIndex: -1,\n        previousGroupedData: []\n      });\n    }\n  }, {\n    key: \"_getViewDataFromMap\",\n    value: function _getViewDataFromMap(viewDataMap, options) {\n      var topVirtualRowHeight = options.topVirtualRowHeight,\n          bottomVirtualRowHeight = options.bottomVirtualRowHeight,\n          leftVirtualCellWidth = options.leftVirtualCellWidth,\n          rightVirtualCellWidth = options.rightVirtualCellWidth,\n          cellCountInGroupRow = options.cellCountInGroupRow,\n          totalCellCount = options.totalCellCount,\n          totalRowCount = options.totalRowCount,\n          cellCount = options.cellCount,\n          rowCount = options.rowCount,\n          startRowIndex = options.startRowIndex,\n          startCellIndex = options.startCellIndex,\n          isProvideVirtualCellsWidth = options.isProvideVirtualCellsWidth;\n      var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();\n      var allDayPanelMap = viewDataMap.allDayPanelMap,\n          dateTableMap = viewDataMap.dateTableMap;\n\n      var _dateTableMap$reduce = dateTableMap.reduce(function (_ref4, cellsRow) {\n        var previousGroupIndex = _ref4.previousGroupIndex,\n            previousGroupedData = _ref4.previousGroupedData;\n        var cellDataRow = cellsRow.map(function (_ref5) {\n          var cellData = _ref5.cellData;\n          return cellData;\n        });\n        var firstCell = cellDataRow[0];\n        var isAllDayRow = firstCell.allDay;\n        var currentGroupIndex = firstCell.groupIndex;\n\n        if (currentGroupIndex !== previousGroupIndex) {\n          previousGroupedData.push({\n            dateTable: [],\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\n            groupIndex: currentGroupIndex\n          });\n        }\n\n        if (isAllDayRow) {\n          previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellDataRow;\n        } else {\n          previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellDataRow);\n        }\n\n        return {\n          previousGroupedData: previousGroupedData,\n          previousGroupIndex: currentGroupIndex\n        };\n      }, {\n        previousGroupIndex: -1,\n        previousGroupedData: []\n      }),\n          groupedData = _dateTableMap$reduce.previousGroupedData;\n\n      if (this.isStandaloneAllDayPanel) {\n        groupedData[0].allDayPanel = allDayPanelMap.map(function (_ref6) {\n          var cellData = _ref6.cellData;\n          return cellData;\n        });\n      }\n\n      return {\n        groupedData: groupedData,\n        topVirtualRowHeight: topVirtualRowHeight,\n        bottomVirtualRowHeight: bottomVirtualRowHeight,\n        leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\n        rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\n        cellCountInGroupRow: cellCountInGroupRow,\n        isGroupedAllDayPanel: isGroupedAllDayPanel,\n        leftVirtualCellCount: startCellIndex,\n        rightVirtualCellCount: totalCellCount - startCellIndex - cellCount,\n        topVirtualRowCount: startRowIndex,\n        bottomVirtualRowCount: totalRowCount - startRowIndex - rowCount\n      };\n    }\n  }, {\n    key: \"_generateViewCellsData\",\n    value: function _generateViewCellsData(options, rowsCount) {\n      var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n      var cellCountInGroupRow = options.cellCountInGroupRow,\n          cellDataGetters = options.cellDataGetters;\n      var viewCellsData = [];\n\n      for (var rowIndex = 0; rowIndex < rowsCount; rowIndex += 1) {\n        viewCellsData.push(this._generateCellsRow(options, cellDataGetters, rowIndex, cellCountInGroupRow, step));\n      }\n\n      return viewCellsData;\n    }\n  }, {\n    key: \"_generateAllDayPanelData\",\n    value: function _generateAllDayPanelData(options, cellCount) {\n      var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n      var workSpace = this.workspace;\n\n      if (!workSpace.isAllDayPanelVisible) {\n        return null;\n      }\n\n      return this._generateCellsRow(options, [workSpace._getAllDayCellData.bind(workSpace)], 0, cellCount, step);\n    }\n  }, {\n    key: \"_generateCellsRow\",\n    value: function _generateCellsRow(options, cellDataGetters, rowIndex, columnCount, step) {\n      var _this = this;\n\n      var cellsRow = [];\n\n      var _loop = function _loop(columnIndex) {\n        var correctedColumnIndex = step * columnIndex;\n        var cellDataValue = cellDataGetters.reduce(function (data, getter) {\n          return _extends({}, data, getter(void 0, rowIndex, correctedColumnIndex, 0, data.startDate).value);\n        }, {});\n        cellDataValue.index = rowIndex * columnCount + columnIndex;\n        cellDataValue.isFirstGroupCell = _this._isFirstGroupCell(rowIndex, columnIndex, options);\n        cellDataValue.isLastGroupCell = _this._isLastGroupCell(rowIndex, columnIndex, options);\n        cellsRow.push(cellDataValue);\n      };\n\n      for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\n        _loop(columnIndex);\n      }\n\n      return cellsRow;\n    }\n  }, {\n    key: \"_calculateCellIndex\",\n    value: function _calculateCellIndex(horizontalGroupCount, groupOrientation, isGroupedByDate, rowIndex, columnIndex, columnsNumber) {\n      var groupCount = horizontalGroupCount || 1;\n      var index = rowIndex * columnsNumber + columnIndex;\n      var columnsInGroup = columnsNumber / groupCount;\n\n      if (\"horizontal\" === groupOrientation) {\n        var columnIndexInCurrentGroup = columnIndex % columnsInGroup;\n\n        if (isGroupedByDate) {\n          columnIndexInCurrentGroup = Math.floor(columnIndex / groupCount);\n        }\n\n        index = rowIndex * columnsInGroup + columnIndexInCurrentGroup;\n      }\n\n      return index;\n    }\n  }, {\n    key: \"generateGroupedDataMap\",\n    value: function generateGroupedDataMap(viewDataMap) {\n      var allDayPanelMap = viewDataMap.allDayPanelMap,\n          dateTableMap = viewDataMap.dateTableMap;\n\n      var _dateTableMap$reduce2 = dateTableMap.reduce(function (previousOptions, cellsRow) {\n        var previousGroupedDataMap = previousOptions.previousGroupedDataMap,\n            previousRowIndex = previousOptions.previousRowIndex,\n            previousGroupIndex = previousOptions.previousGroupIndex;\n        var currentGroupIndex = cellsRow[0].cellData.groupIndex;\n        var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\n        cellsRow.forEach(function (cell) {\n          var groupIndex = cell.cellData.groupIndex;\n\n          if (!previousGroupedDataMap[groupIndex]) {\n            previousGroupedDataMap[groupIndex] = [];\n          }\n\n          if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\n            previousGroupedDataMap[groupIndex][currentRowIndex] = [];\n          }\n\n          previousGroupedDataMap[groupIndex][currentRowIndex].push(cell);\n        });\n        return {\n          previousGroupedDataMap: previousGroupedDataMap,\n          previousRowIndex: currentRowIndex,\n          previousGroupIndex: currentGroupIndex\n        };\n      }, {\n        previousGroupedDataMap: [],\n        previousRowIndex: -1,\n        previousGroupIndex: -1\n      }),\n          dateTableGroupedMap = _dateTableMap$reduce2.previousGroupedDataMap;\n\n      var allDayPanelGroupedMap = [];\n      null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(function (cell) {\n        var groupIndex = cell.cellData.groupIndex;\n\n        if (!allDayPanelGroupedMap[groupIndex]) {\n          allDayPanelGroupedMap[groupIndex] = [];\n        }\n\n        allDayPanelGroupedMap[groupIndex].push(cell);\n      });\n      return {\n        allDayPanelGroupedMap: allDayPanelGroupedMap,\n        dateTableGroupedMap: dateTableGroupedMap\n      };\n    }\n  }, {\n    key: \"_isFirstGroupCell\",\n    value: function _isFirstGroupCell(rowIndex, columnIndex, options) {\n      var groupOrientation = options.groupOrientation,\n          rowCountInGroup = options.rowCountInGroup,\n          cellCountInGroupRow = options.cellCountInGroupRow,\n          groupCount = options.groupCount;\n\n      if (this.workspace.isGroupedByDate()) {\n        return columnIndex % groupCount === 0;\n      }\n\n      if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n        return columnIndex % cellCountInGroupRow === 0;\n      }\n\n      return rowIndex % rowCountInGroup === 0;\n    }\n  }, {\n    key: \"_isLastGroupCell\",\n    value: function _isLastGroupCell(rowIndex, columnIndex, options) {\n      var groupOrientation = options.groupOrientation,\n          rowCountInGroup = options.rowCountInGroup,\n          cellCountInGroupRow = options.cellCountInGroupRow,\n          groupCount = options.groupCount;\n\n      if (this.workspace.isGroupedByDate()) {\n        return (columnIndex + 1) % groupCount === 0;\n      }\n\n      if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n        return (columnIndex + 1) % cellCountInGroupRow === 0;\n      }\n\n      return (rowIndex + 1) % rowCountInGroup === 0;\n    }\n  }]);\n\n  return ViewDataGenerator;\n}();\n\nvar GroupedDataMapProvider = /*#__PURE__*/function () {\n  function GroupedDataMapProvider(viewDataGenerator, viewDataMap, completeViewDataMap, workspace) {\n    _classCallCheck(this, GroupedDataMapProvider);\n\n    this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);\n    this.completeViewDataMap = completeViewDataMap;\n    this._workspace = workspace;\n  }\n\n  _createClass(GroupedDataMapProvider, [{\n    key: \"getGroupStartDate\",\n    value: function getGroupStartDate(groupIndex) {\n      var firstRow = this.getFirstGroupRow(groupIndex);\n\n      if (firstRow) {\n        var startDate = firstRow[0].cellData.startDate;\n        return startDate;\n      }\n    }\n  }, {\n    key: \"getGroupEndDate\",\n    value: function getGroupEndDate(groupIndex) {\n      var lastRow = this.getLastGroupRow(groupIndex);\n\n      if (lastRow) {\n        var lastCellIndex = lastRow.length - 1;\n        var cellData = lastRow[lastCellIndex].cellData;\n        var endDate = cellData.endDate;\n        return endDate;\n      }\n    }\n  }, {\n    key: \"findGroupCellStartDate\",\n    value: function findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {\n      if (isAllDay) {\n        return this.findAllDayGroupCellStartDate(groupIndex, startDate);\n      }\n\n      var groupData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n      var checkCellStartDate = function checkCellStartDate(rowIndex, cellIndex) {\n        var cellData = groupData[rowIndex][cellIndex].cellData;\n        var secondMin = cellData.startDate,\n            secondMax = cellData.endDate;\n\n        if (dateUtils.intervalsOverlap({\n          firstMin: startDate,\n          firstMax: endDate,\n          secondMin: secondMin,\n          secondMax: secondMax\n        })) {\n          return secondMin;\n        }\n      };\n\n      var startDateVerticalSearch = function () {\n        var cellCount = groupData[0].length;\n\n        for (var cellIndex = 0; cellIndex < cellCount; ++cellIndex) {\n          for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n            var result = checkCellStartDate(rowIndex, cellIndex);\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }();\n\n      var startDateHorizontalSearch = function () {\n        for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n          var row = groupData[rowIndex];\n\n          for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {\n            var result = checkCellStartDate(rowIndex, cellIndex);\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }();\n\n      return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch;\n    }\n  }, {\n    key: \"findAllDayGroupCellStartDate\",\n    value: function findAllDayGroupCellStartDate(groupIndex, startDate) {\n      var groupStartDate = this.getGroupStartDate(groupIndex);\n      return groupStartDate > startDate ? groupStartDate : startDate;\n    }\n  }, {\n    key: \"findCellPositionInMap\",\n    value: function findCellPositionInMap(cellInfo) {\n      var _this2 = this;\n\n      var groupIndex = cellInfo.groupIndex,\n          startDate = cellInfo.startDate,\n          isAllDay = cellInfo.isAllDay,\n          index = cellInfo.index;\n      var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();\n\n      var isStartDateInCell = function isStartDateInCell(cellData) {\n        if (!_this2._workspace.isDateAndTimeView) {\n          return dateUtils.sameDate(startDate, cellData.startDate);\n        }\n\n        var cellStartTime = cellData.startDate.getTime();\n        var cellEndTime = cellData.endDate.getTime();\n        return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime;\n      };\n\n      var _this$groupedDataMap = this.groupedDataMap,\n          allDayPanelGroupedMap = _this$groupedDataMap.allDayPanelGroupedMap,\n          dateTableGroupedMap = _this$groupedDataMap.dateTableGroupedMap;\n      var rows = isAllDay && !this._workspace._isVerticalGroupedWorkSpace() ? [allDayPanelGroupedMap[groupIndex]] || [] : dateTableGroupedMap[groupIndex] || [];\n\n      for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\n        var row = rows[rowIndex];\n\n        for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {\n          var cell = row[cellIndex];\n          var cellData = cell.cellData;\n\n          if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {\n            if (isStartDateInCell(cellData)) {\n              return cell.position;\n            }\n          }\n        }\n      }\n\n      return;\n    }\n  }, {\n    key: \"_isSameGroupIndexAndIndex\",\n    value: function _isSameGroupIndexAndIndex(cellData, groupIndex, index) {\n      return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index);\n    }\n  }, {\n    key: \"getCellsGroup\",\n    value: function getCellsGroup(groupIndex) {\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      var groupData = dateTableGroupedMap[groupIndex];\n\n      if (groupData) {\n        var cellData = groupData[0][0].cellData;\n        return cellData.groups;\n      }\n    }\n  }, {\n    key: \"getCompletedGroupsInfo\",\n    value: function getCompletedGroupsInfo() {\n      var _this3 = this;\n\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      return dateTableGroupedMap.map(function (groupData) {\n        var firstCell = groupData[0][0];\n        var _firstCell$cellData = firstCell.cellData,\n            allDay = _firstCell$cellData.allDay,\n            groupIndex = _firstCell$cellData.groupIndex;\n        return {\n          allDay: allDay,\n          groupIndex: groupIndex,\n          startDate: _this3.getGroupStartDate(groupIndex),\n          endDate: _this3.getGroupEndDate(groupIndex)\n        };\n      }).filter(function (_ref7) {\n        var startDate = _ref7.startDate;\n        return !!startDate;\n      });\n    }\n  }, {\n    key: \"getGroupIndices\",\n    value: function getGroupIndices() {\n      return this.getCompletedGroupsInfo().map(function (_ref8) {\n        var groupIndex = _ref8.groupIndex;\n        return groupIndex;\n      });\n    }\n  }, {\n    key: \"getGroupFromDateTableGroupMap\",\n    value: function getGroupFromDateTableGroupMap(groupIndex) {\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      return dateTableGroupedMap[groupIndex];\n    }\n  }, {\n    key: \"getFirstGroupRow\",\n    value: function getFirstGroupRow(groupIndex) {\n      var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n      if (groupedData) {\n        var cellData = groupedData[0][0].cellData;\n        return !cellData.allDay ? groupedData[0] : groupedData[1];\n      }\n    }\n  }, {\n    key: \"getLastGroupRow\",\n    value: function getLastGroupRow(groupIndex) {\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      var groupedData = dateTableGroupedMap[groupIndex];\n\n      if (groupedData) {\n        var lastRowIndex = groupedData.length - 1;\n        return groupedData[lastRowIndex];\n      }\n    }\n  }, {\n    key: \"getLasGroupCellPosition\",\n    value: function getLasGroupCellPosition(groupIndex) {\n      var groupRow = this.getLastGroupRow(groupIndex);\n      return groupRow[groupRow.length - 1].position;\n    }\n  }, {\n    key: \"getRowCountInGroup\",\n    value: function getRowCountInGroup(groupIndex) {\n      var groupRow = this.getLastGroupRow(groupIndex);\n      var cellAmount = groupRow.length;\n      var lastCellData = groupRow[cellAmount - 1].cellData;\n      var lastCellIndex = lastCellData.index;\n      return (lastCellIndex + 1) / groupRow.length;\n    }\n  }]);\n\n  return GroupedDataMapProvider;\n}();\n\nvar ViewDataProvider = /*#__PURE__*/function () {\n  function ViewDataProvider(workspace) {\n    _classCallCheck(this, ViewDataProvider);\n\n    this._viewDataGenerator = null;\n    this._viewData = [];\n    this._completeViewDataMap = [];\n    this._completeDateHeaderMap = [];\n    this._viewDataMap = [];\n    this._groupedDataMapProvider = null;\n    this._workspace = workspace;\n  }\n\n  _createClass(ViewDataProvider, [{\n    key: \"viewDataGenerator\",\n    get: function get() {\n      if (!this._viewDataGenerator) {\n        this._viewDataGenerator = new ViewDataGenerator(this._workspace);\n      }\n\n      return this._viewDataGenerator;\n    }\n  }, {\n    key: \"completeViewDataMap\",\n    get: function get() {\n      return this._completeViewDataMap;\n    },\n    set: function set(value) {\n      this._completeViewDataMap = value;\n    }\n  }, {\n    key: \"completeDateHeaderMap\",\n    get: function get() {\n      return this._completeDateHeaderMap;\n    },\n    set: function set(value) {\n      this._completeDateHeaderMap = value;\n    }\n  }, {\n    key: \"completeTimePanelMap\",\n    get: function get() {\n      return this._completeTimePanelMap;\n    },\n    set: function set(value) {\n      this._completeTimePanelMap = value;\n    }\n  }, {\n    key: \"viewData\",\n    get: function get() {\n      return this._viewData;\n    },\n    set: function set(value) {\n      this._viewData = value;\n    }\n  }, {\n    key: \"viewDataMap\",\n    get: function get() {\n      return this._viewDataMap;\n    },\n    set: function set(value) {\n      this._viewDataMap = value;\n    }\n  }, {\n    key: \"dateHeaderData\",\n    get: function get() {\n      return this._dateHeaderData;\n    },\n    set: function set(value) {\n      this._dateHeaderData = value;\n    }\n  }, {\n    key: \"timePanelData\",\n    get: function get() {\n      return this._timePanelData;\n    },\n    set: function set(value) {\n      this._timePanelData = value;\n    }\n  }, {\n    key: \"groupedDataMap\",\n    get: function get() {\n      return this._groupedDataMapProvider.groupedDataMap;\n    }\n  }, {\n    key: \"isVerticalGroupedWorkspace\",\n    get: function get() {\n      return this._workspace._isVerticalGroupedWorkSpace();\n    }\n  }, {\n    key: \"update\",\n    value: function update(isGenerateNewViewData) {\n      var viewDataGenerator = this.viewDataGenerator,\n          _workspace = this._workspace;\n\n      var renderOptions = _workspace.generateRenderOptions();\n\n      if (isGenerateNewViewData) {\n        this.completeViewDataMap = viewDataGenerator._getCompleteViewDataMap(renderOptions);\n        this.completeDateHeaderMap = viewDataGenerator._getCompleteDateHeaderMap(renderOptions, this.completeViewDataMap);\n        this.completeTimePanelMap = viewDataGenerator._getCompleteTimePanelMap(renderOptions, this.completeViewDataMap);\n      }\n\n      this.viewDataMap = viewDataGenerator._generateViewDataMap(this.completeViewDataMap, renderOptions);\n      this.viewData = viewDataGenerator._getViewDataFromMap(this.viewDataMap, renderOptions);\n      this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, this._workspace);\n      this.dateHeaderData = viewDataGenerator._generateDateHeaderData(this.completeDateHeaderMap, renderOptions);\n      this.timePanelData = viewDataGenerator._generateTimePanelData(this.completeTimePanelMap, renderOptions);\n    }\n  }, {\n    key: \"getStartDate\",\n    value: function getStartDate() {\n      var groupedData = this.viewData.groupedData;\n      var dateTable = groupedData[0].dateTable;\n      return dateTable[0][0].startDate;\n    }\n  }, {\n    key: \"getGroupStartDate\",\n    value: function getGroupStartDate(groupIndex) {\n      return this._groupedDataMapProvider.getGroupStartDate(groupIndex);\n    }\n  }, {\n    key: \"getGroupEndDate\",\n    value: function getGroupEndDate(groupIndex) {\n      return this._groupedDataMapProvider.getGroupEndDate(groupIndex);\n    }\n  }, {\n    key: \"findGroupCellStartDate\",\n    value: function findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {\n      return this._groupedDataMapProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay);\n    }\n  }, {\n    key: \"findAllDayGroupCellStartDate\",\n    value: function findAllDayGroupCellStartDate(groupIndex, startDate) {\n      return this._groupedDataMapProvider.findAllDayGroupCellStartDate(groupIndex, startDate);\n    }\n  }, {\n    key: \"findCellPositionInMap\",\n    value: function findCellPositionInMap(cellInfo) {\n      return this._groupedDataMapProvider.findCellPositionInMap(cellInfo);\n    }\n  }, {\n    key: \"getCellsGroup\",\n    value: function getCellsGroup(groupIndex) {\n      return this._groupedDataMapProvider.getCellsGroup(groupIndex);\n    }\n  }, {\n    key: \"getCompletedGroupsInfo\",\n    value: function getCompletedGroupsInfo() {\n      return this._groupedDataMapProvider.getCompletedGroupsInfo();\n    }\n  }, {\n    key: \"getGroupIndices\",\n    value: function getGroupIndices() {\n      return this._groupedDataMapProvider.getGroupIndices();\n    }\n  }, {\n    key: \"getLasGroupCellPosition\",\n    value: function getLasGroupCellPosition(groupIndex) {\n      return this._groupedDataMapProvider.getLasGroupCellPosition(groupIndex);\n    }\n  }, {\n    key: \"getRowCountInGroup\",\n    value: function getRowCountInGroup(groupIndex) {\n      return this._groupedDataMapProvider.getRowCountInGroup(groupIndex);\n    }\n  }, {\n    key: \"getCellData\",\n    value: function getCellData(rowIndex, cellIndex, isAllDay) {\n      if (isAllDay && !this.isVerticalGroupedWorkspace) {\n        return this._viewData.groupedData[0].allDayPanel[cellIndex];\n      }\n\n      var dateTableMap = this.viewDataMap.dateTableMap;\n      var cellData = dateTableMap[rowIndex][cellIndex].cellData;\n      return cellData;\n    }\n  }, {\n    key: \"getCellsByGroupIndexAndAllDay\",\n    value: function getCellsByGroupIndexAndAllDay(groupIndex, allDay) {\n      var workspace = this._workspace;\n\n      var rowsPerGroup = workspace._getRowCountWithAllDayRows();\n\n      var isShowAllDayPanel = workspace.isAllDayPanelVisible;\n      var firstRowInGroup = this.isVerticalGroupedWorkspace ? groupIndex * rowsPerGroup : 0;\n      var lastRowInGroup = this.isVerticalGroupedWorkspace ? (groupIndex + 1) * rowsPerGroup - 1 : rowsPerGroup;\n      var correctedFirstRow = isShowAllDayPanel && !allDay ? firstRowInGroup + 1 : firstRowInGroup;\n      var correctedLastRow = allDay ? correctedFirstRow : lastRowInGroup;\n      return this.completeViewDataMap.slice(correctedFirstRow, correctedLastRow + 1).map(function (row) {\n        return row.filter(function (_ref9) {\n          var currentGroupIndex = _ref9.groupIndex;\n          return groupIndex === currentGroupIndex;\n        });\n      });\n    }\n  }, {\n    key: \"getGroupData\",\n    value: function getGroupData(groupIndex) {\n      var groupedData = this.viewData.groupedData;\n\n      if (this.isVerticalGroupedWorkspace) {\n        return groupedData.filter(function (item) {\n          return item.groupIndex === groupIndex;\n        })[0];\n      }\n\n      var filterCells = function filterCells(row) {\n        return null === row || void 0 === row ? void 0 : row.filter(function (cell) {\n          return cell.groupIndex === groupIndex;\n        });\n      };\n\n      var _groupedData$ = groupedData[0],\n          allDayPanel = _groupedData$.allDayPanel,\n          dateTable = _groupedData$.dateTable;\n      var filteredDateTable = [];\n      dateTable.forEach(function (row) {\n        filteredDateTable.push(filterCells(row));\n      });\n      return {\n        allDayPanel: filterCells(allDayPanel),\n        dateTable: filteredDateTable\n      };\n    }\n  }, {\n    key: \"getCellCountWithGroup\",\n    value: function getCellCountWithGroup(groupIndex) {\n      var rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      return dateTableGroupedMap.filter(function (_, index) {\n        return index <= groupIndex;\n      }).reduce(function (previous, row) {\n        return previous + row[rowIndex].length;\n      }, 0);\n    }\n  }, {\n    key: \"getAllDayPanel\",\n    value: function getAllDayPanel(groupIndex) {\n      var groupData = this.getGroupData(groupIndex);\n      return null === groupData || void 0 === groupData ? void 0 : groupData.allDayPanel;\n    }\n  }, {\n    key: \"isGroupIntersectDateInterval\",\n    value: function isGroupIntersectDateInterval(groupIndex, startDate, endDate) {\n      var groupStartDate = this.getGroupStartDate(groupIndex);\n      var groupEndDate = this.getGroupEndDate(groupIndex);\n      return startDate < groupEndDate && endDate > groupStartDate;\n    }\n  }, {\n    key: \"findGlobalCellPosition\",\n    value: function findGlobalCellPosition(date) {\n      var groupIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n      var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n      var completeViewDataMap = this.completeViewDataMap,\n          workspace = this._workspace;\n      var showAllDayPanel = workspace.isAllDayPanelVisible;\n\n      for (var rowIndex = 0; rowIndex < completeViewDataMap.length; rowIndex += 1) {\n        var currentRow = completeViewDataMap[rowIndex];\n\n        for (var columnIndex = 0; columnIndex < currentRow.length; columnIndex += 1) {\n          var cellData = currentRow[columnIndex];\n          var currentStartDate = cellData.startDate,\n              currentEndDate = cellData.endDate,\n              currentGroupIndex = cellData.groupIndex,\n              currentAllDay = cellData.allDay;\n\n          if (groupIndex === currentGroupIndex && allDay === !!currentAllDay && this._compareDatesAndAllDay(date, currentStartDate, currentEndDate, allDay)) {\n            return {\n              position: {\n                columnIndex: columnIndex,\n                rowIndex: showAllDayPanel && !this.isVerticalGroupedWorkspace ? rowIndex - 1 : rowIndex\n              },\n              cellData: cellData\n            };\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_compareDatesAndAllDay\",\n    value: function _compareDatesAndAllDay(date, cellStartDate, cellEndDate, allDay) {\n      var time = date.getTime();\n      var trimmedTime = dateUtils.trimTime(date).getTime();\n      var cellStartTime = cellStartDate.getTime();\n      var cellEndTime = cellEndDate.getTime();\n      return !allDay && time >= cellStartTime && time < cellEndTime || allDay && trimmedTime === cellStartTime;\n    }\n  }, {\n    key: \"getSkippedDaysCount\",\n    value: function getSkippedDaysCount(groupIndex, startDate, endDate, daysCount) {\n      var dateTableGroupedMap = this._groupedDataMapProvider.groupedDataMap.dateTableGroupedMap;\n      var groupedData = dateTableGroupedMap[groupIndex];\n      var includedDays = 0;\n\n      for (var rowIndex = 0; rowIndex < groupedData.length; rowIndex += 1) {\n        for (var columnIndex = 0; columnIndex < groupedData[rowIndex].length; columnIndex += 1) {\n          var cell = groupedData[rowIndex][columnIndex].cellData;\n\n          if (startDate.getTime() < cell.endDate.getTime() && endDate.getTime() > cell.startDate.getTime()) {\n            includedDays += 1;\n          }\n        }\n      }\n\n      var lastCell = groupedData[groupedData.length - 1][groupedData[0].length - 1].cellData;\n      var lastCellStart = dateUtils.trimTime(lastCell.startDate);\n      var daysAfterView = Math.floor((endDate.getTime() - lastCellStart.getTime()) / dateUtils.dateToMilliseconds(\"day\"));\n      var deltaDays = daysAfterView > 0 ? daysAfterView : 0;\n      return daysCount - includedDays - deltaDays;\n    }\n  }]);\n\n  return ViewDataProvider;\n}();\n\nexport { ViewDataProvider as default };","map":null,"metadata":{},"sourceType":"module"}