{"ast":null,"code":"import _classCallCheck from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.work_space.grouped.strategy.horizontal.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport GroupedStrategy from \"./ui.scheduler.work_space.grouped.strategy\";\nvar HORIZONTAL_GROUPED_ATTR = \"dx-group-row-count\";\n\nvar HorizontalGroupedStrategy = /*#__PURE__*/function (_GroupedStrategy) {\n  _inherits(HorizontalGroupedStrategy, _GroupedStrategy);\n\n  var _super = _createSuper(HorizontalGroupedStrategy);\n\n  function HorizontalGroupedStrategy() {\n    _classCallCheck(this, HorizontalGroupedStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HorizontalGroupedStrategy, [{\n    key: \"prepareCellIndexes\",\n    value: function prepareCellIndexes(cellCoordinates, groupIndex, inAllDay) {\n      var groupByDay = this._workSpace.isGroupedByDate();\n\n      if (!groupByDay) {\n        return {\n          rowIndex: cellCoordinates.rowIndex,\n          cellIndex: cellCoordinates.cellIndex + groupIndex * this._workSpace._getCellCount()\n        };\n      } else {\n        return {\n          rowIndex: cellCoordinates.rowIndex,\n          cellIndex: cellCoordinates.cellIndex * this._workSpace._getGroupCount() + groupIndex\n        };\n      }\n    }\n  }, {\n    key: \"calculateCellIndex\",\n    value: function calculateCellIndex(rowIndex, cellIndex) {\n      cellIndex %= this._workSpace._getCellCount();\n      return this._workSpace._getRowCount() * cellIndex + rowIndex;\n    }\n  }, {\n    key: \"getGroupIndex\",\n    value: function getGroupIndex(rowIndex, cellIndex) {\n      var groupByDay = this._workSpace.isGroupedByDate();\n\n      var groupCount = this._workSpace._getGroupCount();\n\n      if (groupByDay) {\n        return cellIndex % groupCount;\n      } else {\n        return Math.floor(cellIndex / this._workSpace._getCellCount());\n      }\n    }\n  }, {\n    key: \"calculateHeaderCellRepeatCount\",\n    value: function calculateHeaderCellRepeatCount() {\n      return this._workSpace._getGroupCount() || 1;\n    }\n  }, {\n    key: \"insertAllDayRowsIntoDateTable\",\n    value: function insertAllDayRowsIntoDateTable() {\n      return false;\n    }\n  }, {\n    key: \"getTotalCellCount\",\n    value: function getTotalCellCount(groupCount) {\n      groupCount = groupCount || 1;\n      return this._workSpace._getCellCount() * groupCount;\n    }\n  }, {\n    key: \"getTotalRowCount\",\n    value: function getTotalRowCount() {\n      return this._workSpace._getRowCount();\n    }\n  }, {\n    key: \"addAdditionalGroupCellClasses\",\n    value: function addAdditionalGroupCellClasses(cellClass, index, i, j) {\n      var applyUnconditionally = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\n      cellClass = this._addLastGroupCellClass(cellClass, index, applyUnconditionally);\n      return this._addFirstGroupCellClass(cellClass, index, applyUnconditionally);\n    }\n  }, {\n    key: \"_addLastGroupCellClass\",\n    value: function _addLastGroupCellClass(cellClass, index, applyUnconditionally) {\n      if (applyUnconditionally) {\n        return \"\".concat(cellClass, \" \").concat(this.getLastGroupCellClass());\n      }\n\n      var groupByDate = this._workSpace.isGroupedByDate();\n\n      if (groupByDate) {\n        if (index % this._workSpace._getGroupCount() === 0) {\n          return \"\".concat(cellClass, \" \").concat(this.getLastGroupCellClass());\n        }\n      } else if (index % this._workSpace._getCellCount() === 0) {\n        return \"\".concat(cellClass, \" \").concat(this.getLastGroupCellClass());\n      }\n\n      return cellClass;\n    }\n  }, {\n    key: \"_addFirstGroupCellClass\",\n    value: function _addFirstGroupCellClass(cellClass, index, applyUnconditionally) {\n      if (applyUnconditionally) {\n        return \"\".concat(cellClass, \" \").concat(this.getFirstGroupCellClass());\n      }\n\n      var groupByDate = this._workSpace.isGroupedByDate();\n\n      if (groupByDate) {\n        if ((index - 1) % this._workSpace._getGroupCount() === 0) {\n          return \"\".concat(cellClass, \" \").concat(this.getFirstGroupCellClass());\n        }\n      } else if ((index - 1) % this._workSpace._getCellCount() === 0) {\n        return \"\".concat(cellClass, \" \").concat(this.getFirstGroupCellClass());\n      }\n\n      return cellClass;\n    }\n  }, {\n    key: \"getHorizontalMax\",\n    value: function getHorizontalMax(groupIndex) {\n      return this._workSpace.getMaxAllowedPosition(groupIndex);\n    }\n  }, {\n    key: \"getVerticalMax\",\n    value: function getVerticalMax(groupIndex) {\n      var isVirtualScrolling = this._workSpace.isVirtualScrolling();\n\n      var correctedGroupIndex = isVirtualScrolling ? groupIndex : 0;\n      return this._workSpace.getMaxAllowedVerticalPosition(correctedGroupIndex);\n    }\n  }, {\n    key: \"calculateTimeCellRepeatCount\",\n    value: function calculateTimeCellRepeatCount() {\n      return 1;\n    }\n  }, {\n    key: \"getWorkSpaceMinWidth\",\n    value: function getWorkSpaceMinWidth() {\n      return getBoundingRect(this._workSpace.$element().get(0)).width - this._workSpace.getTimePanelWidth();\n    }\n  }, {\n    key: \"getAllDayOffset\",\n    value: function getAllDayOffset() {\n      return this._workSpace.getAllDayHeight();\n    }\n  }, {\n    key: \"getAllDayTableHeight\",\n    value: function getAllDayTableHeight() {\n      return getBoundingRect(this._workSpace._$allDayTable.get(0)).height || 0;\n    }\n  }, {\n    key: \"getGroupCountAttr\",\n    value: function getGroupCountAttr(groups) {\n      return {\n        attr: HORIZONTAL_GROUPED_ATTR,\n        count: null === groups || void 0 === groups ? void 0 : groups.length\n      };\n    }\n  }, {\n    key: \"getLeftOffset\",\n    value: function getLeftOffset() {\n      return this._workSpace.getTimePanelWidth();\n    }\n  }, {\n    key: \"_createGroupBoundOffset\",\n    value: function _createGroupBoundOffset(startCell, endCell, cellWidth) {\n      var extraOffset = cellWidth / 2;\n      var startOffset = startCell ? startCell.offset().left - extraOffset : 0;\n      var endOffset = endCell ? endCell.offset().left + cellWidth + extraOffset : 0;\n      return {\n        left: startOffset,\n        right: endOffset,\n        top: 0,\n        bottom: 0\n      };\n    }\n  }, {\n    key: \"_getGroupedByDateBoundOffset\",\n    value: function _getGroupedByDateBoundOffset($cells, cellWidth) {\n      var lastCellIndex = $cells.length - 1;\n      var startCell = $cells.eq(0);\n      var endCell = $cells.eq(lastCellIndex);\n      return this._createGroupBoundOffset(startCell, endCell, cellWidth);\n    }\n  }, {\n    key: \"getGroupBoundsOffset\",\n    value: function getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates) {\n      if (this._workSpace.isGroupedByDate()) {\n        return this._getGroupedByDateBoundOffset($cells, cellWidth);\n      }\n\n      var cellIndex = this._workSpace.getCellIndexByCoordinates(coordinates);\n\n      var groupIndex = coordinates.groupIndex || Math.floor(cellIndex / cellCount);\n      var startCellIndex = groupIndex * cellCount;\n      var startCell = $cells.eq(startCellIndex);\n      var endCell = $cells.eq(startCellIndex + cellCount - 1);\n      return this._createGroupBoundOffset(startCell, endCell, cellWidth);\n    }\n  }, {\n    key: \"getVirtualScrollingGroupBoundsOffset\",\n    value: function getVirtualScrollingGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap) {\n      if (this._workSpace.isGroupedByDate()) {\n        return this._getGroupedByDateBoundOffset($cells, cellWidth);\n      }\n\n      var startCell;\n      var endCell;\n\n      var cellIndex = this._workSpace.getCellIndexByCoordinates(coordinates);\n\n      var groupIndex = coordinates.groupIndex || Math.floor(cellIndex / cellCount);\n      var currentCellGroup = groupedDataMap.dateTableGroupedMap[groupIndex];\n\n      if (currentCellGroup) {\n        var groupRowLength = currentCellGroup[0].length;\n        var groupStartPosition = currentCellGroup[0][0].position;\n        var groupEndPosition = currentCellGroup[0][groupRowLength - 1].position;\n        startCell = $cells.eq(groupStartPosition.cellIndex);\n        endCell = $cells.eq(groupEndPosition.cellIndex);\n      }\n\n      return this._createGroupBoundOffset(startCell, endCell, cellWidth);\n    }\n  }, {\n    key: \"shiftIndicator\",\n    value: function shiftIndicator($indicator, height, rtlOffset, groupIndex) {\n      var offset = this._getIndicatorOffset(groupIndex);\n\n      var horizontalOffset = rtlOffset ? rtlOffset - offset : offset;\n      $indicator.css(\"left\", horizontalOffset);\n      $indicator.css(\"top\", height);\n    }\n  }, {\n    key: \"_getIndicatorOffset\",\n    value: function _getIndicatorOffset(groupIndex) {\n      var groupByDay = this._workSpace.isGroupedByDate();\n\n      return groupByDay ? this._calculateGroupByDateOffset(groupIndex) : this._calculateOffset(groupIndex);\n    }\n  }, {\n    key: \"_calculateOffset\",\n    value: function _calculateOffset(groupIndex) {\n      return this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex + this._workSpace.getIndicatorOffset(groupIndex) + groupIndex;\n    }\n  }, {\n    key: \"_calculateGroupByDateOffset\",\n    value: function _calculateGroupByDateOffset(groupIndex) {\n      return this._workSpace.getIndicatorOffset(0) * this._workSpace._getGroupCount() + this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex;\n    }\n  }, {\n    key: \"getShaderOffset\",\n    value: function getShaderOffset(i, width) {\n      var offset = this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(i - 1) * i;\n      return this._workSpace.option(\"rtlEnabled\") ? getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).width - offset - this._workSpace.getTimePanelWidth() - width : offset;\n    }\n  }, {\n    key: \"getShaderTopOffset\",\n    value: function getShaderTopOffset(i) {\n      return -this.getShaderMaxHeight() * (i > 0 ? 1 : 0);\n    }\n  }, {\n    key: \"getShaderHeight\",\n    value: function getShaderHeight() {\n      var height = this._workSpace.getIndicationHeight();\n\n      return height;\n    }\n  }, {\n    key: \"getShaderMaxHeight\",\n    value: function getShaderMaxHeight() {\n      return getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).height;\n    }\n  }, {\n    key: \"getShaderWidth\",\n    value: function getShaderWidth(i) {\n      return this._workSpace.getIndicationWidth(i);\n    }\n  }, {\n    key: \"getScrollableScrollTop\",\n    value: function getScrollableScrollTop(allDay) {\n      return !allDay ? this._workSpace.getScrollable().scrollTop() : 0;\n    }\n  }, {\n    key: \"getGroupIndexByCell\",\n    value: function getGroupIndexByCell($cell) {\n      var rowIndex = $cell.parent().index();\n      var cellIndex = $cell.index();\n      return this.getGroupIndex(rowIndex, cellIndex);\n    }\n  }]);\n\n  return HorizontalGroupedStrategy;\n}(GroupedStrategy);\n\nexport default HorizontalGroupedStrategy;","map":null,"metadata":{},"sourceType":"module"}