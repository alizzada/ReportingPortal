{"ast":null,"code":"import _toConsumableArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.timeline.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport $ from \"../../../core/renderer\";\nimport { noop } from \"../../../core/utils/common\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport registerComponent from \"../../../core/component_registrator\";\nimport SchedulerWorkSpace from \"./ui.scheduler.work_space.indicator\";\nimport dateUtils from \"../../../core/utils/date\";\nimport tableCreatorModule from \"../table_creator\";\nvar tableCreator = tableCreatorModule.tableCreator;\nimport HorizontalShader from \"../shaders/ui.scheduler.current_time_shader.horizontal\";\nimport { HEADER_CURRENT_TIME_CELL_CLASS } from \"../constants\";\nimport timeZoneUtils from \"../utils.timeZone\";\nimport dxrTimelineDateHeader from \"../../../renovation/ui/scheduler/workspaces/timeline/header_panel/layout.j\";\nvar TIMELINE_CLASS = \"dx-scheduler-timeline\";\nvar GROUP_TABLE_CLASS = \"dx-scheduler-group-table\";\nvar HORIZONTAL_GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-horizontal-grouped\";\nvar HEADER_PANEL_CELL_CLASS = \"dx-scheduler-header-panel-cell\";\nvar HEADER_PANEL_WEEK_CELL_CLASS = \"dx-scheduler-header-panel-week-cell\";\nvar HEADER_ROW_CLASS = \"dx-scheduler-header-row\";\nvar HORIZONTAL = \"horizontal\";\nvar DATE_TABLE_CELL_BORDER = 1;\nvar DATE_TABLE_HEADER_MARGIN = 10;\nvar toMs = dateUtils.dateToMilliseconds;\n\nvar SchedulerTimeline = /*#__PURE__*/function (_SchedulerWorkSpace) {\n  _inherits(SchedulerTimeline, _SchedulerWorkSpace);\n\n  var _super = _createSuper(SchedulerTimeline);\n\n  function SchedulerTimeline() {\n    _classCallCheck(this, SchedulerTimeline);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SchedulerTimeline, [{\n    key: \"verticalGroupTableClass\",\n    get: function get() {\n      return GROUP_TABLE_CLASS;\n    }\n  }, {\n    key: \"viewDirection\",\n    get: function get() {\n      return \"horizontal\";\n    }\n  }, {\n    key: \"renovatedHeaderPanelComponent\",\n    get: function get() {\n      return dxrTimelineDateHeader;\n    }\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      _get(_getPrototypeOf(SchedulerTimeline.prototype), \"_init\", this).call(this);\n\n      this.$element().addClass(TIMELINE_CLASS);\n      this._$sidebarTable = $(\"<div>\").addClass(GROUP_TABLE_CLASS);\n    }\n  }, {\n    key: \"_getCellFromNextRow\",\n    value: function _getCellFromNextRow(direction, isMultiSelection) {\n      if (!isMultiSelection) {\n        return _get(_getPrototypeOf(SchedulerTimeline.prototype), \"_getCellFromNextRow\", this).call(this, direction, isMultiSelection);\n      }\n\n      return this._$focusedCell;\n    }\n  }, {\n    key: \"_getDefaultGroupStrategy\",\n    value: function _getDefaultGroupStrategy() {\n      return \"vertical\";\n    }\n  }, {\n    key: \"_toggleGroupingDirectionClass\",\n    value: function _toggleGroupingDirectionClass() {\n      this.$element().toggleClass(HORIZONTAL_GROUPED_WORKSPACE_CLASS, this._isHorizontalGroupedWorkSpace());\n    }\n  }, {\n    key: \"_getDefaultOptions\",\n    value: function _getDefaultOptions() {\n      return extend(_get(_getPrototypeOf(SchedulerTimeline.prototype), \"_getDefaultOptions\", this).call(this), {\n        groupOrientation: \"vertical\"\n      });\n    }\n  }, {\n    key: \"_getRowCount\",\n    value: function _getRowCount() {\n      return 1;\n    }\n  }, {\n    key: \"_getCellCount\",\n    value: function _getCellCount() {\n      return this._getCellCountInDay() * this.option(\"intervalCount\");\n    }\n  }, {\n    key: \"getGroupTableWidth\",\n    value: function getGroupTableWidth() {\n      return this._$sidebarTable ? this._$sidebarTable.outerWidth() : 0;\n    }\n  }, {\n    key: \"_getTotalRowCount\",\n    value: function _getTotalRowCount(groupCount) {\n      if (this._isHorizontalGroupedWorkSpace()) {\n        return this._getRowCount();\n      } else {\n        groupCount = groupCount || 1;\n        return this._getRowCount() * groupCount;\n      }\n    }\n  }, {\n    key: \"_getDateForHeaderText\",\n    value: function _getDateForHeaderText(index) {\n      var firstViewDate = this._getValidFirstViewDateWithoutDST();\n\n      return this._getDateByIndexCore(firstViewDate, index);\n    }\n  }, {\n    key: \"_getDateByIndexCore\",\n    value: function _getDateByIndexCore(date, index) {\n      var result = new Date(date);\n      var dayIndex = Math.floor(index / this._getCellCountInDay());\n      result.setTime(date.getTime() + this._calculateCellIndex(0, index) * this._getInterval() + dayIndex * this._getHiddenInterval());\n      return result;\n    }\n  }, {\n    key: \"_getDateByIndex\",\n    value: function _getDateByIndex(index) {\n      var firstViewDate = this._getValidFirstViewDateWithoutDST();\n\n      var result = this._getDateByIndexCore(firstViewDate, index);\n\n      if (timeZoneUtils.isTimezoneChangeInDate(this._firstViewDate)) {\n        result.setDate(result.getDate() - 1);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getValidFirstViewDateWithoutDST\",\n    value: function _getValidFirstViewDateWithoutDST() {\n      var newFirstViewDate = timeZoneUtils.getDateWithoutTimezoneChange(this._firstViewDate);\n      newFirstViewDate.setHours(this.option(\"startDayHour\"));\n      return newFirstViewDate;\n    }\n  }, {\n    key: \"_getFormat\",\n    value: function _getFormat() {\n      return \"shorttime\";\n    }\n  }, {\n    key: \"_needApplyLastGroupCellClass\",\n    value: function _needApplyLastGroupCellClass() {\n      return true;\n    }\n  }, {\n    key: \"_calculateHiddenInterval\",\n    value: function _calculateHiddenInterval(rowIndex, cellIndex) {\n      var dayIndex = Math.floor(cellIndex / this._getCellCountInDay());\n      return dayIndex * this._getHiddenInterval();\n    }\n  }, {\n    key: \"_getMillisecondsOffset\",\n    value: function _getMillisecondsOffset(rowIndex, cellIndex) {\n      cellIndex = this._calculateCellIndex(rowIndex, cellIndex);\n      return this._getInterval() * cellIndex + this._calculateHiddenInterval(rowIndex, cellIndex);\n    }\n  }, {\n    key: \"_createWorkSpaceElements\",\n    value: function _createWorkSpaceElements() {\n      this._createWorkSpaceScrollableElements();\n    }\n  }, {\n    key: \"_getWorkSpaceHeight\",\n    value: function _getWorkSpaceHeight() {\n      if (this.option(\"crossScrollingEnabled\")) {\n        return getBoundingRect(this._$dateTable.get(0)).height;\n      }\n\n      return getBoundingRect(this.$element().get(0)).height;\n    }\n  }, {\n    key: \"_dateTableScrollableConfig\",\n    value: function _dateTableScrollableConfig() {\n      var config = _get(_getPrototypeOf(SchedulerTimeline.prototype), \"_dateTableScrollableConfig\", this).call(this);\n\n      var timelineConfig = {\n        direction: HORIZONTAL\n      };\n      return this.option(\"crossScrollingEnabled\") ? config : extend(config, timelineConfig);\n    }\n  }, {\n    key: \"_needCreateCrossScrolling\",\n    value: function _needCreateCrossScrolling() {\n      return true;\n    }\n  }, {\n    key: \"_headerScrollableConfig\",\n    value: function _headerScrollableConfig() {\n      var config = _get(_getPrototypeOf(SchedulerTimeline.prototype), \"_headerScrollableConfig\", this).call(this);\n\n      return extend(config, {\n        scrollByContent: true\n      });\n    }\n  }, {\n    key: \"_renderTimePanel\",\n    value: function _renderTimePanel() {\n      return noop();\n    }\n  }, {\n    key: \"_renderAllDayPanel\",\n    value: function _renderAllDayPanel() {\n      return noop();\n    }\n  }, {\n    key: \"_getTableAllDay\",\n    value: function _getTableAllDay() {\n      return false;\n    }\n  }, {\n    key: \"_getDateHeaderTemplate\",\n    value: function _getDateHeaderTemplate() {\n      return this.option(\"timeCellTemplate\");\n    }\n  }, {\n    key: \"_toggleAllDayVisibility\",\n    value: function _toggleAllDayVisibility() {\n      return noop();\n    }\n  }, {\n    key: \"_changeAllDayVisibility\",\n    value: function _changeAllDayVisibility() {\n      return noop();\n    }\n  }, {\n    key: \"supportAllDayRow\",\n    value: function supportAllDayRow() {\n      return false;\n    }\n  }, {\n    key: \"_getGroupHeaderContainer\",\n    value: function _getGroupHeaderContainer() {\n      if (this._isHorizontalGroupedWorkSpace()) {\n        return this._$thead;\n      }\n\n      return this._$sidebarTable;\n    }\n  }, {\n    key: \"_insertAllDayRowsIntoDateTable\",\n    value: function _insertAllDayRowsIntoDateTable() {\n      return false;\n    }\n  }, {\n    key: \"_createAllDayPanelElements\",\n    value: function _createAllDayPanelElements() {\n      return noop();\n    }\n  }, {\n    key: \"_renderDateHeader\",\n    value: function _renderDateHeader() {\n      var $headerRow = _get(_getPrototypeOf(SchedulerTimeline.prototype), \"_renderDateHeader\", this).call(this);\n\n      if (this._needRenderWeekHeader()) {\n        var firstViewDate = new Date(this._firstViewDate);\n        var currentDate = new Date(firstViewDate);\n        var $cells = [];\n\n        var groupCount = this._getGroupCount();\n\n        var cellCountInDay = this._getCellCountInDay();\n\n        var colSpan = this.isGroupedByDate() ? cellCountInDay * groupCount : cellCountInDay;\n        var cellTemplate = this.option(\"dateCellTemplate\");\n        var horizontalGroupCount = this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate() ? groupCount : 1;\n        var cellsInGroup = this._getWeekDuration() * this.option(\"intervalCount\");\n        var cellsCount = cellsInGroup * horizontalGroupCount;\n\n        for (var templateIndex = 0; templateIndex < cellsCount; templateIndex++) {\n          var $th = $(\"<th>\");\n\n          var text = this._formatWeekdayAndDay(currentDate);\n\n          if (cellTemplate) {\n            var templateOptions = {\n              model: _extends({\n                text: text,\n                date: new Date(currentDate)\n              }, this._getGroupsForDateHeaderTemplate(templateIndex, colSpan)),\n              container: $th,\n              index: templateIndex\n            };\n            cellTemplate.render(templateOptions);\n          } else {\n            $th.text(text);\n          }\n\n          $th.addClass(HEADER_PANEL_CELL_CLASS).addClass(HEADER_PANEL_WEEK_CELL_CLASS).attr(\"colSpan\", colSpan);\n          $cells.push($th);\n\n          if (templateIndex % cellsInGroup === cellsInGroup - 1) {\n            currentDate = new Date(firstViewDate);\n          } else {\n            this._incrementDate(currentDate);\n          }\n        }\n\n        var $row = $(\"<tr>\").addClass(HEADER_ROW_CLASS).append($cells);\n        $headerRow.before($row);\n      }\n    }\n  }, {\n    key: \"_needRenderWeekHeader\",\n    value: function _needRenderWeekHeader() {\n      return false;\n    }\n  }, {\n    key: \"_incrementDate\",\n    value: function _incrementDate(date) {\n      date.setDate(date.getDate() + 1);\n    }\n  }, {\n    key: \"_getWeekDuration\",\n    value: function _getWeekDuration() {\n      return 1;\n    }\n  }, {\n    key: \"_renderView\",\n    value: function _renderView() {\n      this._setFirstViewDate();\n\n      var groupCellTemplates;\n\n      if (!this.isRenovatedRender()) {\n        groupCellTemplates = this._renderGroupHeader();\n      }\n\n      if (this.isRenovatedRender()) {\n        this.renderRWorkspace();\n      } else {\n        this._renderDateHeader();\n\n        this._renderTimePanel();\n\n        this._renderDateTable();\n\n        this._renderAllDayPanel();\n      }\n\n      this._shader = new HorizontalShader(this);\n\n      this._$sidebarTable.appendTo(this._sidebarScrollable.$content());\n\n      if (this.isRenovatedRender() && this._isVerticalGroupedWorkSpace()) {\n        this.renderRGroupPanel();\n      }\n\n      this._applyCellTemplates(groupCellTemplates);\n    }\n  }, {\n    key: \"_setHorizontalGroupHeaderCellsHeight\",\n    value: function _setHorizontalGroupHeaderCellsHeight() {\n      return noop();\n    }\n  }, {\n    key: \"getIndicationCellCount\",\n    value: function getIndicationCellCount() {\n      var timeDiff = this._getTimeDiff();\n\n      return this._calculateDurationInCells(timeDiff);\n    }\n  }, {\n    key: \"_getTimeDiff\",\n    value: function _getTimeDiff() {\n      var today = this._getToday();\n\n      var date = this._getIndicationFirstViewDate();\n\n      return today.getTime() - date.getTime();\n    }\n  }, {\n    key: \"_calculateDurationInCells\",\n    value: function _calculateDurationInCells(timeDiff) {\n      var today = this._getToday();\n\n      var differenceInDays = Math.floor(timeDiff / toMs(\"day\"));\n      var duration = (timeDiff - differenceInDays * toMs(\"day\") - this.option(\"startDayHour\") * toMs(\"hour\")) / this.getCellDuration();\n\n      if (today.getHours() > this.option(\"endDayHour\")) {\n        duration = this._getCellCountInDay();\n      }\n\n      if (duration < 0) {\n        duration = 0;\n      }\n\n      return differenceInDays * this._getCellCountInDay() + duration;\n    }\n  }, {\n    key: \"getIndicationWidth\",\n    value: function getIndicationWidth() {\n      if (this.isGroupedByDate()) {\n        var cellCount = this.getIndicationCellCount();\n        var integerPart = Math.floor(cellCount);\n        var fractionPart = cellCount - integerPart;\n        return this.getCellWidth() * (integerPart * this._getGroupCount() + fractionPart);\n      } else {\n        return this.getIndicationCellCount() * this.getCellWidth();\n      }\n    }\n  }, {\n    key: \"_renderIndicator\",\n    value: function _renderIndicator(height, rtlOffset, $container, groupCount) {\n      var $indicator;\n      var width = this.getIndicationWidth();\n\n      if (\"vertical\" === this.option(\"groupOrientation\")) {\n        $indicator = this._createIndicator($container);\n        $indicator.height(getBoundingRect($container.get(0)).height);\n        $indicator.css(\"left\", rtlOffset ? rtlOffset - width : width);\n      } else {\n        for (var i = 0; i < groupCount; i++) {\n          var offset = this.isGroupedByDate() ? i * this.getCellWidth() : this._getCellCount() * this.getCellWidth() * i;\n          $indicator = this._createIndicator($container);\n          $indicator.height(getBoundingRect($container.get(0)).height);\n          $indicator.css(\"left\", rtlOffset ? rtlOffset - width - offset : width + offset);\n        }\n      }\n    }\n  }, {\n    key: \"_isVerticalShader\",\n    value: function _isVerticalShader() {\n      return false;\n    }\n  }, {\n    key: \"_isCurrentTimeHeaderCell\",\n    value: function _isCurrentTimeHeaderCell() {\n      return false;\n    }\n  }, {\n    key: \"_visibilityChanged\",\n    value: function _visibilityChanged(visible) {\n      _get(_getPrototypeOf(SchedulerTimeline.prototype), \"_visibilityChanged\", this).call(this, visible);\n    }\n  }, {\n    key: \"_setTableSizes\",\n    value: function _setTableSizes() {\n      var _this$virtualScrollin;\n\n      var cellHeight = this.getCellHeight();\n\n      var minHeight = this._getWorkSpaceMinHeight();\n\n      var verticalGroupCount = this._isVerticalGroupedWorkSpace() ? this._getGroupCount() : 1;\n      var height = cellHeight * verticalGroupCount;\n\n      if (height < minHeight) {\n        height = minHeight;\n      }\n\n      this._$sidebarTable.height(height);\n\n      this._$dateTable.height(height);\n\n      _get(_getPrototypeOf(SchedulerTimeline.prototype), \"_setTableSizes\", this).call(this);\n\n      null === (_this$virtualScrollin = this.virtualScrollingDispatcher) || void 0 === _this$virtualScrollin ? void 0 : _this$virtualScrollin.updateDimensions();\n    }\n  }, {\n    key: \"_getWorkSpaceMinHeight\",\n    value: function _getWorkSpaceMinHeight() {\n      var minHeight = this._getWorkSpaceHeight();\n\n      var workspaceContainerHeight = this.$element().outerHeight(true) - this.getHeaderPanelHeight() - 2 * DATE_TABLE_CELL_BORDER - DATE_TABLE_HEADER_MARGIN;\n\n      if (minHeight < workspaceContainerHeight) {\n        minHeight = workspaceContainerHeight;\n      }\n\n      return minHeight;\n    }\n  }, {\n    key: \"_makeGroupRows\",\n    value: function _makeGroupRows(groups, groupByDate) {\n      var tableCreatorStrategy = \"vertical\" === this.option(\"groupOrientation\") ? tableCreator.VERTICAL : tableCreator.HORIZONTAL;\n      return tableCreator.makeGroupedTable(tableCreatorStrategy, groups, {\n        groupRowClass: this._getGroupRowClass(),\n        groupHeaderRowClass: this._getGroupRowClass(),\n        groupHeaderClass: this._getGroupHeaderClass.bind(this),\n        groupHeaderContentClass: this._getGroupHeaderContentClass()\n      }, this._getCellCount() || 1, this.option(\"resourceCellTemplate\"), this._getTotalRowCount(this._getGroupCount()), groupByDate);\n    }\n  }, {\n    key: \"_ensureGroupHeaderCellsHeight\",\n    value: function _ensureGroupHeaderCellsHeight(cellHeight) {\n      var minCellHeight = this._calculateMinCellHeight();\n\n      if (cellHeight < minCellHeight) {\n        return minCellHeight;\n      }\n\n      return cellHeight;\n    }\n  }, {\n    key: \"_calculateMinCellHeight\",\n    value: function _calculateMinCellHeight() {\n      var dateTable = this._getDateTable();\n\n      var dateTableRowSelector = \".\" + this._getDateTableRowClass();\n\n      return getBoundingRect(dateTable).height / dateTable.find(dateTableRowSelector).length - 2 * DATE_TABLE_CELL_BORDER;\n    }\n  }, {\n    key: \"_getCellCoordinatesByIndex\",\n    value: function _getCellCoordinatesByIndex(index) {\n      return {\n        cellIndex: index % this._getCellCount(),\n        rowIndex: 0\n      };\n    }\n  }, {\n    key: \"_getCellByCoordinates\",\n    value: function _getCellByCoordinates(cellCoordinates, groupIndex) {\n      var indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex);\n\n      return this._$dateTable.find(\"tr\").eq(indexes.rowIndex).find(\"td\").eq(indexes.cellIndex);\n    }\n  }, {\n    key: \"_getWorkSpaceWidth\",\n    value: function _getWorkSpaceWidth() {\n      return this._$dateTable.outerWidth(true);\n    }\n  }, {\n    key: \"_getIndicationFirstViewDate\",\n    value: function _getIndicationFirstViewDate() {\n      return dateUtils.trimTime(new Date(this._firstViewDate));\n    }\n  }, {\n    key: \"_getIntervalBetween\",\n    value: function _getIntervalBetween(currentDate, allDay) {\n      var startDayHour = this.option(\"startDayHour\");\n      var endDayHour = this.option(\"endDayHour\");\n      var firstViewDate = this.getStartViewDate();\n      var firstViewDateTime = firstViewDate.getTime();\n      var hiddenInterval = (24 - endDayHour + startDayHour) * toMs(\"hour\");\n      var timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate);\n      var apptStart = currentDate.getTime();\n      var fullInterval = apptStart - firstViewDateTime - timeZoneOffset;\n      var fullDays = Math.floor(fullInterval / toMs(\"day\"));\n      var tailDuration = fullInterval - fullDays * toMs(\"day\");\n      var tailDelta = 0;\n\n      var cellCount = this._getCellCountInDay() * (fullDays - this._getWeekendsCount(fullDays));\n\n      var gapBeforeAppt = apptStart - dateUtils.trimTime(new Date(currentDate)).getTime();\n      var result = cellCount * this.option(\"hoursInterval\") * toMs(\"hour\");\n\n      if (!allDay) {\n        if (currentDate.getHours() < startDayHour) {\n          tailDelta = tailDuration - hiddenInterval + gapBeforeAppt;\n        } else if (currentDate.getHours() >= startDayHour && currentDate.getHours() < endDayHour) {\n          tailDelta = tailDuration;\n        } else if (currentDate.getHours() >= startDayHour && currentDate.getHours() >= endDayHour) {\n          tailDelta = tailDuration - (gapBeforeAppt - endDayHour * toMs(\"hour\"));\n        } else if (!fullDays) {\n          result = fullInterval;\n        }\n\n        result += tailDelta;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getWeekendsCount\",\n    value: function _getWeekendsCount() {\n      return 0;\n    }\n  }, {\n    key: \"getAllDayContainer\",\n    value: function getAllDayContainer() {\n      return null;\n    }\n  }, {\n    key: \"getTimePanelWidth\",\n    value: function getTimePanelWidth() {\n      return 0;\n    }\n  }, {\n    key: \"getPositionShift\",\n    value: function getPositionShift(timeShift) {\n      var positionShift = _get(_getPrototypeOf(SchedulerTimeline.prototype), \"getPositionShift\", this).call(this, timeShift);\n\n      var left = this.getCellWidth() * timeShift;\n\n      if (this.option(\"rtlEnabled\")) {\n        left *= -1;\n      }\n\n      left += positionShift.left;\n      return {\n        top: 0,\n        left: left,\n        cellPosition: left\n      };\n    }\n  }, {\n    key: \"getVisibleBounds\",\n    value: function getVisibleBounds() {\n      var isRtl = this.option(\"rtlEnabled\");\n      var result = {};\n      var $scrollable = this.getScrollable().$element();\n      var cellWidth = this.getCellWidth();\n      var scrollableOffset = isRtl ? this.getScrollableOuterWidth() - this.getScrollableScrollLeft() : this.getScrollableScrollLeft();\n      var scrolledCellCount = scrollableOffset / cellWidth;\n      var visibleCellCount = $scrollable.width() / cellWidth;\n      var totalCellCount = isRtl ? scrolledCellCount - visibleCellCount : scrolledCellCount + visibleCellCount;\n\n      var leftDate = this._getDateByIndex(scrolledCellCount);\n\n      var rightDate = this._getDateByIndex(totalCellCount);\n\n      if (isRtl) {\n        leftDate = this._getDateByIndex(totalCellCount);\n        rightDate = this._getDateByIndex(scrolledCellCount);\n      }\n\n      result.left = {\n        hours: leftDate.getHours(),\n        minutes: leftDate.getMinutes() >= 30 ? 30 : 0,\n        date: dateUtils.trimTime(leftDate)\n      };\n      result.right = {\n        hours: rightDate.getHours(),\n        minutes: rightDate.getMinutes() >= 30 ? 30 : 0,\n        date: dateUtils.trimTime(rightDate)\n      };\n      return result;\n    }\n  }, {\n    key: \"getIntervalDuration\",\n    value: function getIntervalDuration(allDay) {\n      return this.getCellDuration();\n    }\n  }, {\n    key: \"_supportCompactDropDownAppointments\",\n    value: function _supportCompactDropDownAppointments() {\n      return false;\n    }\n  }, {\n    key: \"getCellMinWidth\",\n    value: function getCellMinWidth() {\n      return 0;\n    }\n  }, {\n    key: \"getWorkSpaceLeftOffset\",\n    value: function getWorkSpaceLeftOffset() {\n      return 0;\n    }\n  }, {\n    key: \"scrollToTime\",\n    value: function scrollToTime(hours, minutes, date) {\n      var coordinates = this._getScrollCoordinates(hours, minutes, date);\n\n      var scrollable = this.getScrollable();\n      var offset = this.option(\"rtlEnabled\") ? getBoundingRect(this.getScrollableContainer().get(0)).width : 0;\n\n      if (this.option(\"templatesRenderAsynchronously\")) {\n        setTimeout(function () {\n          scrollable.scrollBy({\n            left: coordinates.left - scrollable.scrollLeft() - offset,\n            top: 0\n          });\n        });\n      } else {\n        scrollable.scrollBy({\n          left: coordinates.left - scrollable.scrollLeft() - offset,\n          top: 0\n        });\n      }\n    }\n  }, {\n    key: \"_getRowCountWithAllDayRows\",\n    value: function _getRowCountWithAllDayRows() {\n      return this._getRowCount();\n    }\n  }, {\n    key: \"_setCurrentTimeCells\",\n    value: function _setCurrentTimeCells() {\n      var timePanelCells = this._getTimePanelCells();\n\n      var currentTimeCellIndices = this._getCurrentTimePanelCellIndices();\n\n      currentTimeCellIndices.forEach(function (timePanelCellIndex) {\n        timePanelCells.eq(timePanelCellIndex).addClass(HEADER_CURRENT_TIME_CELL_CLASS);\n      });\n    }\n  }, {\n    key: \"_cleanCurrentTimeCells\",\n    value: function _cleanCurrentTimeCells() {\n      this.$element().find(\".\".concat(HEADER_CURRENT_TIME_CELL_CLASS)).removeClass(HEADER_CURRENT_TIME_CELL_CLASS);\n    }\n  }, {\n    key: \"_getTimePanelCells\",\n    value: function _getTimePanelCells() {\n      return this.$element().find(\".\".concat(HEADER_PANEL_CELL_CLASS, \":not(.\").concat(HEADER_PANEL_WEEK_CELL_CLASS, \")\"));\n    }\n  }, {\n    key: \"_getCurrentTimePanelCellIndices\",\n    value: function _getCurrentTimePanelCellIndices() {\n      var columnCountPerGroup = this._getCellCount();\n\n      var today = this._getToday();\n\n      var index = this.getCellIndexByDate(today);\n\n      var _this$_getCellCoordin = this._getCellCoordinatesByIndex(index),\n          currentTimeCellIndex = _this$_getCellCoordin.cellIndex;\n\n      if (void 0 === currentTimeCellIndex) {\n        return [];\n      }\n\n      var horizontalGroupCount = this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate() ? this._getGroupCount() : 1;\n      return _toConsumableArray(new Array(horizontalGroupCount)).map(function (_, groupIndex) {\n        return columnCountPerGroup * groupIndex + currentTimeCellIndex;\n      });\n    }\n  }, {\n    key: \"renovatedRenderSupported\",\n    value: function renovatedRenderSupported() {\n      return true;\n    }\n  }, {\n    key: \"renderRAllDayPanel\",\n    value: function renderRAllDayPanel() {}\n  }, {\n    key: \"renderRTimeTable\",\n    value: function renderRTimeTable() {}\n  }, {\n    key: \"generateRenderOptions\",\n    value: function generateRenderOptions() {\n      var options = _get(_getPrototypeOf(SchedulerTimeline.prototype), \"generateRenderOptions\", this).call(this, true);\n\n      var groupCount = this._getGroupCount();\n\n      var horizontalGroupCount = this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate() ? groupCount : 1;\n      var cellsInGroup = this._getWeekDuration() * this.option(\"intervalCount\");\n      var daysInView = cellsInGroup * horizontalGroupCount;\n      return _extends({}, options, {\n        isGenerateWeekDaysHeaderData: this._needRenderWeekHeader(),\n        getWeekDaysHeaderText: this._formatWeekdayAndDay.bind(this),\n        daysInView: daysInView,\n        cellCountInDay: this._getCellCountInDay()\n      });\n    }\n  }]);\n\n  return SchedulerTimeline;\n}(SchedulerWorkSpace);\n\nregisterComponent(\"dxSchedulerTimeline\", SchedulerTimeline);\nexport default SchedulerTimeline;","map":null,"metadata":{},"sourceType":"module"}