{"ast":null,"code":"import _slicedToArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/recurrence.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport errors from \"../../core/errors\";\nimport { each } from \"../../core/utils/iterator\";\nimport { inArray } from \"../../core/utils/array\";\nimport { RRule, RRuleSet } from \"rrule\";\nimport dateUtils from \"../../core/utils/date\";\nimport timeZoneUtils from \"./utils.timeZone.js\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\nvar days = {\n  SU: 0,\n  MO: 1,\n  TU: 2,\n  WE: 3,\n  TH: 4,\n  FR: 5,\n  SA: 6\n};\nvar loggedWarnings = [];\nvar recurrence = null;\nexport function getRecurrenceProcessor() {\n  if (!recurrence) {\n    recurrence = new RecurrenceProcessor();\n  }\n\n  return recurrence;\n}\n\nvar RecurrenceProcessor = /*#__PURE__*/function () {\n  function RecurrenceProcessor() {\n    _classCallCheck(this, RecurrenceProcessor);\n\n    this.rRule = null;\n    this.rRuleSet = null;\n    this.validator = new RecurrenceValidator();\n  }\n\n  _createClass(RecurrenceProcessor, [{\n    key: \"generateDates\",\n    value: function generateDates(options) {\n      var result = [];\n      var recurrenceRule = this.evalRecurrenceRule(options.rule);\n      var rule = recurrenceRule.rule;\n\n      if (!recurrenceRule.isValid || !rule.freq) {\n        return result;\n      }\n\n      var startDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.start);\n      var endDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.end);\n      var minDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.min);\n      var maxDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.max);\n      var duration = endDateUtc ? endDateUtc.getTime() - startDateUtc.getTime() : 0;\n\n      this._initializeRRule(options, startDateUtc);\n\n      var minTime = minDateUtc.getTime();\n\n      var leftBorder = this._getLeftBorder(options, minDateUtc, duration);\n\n      this.rRuleSet.between(leftBorder, maxDateUtc, true).forEach(function (date) {\n        var endAppointmentTime = date.getTime() + duration;\n\n        if (endAppointmentTime >= minTime) {\n          var correctDate = timeZoneUtils.createDateFromUTCWithLocalOffset(date);\n          result.push(correctDate);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"hasRecurrence\",\n    value: function hasRecurrence(options) {\n      return !!this.generateDates(options).length;\n    }\n  }, {\n    key: \"evalRecurrenceRule\",\n    value: function evalRecurrenceRule(rule) {\n      var result = {\n        rule: {},\n        isValid: false\n      };\n\n      if (rule) {\n        result.rule = this._parseRecurrenceRule(rule);\n        result.isValid = this.validator.validateRRule(result.rule, rule);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"isValidRecurrenceRule\",\n    value: function isValidRecurrenceRule(rule) {\n      return this.evalRecurrenceRule(rule).isValid;\n    }\n  }, {\n    key: \"daysFromByDayRule\",\n    value: function daysFromByDayRule(rule) {\n      var result = [];\n\n      if (rule.byday) {\n        if (Array.isArray(rule.byday)) {\n          result = rule.byday;\n        } else {\n          result = rule.byday.split(\",\");\n        }\n      }\n\n      return result.map(function (item) {\n        var match = item.match(/[A-Za-z]+/);\n        return !!match && match[0];\n      }).filter(function (item) {\n        return !!item;\n      });\n    }\n  }, {\n    key: \"getAsciiStringByDate\",\n    value: function getAsciiStringByDate(date) {\n      var currentOffset = date.getTimezoneOffset() * toMs(\"minute\");\n      var offsetDate = new Date(date.getTime() + currentOffset);\n      return offsetDate.getFullYear() + (\"0\" + (offsetDate.getMonth() + 1)).slice(-2) + (\"0\" + offsetDate.getDate()).slice(-2) + \"T\" + (\"0\" + offsetDate.getHours()).slice(-2) + (\"0\" + offsetDate.getMinutes()).slice(-2) + (\"0\" + offsetDate.getSeconds()).slice(-2) + \"Z\";\n    }\n  }, {\n    key: \"getRecurrenceString\",\n    value: function getRecurrenceString(object) {\n      if (!object || !object.freq) {\n        return;\n      }\n\n      var result = \"\";\n\n      for (var field in object) {\n        var value = object[field];\n\n        if (\"interval\" === field && value < 2) {\n          continue;\n        }\n\n        if (\"until\" === field) {\n          value = this.getAsciiStringByDate(value);\n        }\n\n        result += field + \"=\" + value + \";\";\n      }\n\n      result = result.substring(0, result.length - 1);\n      return result.toUpperCase();\n    }\n  }, {\n    key: \"_parseExceptionToRawArray\",\n    value: function _parseExceptionToRawArray(value) {\n      return value.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/);\n    }\n  }, {\n    key: \"getDateByAsciiString\",\n    value: function getDateByAsciiString(exceptionText) {\n      if (\"string\" !== typeof exceptionText) {\n        return exceptionText;\n      }\n\n      var result = this._parseExceptionToRawArray(exceptionText);\n\n      if (!result) {\n        return null;\n      }\n\n      var _this$_createDateTupl = this._createDateTuple(result),\n          _this$_createDateTupl2 = _slicedToArray(_this$_createDateTupl, 7),\n          year = _this$_createDateTupl2[0],\n          month = _this$_createDateTupl2[1],\n          date = _this$_createDateTupl2[2],\n          hours = _this$_createDateTupl2[3],\n          minutes = _this$_createDateTupl2[4],\n          seconds = _this$_createDateTupl2[5],\n          isUtc = _this$_createDateTupl2[6];\n\n      if (isUtc) {\n        return new Date(Date.UTC(year, month, date, hours, minutes, seconds));\n      }\n\n      return new Date(year, month, date, hours, minutes, seconds);\n    }\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      if (this.rRuleSet) {\n        delete this.rRuleSet;\n        this.rRuleSet = null;\n      }\n\n      if (this.rRule) {\n        delete this.rRule;\n        this.rRule = null;\n      }\n    }\n  }, {\n    key: \"_getTimeZoneOffset\",\n    value: function _getTimeZoneOffset() {\n      return new Date().getTimezoneOffset();\n    }\n  }, {\n    key: \"_initializeRRule\",\n    value: function _initializeRRule(options, startDateUtc) {\n      var _this = this;\n\n      var ruleOptions = RRule.parseString(options.rule);\n      var firstDayOfWeek = options.firstDayOfWeek;\n      ruleOptions.dtstart = startDateUtc;\n\n      if (!ruleOptions.wkst && firstDayOfWeek) {\n        ruleOptions.wkst = [6, 0, 1, 2, 3, 4, 5][firstDayOfWeek];\n      }\n\n      this._createRRule(ruleOptions);\n\n      if (options.exception) {\n        var exceptionStrings = options.exception;\n        var exceptionDates = exceptionStrings.split(\",\").map(function (rule) {\n          return _this.getDateByAsciiString(rule);\n        });\n        exceptionDates.forEach(function (date) {\n          if (options.getPostProcessedException) {\n            date = options.getPostProcessedException(date);\n          }\n\n          var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n\n          _this.rRuleSet.exdate(utcDate);\n        });\n      }\n    }\n  }, {\n    key: \"_createRRule\",\n    value: function _createRRule(ruleOptions) {\n      this._dispose();\n\n      var rRuleSet = new RRuleSet();\n      this.rRuleSet = rRuleSet;\n      this.rRule = new RRule(ruleOptions);\n      this.rRuleSet.rrule(this.rRule);\n    }\n  }, {\n    key: \"_getLeftBorder\",\n    value: function _getLeftBorder(options, minDateUtc, appointmentDuration) {\n      if (options.end && !timeZoneUtils.isSameAppointmentDates(options.start, options.end)) {\n        return new Date(minDateUtc.getTime() - appointmentDuration);\n      }\n\n      return minDateUtc;\n    }\n  }, {\n    key: \"_parseRecurrenceRule\",\n    value: function _parseRecurrenceRule(recurrence) {\n      var ruleObject = {};\n      var ruleParts = recurrence.split(\";\");\n\n      for (var i = 0, len = ruleParts.length; i < len; i++) {\n        var rule = ruleParts[i].split(\"=\");\n        var ruleName = rule[0].toLowerCase();\n        var ruleValue = rule[1];\n        ruleObject[ruleName] = ruleValue;\n      }\n\n      var count = parseInt(ruleObject.count);\n\n      if (!isNaN(count)) {\n        ruleObject.count = count;\n      }\n\n      if (ruleObject.interval) {\n        var interval = parseInt(ruleObject.interval);\n\n        if (!isNaN(interval)) {\n          ruleObject.interval = interval;\n        }\n      } else {\n        ruleObject.interval = 1;\n      }\n\n      if (ruleObject.freq && ruleObject.until) {\n        ruleObject.until = this.getDateByAsciiString(ruleObject.until);\n      }\n\n      return ruleObject;\n    }\n  }, {\n    key: \"_createDateTuple\",\n    value: function _createDateTuple(parseResult) {\n      var isUtc = void 0 !== parseResult[8];\n      parseResult.shift();\n\n      if (void 0 === parseResult[3]) {\n        parseResult.splice(3);\n      } else {\n        parseResult.splice(3, 1);\n        parseResult.splice(6);\n      }\n\n      parseResult[1]--;\n      parseResult.unshift(null);\n      return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc];\n    }\n  }]);\n\n  return RecurrenceProcessor;\n}();\n\nvar RecurrenceValidator = /*#__PURE__*/function () {\n  function RecurrenceValidator() {\n    _classCallCheck(this, RecurrenceValidator);\n  }\n\n  _createClass(RecurrenceValidator, [{\n    key: \"validateRRule\",\n    value: function validateRRule(rule, recurrence) {\n      if (this._brokenRuleNameExists(rule) || -1 === inArray(rule.freq, freqNames) || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {\n        this._logBrokenRule(recurrence);\n\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_wrongUntilRule\",\n    value: function _wrongUntilRule(rule) {\n      var wrongUntil = false;\n      var until = rule.until;\n\n      if (void 0 !== until && !(until instanceof Date)) {\n        wrongUntil = true;\n      }\n\n      return wrongUntil;\n    }\n  }, {\n    key: \"_wrongCountRule\",\n    value: function _wrongCountRule(rule) {\n      var wrongCount = false;\n      var count = rule.count;\n\n      if (count && \"string\" === typeof count) {\n        wrongCount = true;\n      }\n\n      return wrongCount;\n    }\n  }, {\n    key: \"_wrongByMonthDayRule\",\n    value: function _wrongByMonthDayRule(rule) {\n      var wrongByMonthDay = false;\n      var byMonthDay = rule.bymonthday;\n\n      if (byMonthDay && isNaN(parseInt(byMonthDay))) {\n        wrongByMonthDay = true;\n      }\n\n      return wrongByMonthDay;\n    }\n  }, {\n    key: \"_wrongByMonth\",\n    value: function _wrongByMonth(rule) {\n      var wrongByMonth = false;\n      var byMonth = rule.bymonth;\n\n      if (byMonth && isNaN(parseInt(byMonth))) {\n        wrongByMonth = true;\n      }\n\n      return wrongByMonth;\n    }\n  }, {\n    key: \"_wrongIntervalRule\",\n    value: function _wrongIntervalRule(rule) {\n      var wrongInterval = false;\n      var interval = rule.interval;\n\n      if (interval && \"string\" === typeof interval) {\n        wrongInterval = true;\n      }\n\n      return wrongInterval;\n    }\n  }, {\n    key: \"_wrongDayOfWeek\",\n    value: function _wrongDayOfWeek(rule) {\n      var byDay = rule.byday;\n      var daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);\n      var brokenDaysExist = false;\n\n      if (\"\" === byDay) {\n        brokenDaysExist = true;\n      }\n\n      each(daysByRule, function (_, day) {\n        if (!Object.prototype.hasOwnProperty.call(days, day)) {\n          brokenDaysExist = true;\n          return false;\n        }\n      });\n      return brokenDaysExist;\n    }\n  }, {\n    key: \"_brokenRuleNameExists\",\n    value: function _brokenRuleNameExists(rule) {\n      var brokenRuleExists = false;\n      each(rule, function (ruleName) {\n        if (-1 === inArray(ruleName, ruleNames)) {\n          brokenRuleExists = true;\n          return false;\n        }\n      });\n      return brokenRuleExists;\n    }\n  }, {\n    key: \"_logBrokenRule\",\n    value: function _logBrokenRule(recurrence) {\n      if (-1 === inArray(recurrence, loggedWarnings)) {\n        errors.log(\"W0006\", recurrence);\n        loggedWarnings.push(recurrence);\n      }\n    }\n  }]);\n\n  return RecurrenceValidator;\n}();","map":{"version":3,"sources":["C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/devextreme/esm/ui/scheduler/recurrence.js"],"names":["errors","each","inArray","RRule","RRuleSet","dateUtils","timeZoneUtils","toMs","dateToMilliseconds","ruleNames","freqNames","days","SU","MO","TU","WE","TH","FR","SA","loggedWarnings","recurrence","getRecurrenceProcessor","RecurrenceProcessor","rRule","rRuleSet","validator","RecurrenceValidator","options","result","recurrenceRule","evalRecurrenceRule","rule","isValid","freq","startDateUtc","createUTCDateWithLocalOffset","start","endDateUtc","end","minDateUtc","min","maxDateUtc","max","duration","getTime","_initializeRRule","minTime","leftBorder","_getLeftBorder","between","forEach","date","endAppointmentTime","correctDate","createDateFromUTCWithLocalOffset","push","generateDates","length","_parseRecurrenceRule","validateRRule","byday","Array","isArray","split","map","item","match","filter","currentOffset","getTimezoneOffset","offsetDate","Date","getFullYear","getMonth","slice","getDate","getHours","getMinutes","getSeconds","object","field","value","getAsciiStringByDate","substring","toUpperCase","exceptionText","_parseExceptionToRawArray","_createDateTuple","year","month","hours","minutes","seconds","isUtc","UTC","ruleOptions","parseString","firstDayOfWeek","dtstart","wkst","_createRRule","exception","exceptionStrings","exceptionDates","getDateByAsciiString","getPostProcessedException","utcDate","exdate","_dispose","rrule","appointmentDuration","isSameAppointmentDates","ruleObject","ruleParts","i","len","ruleName","toLowerCase","ruleValue","count","parseInt","isNaN","interval","until","parseResult","shift","splice","unshift","_brokenRuleNameExists","_wrongCountRule","_wrongIntervalRule","_wrongDayOfWeek","_wrongByMonthDayRule","_wrongByMonth","_wrongUntilRule","_logBrokenRule","wrongUntil","wrongCount","wrongByMonthDay","byMonthDay","bymonthday","wrongByMonth","byMonth","bymonth","wrongInterval","byDay","daysByRule","daysFromByDayRule","brokenDaysExist","_","day","Object","prototype","hasOwnProperty","call","brokenRuleExists","log"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/recurrence.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport errors from \"../../core/errors\";\r\nimport {\r\n    each\r\n} from \"../../core/utils/iterator\";\r\nimport {\r\n    inArray\r\n} from \"../../core/utils/array\";\r\nimport {\r\n    RRule,\r\n    RRuleSet\r\n} from \"rrule\";\r\nimport dateUtils from \"../../core/utils/date\";\r\nimport timeZoneUtils from \"./utils.timeZone.js\";\r\nvar toMs = dateUtils.dateToMilliseconds;\r\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\r\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\r\nvar days = {\r\n    SU: 0,\r\n    MO: 1,\r\n    TU: 2,\r\n    WE: 3,\r\n    TH: 4,\r\n    FR: 5,\r\n    SA: 6\r\n};\r\nvar loggedWarnings = [];\r\nvar recurrence = null;\r\nexport function getRecurrenceProcessor() {\r\n    if (!recurrence) {\r\n        recurrence = new RecurrenceProcessor\r\n    }\r\n    return recurrence\r\n}\r\nclass RecurrenceProcessor {\r\n    constructor() {\r\n        this.rRule = null;\r\n        this.rRuleSet = null;\r\n        this.validator = new RecurrenceValidator\r\n    }\r\n    generateDates(options) {\r\n        var result = [];\r\n        var recurrenceRule = this.evalRecurrenceRule(options.rule);\r\n        var rule = recurrenceRule.rule;\r\n        if (!recurrenceRule.isValid || !rule.freq) {\r\n            return result\r\n        }\r\n        var startDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.start);\r\n        var endDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.end);\r\n        var minDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.min);\r\n        var maxDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.max);\r\n        var duration = endDateUtc ? endDateUtc.getTime() - startDateUtc.getTime() : 0;\r\n        this._initializeRRule(options, startDateUtc);\r\n        var minTime = minDateUtc.getTime();\r\n        var leftBorder = this._getLeftBorder(options, minDateUtc, duration);\r\n        this.rRuleSet.between(leftBorder, maxDateUtc, true).forEach(date => {\r\n            var endAppointmentTime = date.getTime() + duration;\r\n            if (endAppointmentTime >= minTime) {\r\n                var correctDate = timeZoneUtils.createDateFromUTCWithLocalOffset(date);\r\n                result.push(correctDate)\r\n            }\r\n        });\r\n        return result\r\n    }\r\n    hasRecurrence(options) {\r\n        return !!this.generateDates(options).length\r\n    }\r\n    evalRecurrenceRule(rule) {\r\n        var result = {\r\n            rule: {},\r\n            isValid: false\r\n        };\r\n        if (rule) {\r\n            result.rule = this._parseRecurrenceRule(rule);\r\n            result.isValid = this.validator.validateRRule(result.rule, rule)\r\n        }\r\n        return result\r\n    }\r\n    isValidRecurrenceRule(rule) {\r\n        return this.evalRecurrenceRule(rule).isValid\r\n    }\r\n    daysFromByDayRule(rule) {\r\n        var result = [];\r\n        if (rule.byday) {\r\n            if (Array.isArray(rule.byday)) {\r\n                result = rule.byday\r\n            } else {\r\n                result = rule.byday.split(\",\")\r\n            }\r\n        }\r\n        return result.map(item => {\r\n            var match = item.match(/[A-Za-z]+/);\r\n            return !!match && match[0]\r\n        }).filter(item => !!item)\r\n    }\r\n    getAsciiStringByDate(date) {\r\n        var currentOffset = date.getTimezoneOffset() * toMs(\"minute\");\r\n        var offsetDate = new Date(date.getTime() + currentOffset);\r\n        return offsetDate.getFullYear() + (\"0\" + (offsetDate.getMonth() + 1)).slice(-2) + (\"0\" + offsetDate.getDate()).slice(-2) + \"T\" + (\"0\" + offsetDate.getHours()).slice(-2) + (\"0\" + offsetDate.getMinutes()).slice(-2) + (\"0\" + offsetDate.getSeconds()).slice(-2) + \"Z\"\r\n    }\r\n    getRecurrenceString(object) {\r\n        if (!object || !object.freq) {\r\n            return\r\n        }\r\n        var result = \"\";\r\n        for (var field in object) {\r\n            var value = object[field];\r\n            if (\"interval\" === field && value < 2) {\r\n                continue\r\n            }\r\n            if (\"until\" === field) {\r\n                value = this.getAsciiStringByDate(value)\r\n            }\r\n            result += field + \"=\" + value + \";\"\r\n        }\r\n        result = result.substring(0, result.length - 1);\r\n        return result.toUpperCase()\r\n    }\r\n    _parseExceptionToRawArray(value) {\r\n        return value.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/)\r\n    }\r\n    getDateByAsciiString(exceptionText) {\r\n        if (\"string\" !== typeof exceptionText) {\r\n            return exceptionText\r\n        }\r\n        var result = this._parseExceptionToRawArray(exceptionText);\r\n        if (!result) {\r\n            return null\r\n        }\r\n        var [year, month, date, hours, minutes, seconds, isUtc] = this._createDateTuple(result);\r\n        if (isUtc) {\r\n            return new Date(Date.UTC(year, month, date, hours, minutes, seconds))\r\n        }\r\n        return new Date(year, month, date, hours, minutes, seconds)\r\n    }\r\n    _dispose() {\r\n        if (this.rRuleSet) {\r\n            delete this.rRuleSet;\r\n            this.rRuleSet = null\r\n        }\r\n        if (this.rRule) {\r\n            delete this.rRule;\r\n            this.rRule = null\r\n        }\r\n    }\r\n    _getTimeZoneOffset() {\r\n        return (new Date).getTimezoneOffset()\r\n    }\r\n    _initializeRRule(options, startDateUtc) {\r\n        var ruleOptions = RRule.parseString(options.rule);\r\n        var firstDayOfWeek = options.firstDayOfWeek;\r\n        ruleOptions.dtstart = startDateUtc;\r\n        if (!ruleOptions.wkst && firstDayOfWeek) {\r\n            ruleOptions.wkst = [6, 0, 1, 2, 3, 4, 5][firstDayOfWeek]\r\n        }\r\n        this._createRRule(ruleOptions);\r\n        if (options.exception) {\r\n            var exceptionStrings = options.exception;\r\n            var exceptionDates = exceptionStrings.split(\",\").map(rule => this.getDateByAsciiString(rule));\r\n            exceptionDates.forEach(date => {\r\n                if (options.getPostProcessedException) {\r\n                    date = options.getPostProcessedException(date)\r\n                }\r\n                var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\r\n                this.rRuleSet.exdate(utcDate)\r\n            })\r\n        }\r\n    }\r\n    _createRRule(ruleOptions) {\r\n        this._dispose();\r\n        var rRuleSet = new RRuleSet;\r\n        this.rRuleSet = rRuleSet;\r\n        this.rRule = new RRule(ruleOptions);\r\n        this.rRuleSet.rrule(this.rRule)\r\n    }\r\n    _getLeftBorder(options, minDateUtc, appointmentDuration) {\r\n        if (options.end && !timeZoneUtils.isSameAppointmentDates(options.start, options.end)) {\r\n            return new Date(minDateUtc.getTime() - appointmentDuration)\r\n        }\r\n        return minDateUtc\r\n    }\r\n    _parseRecurrenceRule(recurrence) {\r\n        var ruleObject = {};\r\n        var ruleParts = recurrence.split(\";\");\r\n        for (var i = 0, len = ruleParts.length; i < len; i++) {\r\n            var rule = ruleParts[i].split(\"=\");\r\n            var ruleName = rule[0].toLowerCase();\r\n            var ruleValue = rule[1];\r\n            ruleObject[ruleName] = ruleValue\r\n        }\r\n        var count = parseInt(ruleObject.count);\r\n        if (!isNaN(count)) {\r\n            ruleObject.count = count\r\n        }\r\n        if (ruleObject.interval) {\r\n            var interval = parseInt(ruleObject.interval);\r\n            if (!isNaN(interval)) {\r\n                ruleObject.interval = interval\r\n            }\r\n        } else {\r\n            ruleObject.interval = 1\r\n        }\r\n        if (ruleObject.freq && ruleObject.until) {\r\n            ruleObject.until = this.getDateByAsciiString(ruleObject.until)\r\n        }\r\n        return ruleObject\r\n    }\r\n    _createDateTuple(parseResult) {\r\n        var isUtc = void 0 !== parseResult[8];\r\n        parseResult.shift();\r\n        if (void 0 === parseResult[3]) {\r\n            parseResult.splice(3)\r\n        } else {\r\n            parseResult.splice(3, 1);\r\n            parseResult.splice(6)\r\n        }\r\n        parseResult[1]--;\r\n        parseResult.unshift(null);\r\n        return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc]\r\n    }\r\n}\r\nclass RecurrenceValidator {\r\n    validateRRule(rule, recurrence) {\r\n        if (this._brokenRuleNameExists(rule) || -1 === inArray(rule.freq, freqNames) || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {\r\n            this._logBrokenRule(recurrence);\r\n            return false\r\n        }\r\n        return true\r\n    }\r\n    _wrongUntilRule(rule) {\r\n        var wrongUntil = false;\r\n        var until = rule.until;\r\n        if (void 0 !== until && !(until instanceof Date)) {\r\n            wrongUntil = true\r\n        }\r\n        return wrongUntil\r\n    }\r\n    _wrongCountRule(rule) {\r\n        var wrongCount = false;\r\n        var count = rule.count;\r\n        if (count && \"string\" === typeof count) {\r\n            wrongCount = true\r\n        }\r\n        return wrongCount\r\n    }\r\n    _wrongByMonthDayRule(rule) {\r\n        var wrongByMonthDay = false;\r\n        var byMonthDay = rule.bymonthday;\r\n        if (byMonthDay && isNaN(parseInt(byMonthDay))) {\r\n            wrongByMonthDay = true\r\n        }\r\n        return wrongByMonthDay\r\n    }\r\n    _wrongByMonth(rule) {\r\n        var wrongByMonth = false;\r\n        var byMonth = rule.bymonth;\r\n        if (byMonth && isNaN(parseInt(byMonth))) {\r\n            wrongByMonth = true\r\n        }\r\n        return wrongByMonth\r\n    }\r\n    _wrongIntervalRule(rule) {\r\n        var wrongInterval = false;\r\n        var interval = rule.interval;\r\n        if (interval && \"string\" === typeof interval) {\r\n            wrongInterval = true\r\n        }\r\n        return wrongInterval\r\n    }\r\n    _wrongDayOfWeek(rule) {\r\n        var byDay = rule.byday;\r\n        var daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);\r\n        var brokenDaysExist = false;\r\n        if (\"\" === byDay) {\r\n            brokenDaysExist = true\r\n        }\r\n        each(daysByRule, (function(_, day) {\r\n            if (!Object.prototype.hasOwnProperty.call(days, day)) {\r\n                brokenDaysExist = true;\r\n                return false\r\n            }\r\n        }));\r\n        return brokenDaysExist\r\n    }\r\n    _brokenRuleNameExists(rule) {\r\n        var brokenRuleExists = false;\r\n        each(rule, (function(ruleName) {\r\n            if (-1 === inArray(ruleName, ruleNames)) {\r\n                brokenRuleExists = true;\r\n                return false\r\n            }\r\n        }));\r\n        return brokenRuleExists\r\n    }\r\n    _logBrokenRule(recurrence) {\r\n        if (-1 === inArray(recurrence, loggedWarnings)) {\r\n            errors.log(\"W0006\", recurrence);\r\n            loggedWarnings.push(recurrence)\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}