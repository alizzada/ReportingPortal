{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scroll_view/ui.scrollable.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { nativeScrolling } from \"../../core/utils/support\";\nimport browser from \"../../core/utils/browser\";\nimport { deferUpdate, deferRender, ensureDefined } from \"../../core/utils/common\";\nimport { isPlainObject, isDefined } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { getPublicElement } from \"../../core/element\";\nimport { getWindow, hasWindow } from \"../../core/utils/window\";\nimport domAdapter from \"../../core/dom_adapter\";\nimport devices from \"../../core/devices\";\nimport registerComponent from \"../../core/component_registrator\";\nimport DOMComponent from \"../../core/dom_component\";\nimport { focusable } from \"../widget/selectors\";\nimport { addNamespace } from \"../../events/utils/index\";\nimport scrollEvents from \"./ui.events.emitter.gesture.scroll\";\nimport { SimulatedStrategy } from \"./ui.scrollable.simulated\";\nimport NativeStrategy from \"./ui.scrollable.native\";\nimport { deviceDependentOptions } from \"./ui.scrollable.device\";\nimport { when } from \"../../core/utils/deferred\";\nvar SCROLLABLE = \"dxScrollable\";\nvar SCROLLABLE_STRATEGY = \"dxScrollableStrategy\";\nvar SCROLLABLE_CLASS = \"dx-scrollable\";\nvar SCROLLABLE_DISABLED_CLASS = \"dx-scrollable-disabled\";\nvar SCROLLABLE_CONTAINER_CLASS = \"dx-scrollable-container\";\nvar SCROLLABLE_WRAPPER_CLASS = \"dx-scrollable-wrapper\";\nvar SCROLLABLE_CONTENT_CLASS = \"dx-scrollable-content\";\nvar VERTICAL = \"vertical\";\nvar HORIZONTAL = \"horizontal\";\nvar BOTH = \"both\";\nvar Scrollable = DOMComponent.inherit({\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      disabled: false,\n      onScroll: null,\n      direction: VERTICAL,\n      showScrollbar: \"onScroll\",\n      useNative: true,\n      bounceEnabled: true,\n      scrollByContent: true,\n      scrollByThumb: false,\n      onUpdated: null,\n      onStart: null,\n      onEnd: null,\n      onBounce: null,\n      useSimulatedScrollbar: false,\n      useKeyboard: true,\n      inertiaEnabled: true,\n      updateManually: false\n    });\n  },\n  _defaultOptionsRules: function _defaultOptionsRules() {\n    return this.callBase().concat(deviceDependentOptions(), [{\n      device: function device() {\n        return nativeScrolling && \"android\" === devices.real().platform && !browser.mozilla;\n      },\n      options: {\n        useSimulatedScrollbar: true\n      }\n    }]);\n  },\n  _initOptions: function _initOptions(options) {\n    this.callBase(options);\n\n    if (!(\"useSimulatedScrollbar\" in options)) {\n      this._setUseSimulatedScrollbar();\n    }\n  },\n  _setUseSimulatedScrollbar: function _setUseSimulatedScrollbar() {\n    if (!this.initialOption(\"useSimulatedScrollbar\")) {\n      this.option(\"useSimulatedScrollbar\", !this.option(\"useNative\"));\n    }\n  },\n  _init: function _init() {\n    this.callBase();\n\n    this._initScrollableMarkup();\n\n    this._locked = false;\n  },\n  _getWindowDevicePixelRatio: function _getWindowDevicePixelRatio() {\n    return hasWindow() ? getWindow().devicePixelRatio : 1;\n  },\n  _visibilityChanged: function _visibilityChanged(visible) {\n    if (visible) {\n      this.update();\n\n      this._updateRtlPosition();\n\n      this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);\n      delete this._savedScrollOffset;\n    } else {\n      this._savedScrollOffset = this.scrollOffset();\n    }\n  },\n  _initScrollableMarkup: function _initScrollableMarkup() {\n    var $element = this.$element().addClass(SCROLLABLE_CLASS);\n    var $container = this._$container = $(\"<div>\").addClass(SCROLLABLE_CONTAINER_CLASS);\n    var $wrapper = this._$wrapper = $(\"<div>\").addClass(SCROLLABLE_WRAPPER_CLASS);\n    var $content = this._$content = $(\"<div>\").addClass(SCROLLABLE_CONTENT_CLASS);\n\n    if (domAdapter.hasDocumentProperty(\"onbeforeactivate\") && browser.msie && browser.version < 12) {\n      eventsEngine.on($element, addNamespace(\"beforeactivate\", SCROLLABLE), function (e) {\n        if (!$(e.target).is(focusable)) {\n          e.preventDefault();\n        }\n      });\n    }\n\n    $content.append($element.contents()).appendTo($container);\n    $container.appendTo($wrapper);\n    $wrapper.appendTo($element);\n  },\n  _dimensionChanged: function _dimensionChanged() {\n    this.update();\n\n    this._updateRtlPosition();\n  },\n  _initMarkup: function _initMarkup() {\n    this.callBase();\n\n    this._renderDirection();\n  },\n  _render: function _render() {\n    this._renderStrategy();\n\n    this._attachEventHandlers();\n\n    this._renderDisabledState();\n\n    this._createActions();\n\n    this.update();\n    this.callBase();\n    this._rtlConfig = {\n      scrollRight: 0,\n      clientWidth: this._container().get(0).clientWidth,\n      windowPixelRatio: this._getWindowDevicePixelRatio()\n    };\n\n    this._updateRtlPosition();\n  },\n  _isHorizontalAndRtlEnabled: function _isHorizontalAndRtlEnabled() {\n    return this.option(\"rtlEnabled\") && this.option(\"direction\") !== VERTICAL;\n  },\n  _updateRtlPosition: function _updateRtlPosition() {\n    var _this = this;\n\n    this._updateBounds();\n\n    if (this._isHorizontalAndRtlEnabled()) {\n      deferUpdate(function () {\n        var scrollLeft = _this._getMaxOffset().left - _this._rtlConfig.scrollRight;\n\n        if (scrollLeft <= 0) {\n          scrollLeft = 0;\n          _this._rtlConfig.scrollRight = _this._getMaxOffset().left;\n        }\n\n        deferRender(function () {\n          if (_this.scrollLeft() !== scrollLeft) {\n            _this._rtlConfig.skipUpdating = true;\n\n            _this.scrollTo({\n              left: scrollLeft\n            });\n\n            _this._rtlConfig.skipUpdating = false;\n          }\n        });\n      });\n    }\n  },\n  _getMaxOffset: function _getMaxOffset() {\n    var _this$_container$get = this._container().get(0),\n        scrollWidth = _this$_container$get.scrollWidth,\n        clientWidth = _this$_container$get.clientWidth,\n        scrollHeight = _this$_container$get.scrollHeight,\n        clientHeight = _this$_container$get.clientHeight;\n\n    return {\n      left: scrollWidth - clientWidth,\n      top: scrollHeight - clientHeight\n    };\n  },\n  _updateBounds: function _updateBounds() {\n    this._strategy.updateBounds();\n  },\n  _attachEventHandlers: function _attachEventHandlers() {\n    var strategy = this._strategy;\n    var initEventData = {\n      getDirection: strategy.getDirection.bind(strategy),\n      validate: this._validate.bind(this),\n      isNative: this.option(\"useNative\"),\n      scrollTarget: this._$container\n    };\n    eventsEngine.off(this._$wrapper, \".\" + SCROLLABLE);\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.init, SCROLLABLE), initEventData, this._initHandler.bind(this));\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.start, SCROLLABLE), strategy.handleStart.bind(strategy));\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.move, SCROLLABLE), strategy.handleMove.bind(strategy));\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.end, SCROLLABLE), strategy.handleEnd.bind(strategy));\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.cancel, SCROLLABLE), strategy.handleCancel.bind(strategy));\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.stop, SCROLLABLE), strategy.handleStop.bind(strategy));\n    eventsEngine.off(this._$container, \".\" + SCROLLABLE);\n    eventsEngine.on(this._$container, addNamespace(\"scroll\", SCROLLABLE), strategy.handleScroll.bind(strategy));\n  },\n  _updateRtlConfig: function _updateRtlConfig() {\n    if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {\n      var _this$_container$get2 = this._container().get(0),\n          clientWidth = _this$_container$get2.clientWidth,\n          scrollLeft = _this$_container$get2.scrollLeft;\n\n      var windowPixelRatio = this._getWindowDevicePixelRatio();\n\n      if (this._rtlConfig.windowPixelRatio === windowPixelRatio && this._rtlConfig.clientWidth === clientWidth) {\n        this._rtlConfig.scrollRight = this._getMaxOffset().left - scrollLeft;\n      }\n\n      this._rtlConfig.clientWidth = clientWidth;\n      this._rtlConfig.windowPixelRatio = windowPixelRatio;\n    }\n  },\n  _validate: function _validate(e) {\n    if (this._isLocked()) {\n      return false;\n    }\n\n    this._updateIfNeed();\n\n    return this._strategy.validate(e);\n  },\n  _initHandler: function _initHandler() {\n    var strategy = this._strategy;\n    strategy.handleInit.apply(strategy, arguments);\n  },\n  _renderDisabledState: function _renderDisabledState() {\n    this.$element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option(\"disabled\"));\n\n    if (this.option(\"disabled\")) {\n      this._lock();\n    } else {\n      this._unlock();\n    }\n  },\n  _renderDirection: function _renderDirection() {\n    this.$element().removeClass(\"dx-scrollable-\" + HORIZONTAL).removeClass(\"dx-scrollable-\" + VERTICAL).removeClass(\"dx-scrollable-\" + BOTH).addClass(\"dx-scrollable-\" + this.option(\"direction\"));\n  },\n  _renderStrategy: function _renderStrategy() {\n    this._createStrategy();\n\n    this._strategy.render();\n\n    this.$element().data(SCROLLABLE_STRATEGY, this._strategy);\n  },\n  _createStrategy: function _createStrategy() {\n    this._strategy = this.option(\"useNative\") ? new NativeStrategy(this) : new SimulatedStrategy(this);\n  },\n  _createActions: function _createActions() {\n    this._strategy && this._strategy.createActions();\n  },\n  _clean: function _clean() {\n    this._strategy && this._strategy.dispose();\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"onStart\":\n      case \"onEnd\":\n      case \"onUpdated\":\n      case \"onScroll\":\n      case \"onBounce\":\n        this._createActions();\n\n        break;\n\n      case \"direction\":\n        this._resetInactiveDirection();\n\n        this._invalidate();\n\n        break;\n\n      case \"useNative\":\n        this._setUseSimulatedScrollbar();\n\n        this._invalidate();\n\n        break;\n\n      case \"inertiaEnabled\":\n      case \"scrollByContent\":\n      case \"scrollByThumb\":\n      case \"bounceEnabled\":\n      case \"useKeyboard\":\n      case \"showScrollbar\":\n      case \"useSimulatedScrollbar\":\n        this._invalidate();\n\n        break;\n\n      case \"disabled\":\n        this._renderDisabledState();\n\n        this._strategy && this._strategy.disabledChanged();\n        break;\n\n      case \"updateManually\":\n        break;\n\n      case \"width\":\n        this.callBase(args);\n\n        this._updateRtlPosition();\n\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _resetInactiveDirection: function _resetInactiveDirection() {\n    var inactiveProp = this._getInactiveProp();\n\n    if (!inactiveProp || !hasWindow()) {\n      return;\n    }\n\n    var scrollOffset = this.scrollOffset();\n    scrollOffset[inactiveProp] = 0;\n    this.scrollTo(scrollOffset);\n  },\n  _getInactiveProp: function _getInactiveProp() {\n    var direction = this.option(\"direction\");\n\n    if (direction === VERTICAL) {\n      return \"left\";\n    }\n\n    if (direction === HORIZONTAL) {\n      return \"top\";\n    }\n  },\n  _location: function _location() {\n    return this._strategy.location();\n  },\n  _normalizeLocation: function _normalizeLocation(location) {\n    if (isPlainObject(location)) {\n      var left = ensureDefined(location.left, location.x);\n      var top = ensureDefined(location.top, location.y);\n      return {\n        left: isDefined(left) ? -left : void 0,\n        top: isDefined(top) ? -top : void 0\n      };\n    } else {\n      var direction = this.option(\"direction\");\n      return {\n        left: direction !== VERTICAL ? -location : void 0,\n        top: direction !== HORIZONTAL ? -location : void 0\n      };\n    }\n  },\n  _isLocked: function _isLocked() {\n    return this._locked;\n  },\n  _lock: function _lock() {\n    this._locked = true;\n  },\n  _unlock: function _unlock() {\n    if (!this.option(\"disabled\")) {\n      this._locked = false;\n    }\n  },\n  _isDirection: function _isDirection(direction) {\n    var current = this.option(\"direction\");\n\n    if (direction === VERTICAL) {\n      return current !== HORIZONTAL;\n    }\n\n    if (direction === HORIZONTAL) {\n      return current !== VERTICAL;\n    }\n\n    return current === direction;\n  },\n  _updateAllowedDirection: function _updateAllowedDirection() {\n    var allowedDirections = this._strategy._allowedDirections();\n\n    if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {\n      this._allowedDirectionValue = BOTH;\n    } else if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal) {\n      this._allowedDirectionValue = HORIZONTAL;\n    } else if (this._isDirection(VERTICAL) && allowedDirections.vertical) {\n      this._allowedDirectionValue = VERTICAL;\n    } else {\n      this._allowedDirectionValue = null;\n    }\n  },\n  _allowedDirection: function _allowedDirection() {\n    return this._allowedDirectionValue;\n  },\n  _container: function _container() {\n    return this._$container;\n  },\n  $content: function $content() {\n    return this._$content;\n  },\n  content: function content() {\n    return getPublicElement(this._$content);\n  },\n  scrollOffset: function scrollOffset() {\n    return this._getScrollOffset();\n  },\n  _getScrollOffset: function _getScrollOffset() {\n    return {\n      top: -this._location().top,\n      left: -this._location().left\n    };\n  },\n  scrollTop: function scrollTop() {\n    return this.scrollOffset().top;\n  },\n  scrollLeft: function scrollLeft() {\n    return this.scrollOffset().left;\n  },\n  clientHeight: function clientHeight() {\n    return this._$container.height();\n  },\n  scrollHeight: function scrollHeight() {\n    return this.$content().outerHeight();\n  },\n  clientWidth: function clientWidth() {\n    return this._$container.width();\n  },\n  scrollWidth: function scrollWidth() {\n    return this.$content().outerWidth();\n  },\n  update: function update() {\n    if (!this._strategy) {\n      return;\n    }\n\n    return when(this._strategy.update()).done(function () {\n      this._updateAllowedDirection();\n    }.bind(this));\n  },\n  scrollBy: function scrollBy(distance) {\n    distance = this._normalizeLocation(distance);\n\n    if (!distance.top && !distance.left) {\n      return;\n    }\n\n    this._updateIfNeed();\n\n    this._strategy.scrollBy(distance);\n\n    this._updateRtlConfig();\n  },\n  scrollTo: function scrollTo(targetLocation) {\n    targetLocation = this._normalizeLocation(targetLocation);\n\n    this._updateIfNeed();\n\n    var location = this._location();\n\n    if (!this.option(\"useNative\")) {\n      targetLocation = this._strategy._applyScaleRatio(targetLocation);\n      location = this._strategy._applyScaleRatio(location);\n    }\n\n    var distance = this._normalizeLocation({\n      left: location.left - ensureDefined(targetLocation.left, location.left),\n      top: location.top - ensureDefined(targetLocation.top, location.top)\n    });\n\n    if (!distance.top && !distance.left) {\n      return;\n    }\n\n    this._strategy.scrollBy(distance);\n\n    this._updateRtlConfig();\n  },\n  scrollToElement: function scrollToElement(element, offset) {\n    var $element = $(element);\n    var elementInsideContent = this.$content().find(element).length;\n    var elementIsInsideContent = $element.parents(\".\" + SCROLLABLE_CLASS).length - $element.parents(\".\" + SCROLLABLE_CONTENT_CLASS).length === 0;\n\n    if (!elementInsideContent || !elementIsInsideContent) {\n      return;\n    }\n\n    var scrollPosition = {\n      top: 0,\n      left: 0\n    };\n    var direction = this.option(\"direction\");\n\n    if (direction !== VERTICAL) {\n      scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL, offset);\n    }\n\n    if (direction !== HORIZONTAL) {\n      scrollPosition.top = this.getScrollElementPosition($element, VERTICAL, offset);\n    }\n\n    this.scrollTo(scrollPosition);\n  },\n  scrollToElementTopLeft: function scrollToElementTopLeft(element) {\n    var $element = $(element);\n    var elementInsideContent = this.$content().find(element).length;\n    var elementIsInsideContent = $element.parents(\".\" + SCROLLABLE_CLASS).length - $element.parents(\".\" + SCROLLABLE_CONTENT_CLASS).length === 0;\n\n    if (!elementInsideContent || !elementIsInsideContent) {\n      return;\n    }\n\n    var scrollPosition = {\n      top: 0,\n      left: 0\n    };\n    var direction = this.option(\"direction\");\n\n    if (direction !== VERTICAL) {\n      var leftPosition = this._elementPositionRelativeToContent($element, \"left\");\n\n      scrollPosition.left = true === this.option(\"rtlEnabled\") ? leftPosition + $element.width() - this.clientWidth() : leftPosition;\n    }\n\n    if (direction !== HORIZONTAL) {\n      scrollPosition.top = this._elementPositionRelativeToContent($element, \"top\");\n    }\n\n    this.scrollTo(scrollPosition);\n  },\n  getScrollElementPosition: function getScrollElementPosition($element, direction, offset) {\n    offset = offset || {};\n    var isVertical = direction === VERTICAL;\n    var startOffset = (isVertical ? offset.top : offset.left) || 0;\n    var endOffset = (isVertical ? offset.bottom : offset.right) || 0;\n\n    var elementPositionRelativeToContent = this._elementPositionRelativeToContent($element, isVertical ? \"top\" : \"left\");\n\n    var elementPosition = elementPositionRelativeToContent;\n    var elementSize = $element[isVertical ? \"outerHeight\" : \"outerWidth\"]();\n    var scrollLocation = isVertical ? this.scrollTop() : this.scrollLeft();\n\n    var clientSize = this._container().get(0)[isVertical ? \"clientHeight\" : \"clientWidth\"];\n\n    var startDistance = scrollLocation - elementPosition + startOffset;\n    var endDistance = scrollLocation - elementPosition - elementSize + clientSize - endOffset;\n\n    if (startDistance <= 0 && endDistance >= 0) {\n      return scrollLocation;\n    }\n\n    return scrollLocation - (Math.abs(startDistance) > Math.abs(endDistance) ? endDistance : startDistance);\n  },\n  _elementPositionRelativeToContent: function _elementPositionRelativeToContent($element, prop) {\n    var result = 0;\n\n    while (this._hasScrollContent($element)) {\n      result += $element.position()[prop];\n      $element = $element.offsetParent();\n    }\n\n    return result;\n  },\n  _hasScrollContent: function _hasScrollContent($element) {\n    var $content = this.$content();\n    return $element.closest($content).length && !$element.is($content);\n  },\n  _updateIfNeed: function _updateIfNeed() {\n    if (!this.option(\"updateManually\")) {\n      this.update();\n    }\n  },\n  _useTemplates: function _useTemplates() {\n    return false;\n  }\n});\nregisterComponent(SCROLLABLE, Scrollable);\nexport default Scrollable;","map":null,"metadata":{},"sourceType":"module"}