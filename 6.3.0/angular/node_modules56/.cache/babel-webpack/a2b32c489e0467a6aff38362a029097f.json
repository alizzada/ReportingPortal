{"ast":null,"code":"import _defineProperty from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _get from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.work_space.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport $ from \"../../../core/renderer\";\nimport domAdapter from \"../../../core/dom_adapter\";\nimport eventsEngine from \"../../../events/core/events_engine\";\nimport { data as elementData } from \"../../../core/element_data\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { getWindow, hasWindow } from \"../../../core/utils/window\";\nimport { getPublicElement } from \"../../../core/element\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { each } from \"../../../core/utils/iterator\";\nimport { getBoundingRect, getElementsFromPoint } from \"../../../core/utils/position\";\nimport messageLocalization from \"../../../localization/message\";\nimport dateLocalization from \"../../../localization/date\";\nimport { noop } from \"../../../core/utils/common\";\nimport { isDefined } from \"../../../core/utils/type\";\nimport { addNamespace, isMouseEvent } from \"../../../events/utils/index\";\nimport pointerEvents from \"../../../events/pointer\";\nimport errors from \"../../widget/ui.errors\";\nimport { name as clickEventName } from \"../../../events/click\";\nimport { name as contextMenuEventName } from \"../../../events/contextmenu\";\nimport { enter as dragEventEnter, leave as dragEventLeave, drop as dragEventDrop } from \"../../../events/drag\";\nimport Scrollable from \"../../scroll_view/ui.scrollable\";\nimport HorizontalGroupedStrategy from \"./ui.scheduler.work_space.grouped.strategy.horizontal\";\nimport VerticalGroupedStrategy from \"./ui.scheduler.work_space.grouped.strategy.vertical\";\nimport tableCreatorModule from \"../table_creator\";\nvar tableCreator = tableCreatorModule.tableCreator;\nimport VerticalShader from \"../shaders/ui.scheduler.current_time_shader.vertical\";\nimport AppointmentDragBehavior from \"../appointmentDragBehavior\";\nimport { APPOINTMENT_SETTINGS_KEY, FIXED_CONTAINER_CLASS, VIRTUAL_CELL_CLASS } from \"../constants\";\nimport timeZoneUtils from \"../utils.timeZone\";\nimport WidgetObserver from \"../base/widgetObserver\";\nimport { resetPosition, locate } from \"../../../animation/translator\";\nimport VirtualScrollingDispatcher from \"./ui.scheduler.virtual_scrolling\";\nimport ViewDataProvider from \"./view_data_provider\";\nimport dxrDateTableLayout from \"../../../renovation/ui/scheduler/workspaces/base/date_table/layout.j\";\nimport dxrAllDayPanelLayout from \"../../../renovation/ui/scheduler/workspaces/base/date_table/all_day_panel/layout.j\";\nimport dxrAllDayPanelTitle from \"../../../renovation/ui/scheduler/workspaces/base/date_table/all_day_panel/title.j\";\nimport dxrTimePanelTableLayout from \"../../../renovation/ui/scheduler/workspaces/base/time_panel/layout.j\";\nimport dxrGroupPanel from \"../../../renovation/ui/scheduler/workspaces/base/group_panel/group_panel.j\";\nimport dxrDateHeader from \"../../../renovation/ui/scheduler/workspaces/base/header_panel/layout.j\";\nimport VirtualSelectionState from \"./virtual_selection_state\";\nimport { cache } from \"./cache\";\nvar abstract = WidgetObserver.abstract;\nvar toMs = dateUtils.dateToMilliseconds;\nvar COMPONENT_CLASS = \"dx-scheduler-work-space\";\nvar GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-grouped\";\nvar VERTICAL_GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-vertical-grouped\";\nvar WORKSPACE_VERTICAL_GROUP_TABLE_CLASS = \"dx-scheduler-work-space-vertical-group-table\";\nvar WORKSPACE_WITH_BOTH_SCROLLS_CLASS = \"dx-scheduler-work-space-both-scrollbar\";\nvar WORKSPACE_WITH_COUNT_CLASS = \"dx-scheduler-work-space-count\";\nvar WORKSPACE_WITH_GROUP_BY_DATE_CLASS = \"dx-scheduler-work-space-group-by-date\";\nvar WORKSPACE_WITH_ODD_CELLS_CLASS = \"dx-scheduler-work-space-odd-cells\";\nvar TIME_PANEL_CLASS = \"dx-scheduler-time-panel\";\nvar TIME_PANEL_CELL_CLASS = \"dx-scheduler-time-panel-cell\";\nvar TIME_PANEL_ROW_CLASS = \"dx-scheduler-time-panel-row\";\nvar ALL_DAY_PANEL_CLASS = \"dx-scheduler-all-day-panel\";\nvar ALL_DAY_TABLE_CLASS = \"dx-scheduler-all-day-table\";\nvar ALL_DAY_CONTAINER_CLASS = \"dx-scheduler-all-day-appointments\";\nvar ALL_DAY_TITLE_CLASS = \"dx-scheduler-all-day-title\";\nvar ALL_DAY_TITLE_HIDDEN_CLASS = \"dx-scheduler-all-day-title-hidden\";\nvar ALL_DAY_TABLE_CELL_CLASS = \"dx-scheduler-all-day-table-cell\";\nvar ALL_DAY_TABLE_ROW_CLASS = \"dx-scheduler-all-day-table-row\";\nvar WORKSPACE_WITH_ALL_DAY_CLASS = \"dx-scheduler-work-space-all-day\";\nvar WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS = \"dx-scheduler-work-space-all-day-collapsed\";\nvar WORKSPACE_WITH_MOUSE_SELECTION_CLASS = \"dx-scheduler-work-space-mouse-selection\";\nvar HORIZONTAL_SIZES_CLASS = \"dx-scheduler-cell-sizes-horizontal\";\nvar VERTICAL_SIZES_CLASS = \"dx-scheduler-cell-sizes-vertical\";\nvar HEADER_PANEL_CLASS = \"dx-scheduler-header-panel\";\nvar HEADER_PANEL_CELL_CLASS = \"dx-scheduler-header-panel-cell\";\nvar HEADER_ROW_CLASS = \"dx-scheduler-header-row\";\nvar GROUP_ROW_CLASS = \"dx-scheduler-group-row\";\nvar GROUP_HEADER_CLASS = \"dx-scheduler-group-header\";\nvar GROUP_HEADER_CONTENT_CLASS = \"dx-scheduler-group-header-content\";\nvar DATE_TABLE_CLASS = \"dx-scheduler-date-table\";\nvar DATE_TABLE_CELL_CLASS = \"dx-scheduler-date-table-cell\";\nvar DATE_TABLE_ROW_CLASS = \"dx-scheduler-date-table-row\";\nvar DATE_TABLE_FOCUSED_CELL_CLASS = \"dx-scheduler-focused-cell\";\nvar VIRTUAL_ROW_CLASS = \"dx-scheduler-virtual-row\";\nvar DATE_TABLE_DROPPABLE_CELL_CLASS = \"dx-scheduler-date-table-droppable-cell\";\nvar SCHEDULER_HEADER_SCROLLABLE_CLASS = \"dx-scheduler-header-scrollable\";\nvar SCHEDULER_SIDEBAR_SCROLLABLE_CLASS = \"dx-scheduler-sidebar-scrollable\";\nvar SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS = \"dx-scheduler-date-table-scrollable\";\nvar SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME = addNamespace(pointerEvents.down, \"dxSchedulerWorkSpace\");\nvar DragEventNames = {\n  ENTER: addNamespace(dragEventEnter, \"dxSchedulerDateTable\"),\n  DROP: addNamespace(dragEventDrop, \"dxSchedulerDateTable\"),\n  LEAVE: addNamespace(dragEventLeave, \"dxSchedulerDateTable\")\n};\nvar SCHEDULER_CELL_DXCLICK_EVENT_NAME = addNamespace(clickEventName, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME = addNamespace(pointerEvents.down, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME = addNamespace(pointerEvents.up, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME = addNamespace(pointerEvents.move, \"dxSchedulerDateTable\");\nvar CELL_DATA = \"dxCellData\";\nvar DATE_TABLE_CELL_BORDER = 1;\nvar DATE_TABLE_MIN_CELL_WIDTH = 75;\nvar DAY_MS = toMs(\"day\");\nvar HOUR_MS = toMs(\"hour\");\nvar DRAG_AND_DROP_SELECTOR = \".\".concat(DATE_TABLE_CLASS, \" td, .\").concat(ALL_DAY_TABLE_CLASS, \" td\");\nvar CELL_SELECTOR = \".\".concat(DATE_TABLE_CELL_CLASS, \", .\").concat(ALL_DAY_TABLE_CELL_CLASS);\n\nvar ScrollSemaphore = /*#__PURE__*/function () {\n  function ScrollSemaphore() {\n    _classCallCheck(this, ScrollSemaphore);\n\n    this.counter = 0;\n  }\n\n  _createClass(ScrollSemaphore, [{\n    key: \"isFree\",\n    value: function isFree() {\n      return 0 === this.counter;\n    }\n  }, {\n    key: \"take\",\n    value: function take() {\n      this.counter++;\n    }\n  }, {\n    key: \"release\",\n    value: function release() {\n      this.counter--;\n\n      if (this.counter < 0) {\n        this.counter = 0;\n      }\n    }\n  }]);\n\n  return ScrollSemaphore;\n}();\n\nvar formatWeekday = function formatWeekday(date) {\n  return dateLocalization.getDayNames(\"abbreviated\")[date.getDay()];\n};\n\nvar SchedulerWorkSpace = /*#__PURE__*/function (_WidgetObserver) {\n  _inherits(SchedulerWorkSpace, _WidgetObserver);\n\n  var _super = _createSuper(SchedulerWorkSpace);\n\n  function SchedulerWorkSpace() {\n    _classCallCheck(this, SchedulerWorkSpace);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SchedulerWorkSpace, [{\n    key: \"viewDataProvider\",\n    get: function get() {\n      if (!this._viewDataProvider) {\n        this._viewDataProvider = new ViewDataProvider(this);\n      }\n\n      return this._viewDataProvider;\n    }\n  }, {\n    key: \"cache\",\n    get: function get() {\n      return cache;\n    }\n  }, {\n    key: \"virtualSelectionState\",\n    get: function get() {\n      if (!this._virtualSelectionState) {\n        this._virtualSelectionState = new VirtualSelectionState(this.viewDataProvider);\n      }\n\n      return this._virtualSelectionState;\n    }\n  }, {\n    key: \"isAllDayPanelVisible\",\n    get: function get() {\n      return this._isShowAllDayPanel() && this.supportAllDayRow();\n    }\n  }, {\n    key: \"isDateAndTimeView\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"verticalGroupTableClass\",\n    get: function get() {\n      return WORKSPACE_VERTICAL_GROUP_TABLE_CLASS;\n    }\n  }, {\n    key: \"viewDirection\",\n    get: function get() {\n      return \"vertical\";\n    }\n  }, {\n    key: \"renovatedHeaderPanelComponent\",\n    get: function get() {\n      return dxrDateHeader;\n    }\n  }, {\n    key: \"_supportedKeys\",\n    value: function _supportedKeys() {\n      var clickHandler = function clickHandler(e) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        if (this._selectedCells && this._selectedCells.length) {\n          var $itemElement = $(this.option(\"focusedElement\"));\n          var $cellElement = $($itemElement.length ? $itemElement : this._selectedCells);\n          e.target = this._selectedCells;\n          this._showPopup = true;\n\n          this._cellClickAction({\n            event: e,\n            cellElement: $(this._selectedCells),\n            cellData: this.getCellData($cellElement)\n          });\n        }\n      };\n\n      var arrowPressHandler = function arrowPressHandler(e, cell) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        this._moveToCell(cell, e.shiftKey);\n      };\n\n      return extend(_get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_supportedKeys\", this).call(this), {\n        enter: clickHandler,\n        space: clickHandler,\n        downArrow: function downArrow(e) {\n          var $cell = this._getCellFromNextRow(\"next\", e.shiftKey);\n\n          arrowPressHandler.call(this, e, $cell);\n        },\n        upArrow: function upArrow(e) {\n          var $cell = this._getCellFromNextRow(\"prev\", e.shiftKey);\n\n          arrowPressHandler.call(this, e, $cell);\n        },\n        rightArrow: function rightArrow(e) {\n          var $rightCell = this._getCellFromNextColumn(\"next\", e.shiftKey);\n\n          arrowPressHandler.call(this, e, $rightCell);\n        },\n        leftArrow: function leftArrow(e) {\n          var $leftCell = this._getCellFromNextColumn(\"prev\", e.shiftKey);\n\n          arrowPressHandler.call(this, e, $leftCell);\n        }\n      });\n    }\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      var _this$virtualScrollin;\n\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_dispose\", this).call(this);\n\n      null === (_this$virtualScrollin = this.virtualScrollingDispatcher) || void 0 === _this$virtualScrollin ? void 0 : _this$virtualScrollin.dispose();\n    }\n  }, {\n    key: \"_isRTL\",\n    value: function _isRTL() {\n      return this.option(\"rtlEnabled\");\n    }\n  }, {\n    key: \"_getFocusedCell\",\n    value: function _getFocusedCell() {\n      return this._$focusedCell || this._$dateTable.find(\".\" + DATE_TABLE_CELL_CLASS).eq(0);\n    }\n  }, {\n    key: \"_getAllFocusedCells\",\n    value: function _getAllFocusedCells() {\n      return this._selectedCells || this._$dateTable.find(\".\" + DATE_TABLE_CELL_CLASS).eq(0);\n    }\n  }, {\n    key: \"_getCellFromNextRow\",\n    value: function _getCellFromNextRow(direction) {\n      var $currentCell = this._$focusedCell;\n\n      if (isDefined($currentCell)) {\n        var cellIndex = $currentCell.index();\n        var $row = $currentCell.parent();\n        var $cell = $row[direction]().children().eq(cellIndex);\n        $cell = this._checkForViewBounds($cell);\n        return $cell;\n      }\n    }\n  }, {\n    key: \"_checkForViewBounds\",\n    value: function _checkForViewBounds($item) {\n      if (!$item.length) {\n        $item = this._$focusedCell;\n      }\n\n      return $item;\n    }\n  }, {\n    key: \"_getCellFromNextColumn\",\n    value: function _getCellFromNextColumn(direction, isMultiSelection) {\n      var $focusedCell = this._$focusedCell;\n\n      if (!isDefined($focusedCell)) {\n        return;\n      }\n\n      var $nextCell;\n      var $row = $focusedCell.parent();\n      var nextColumnDirection = direction;\n      var isDirectionNext = \"next\" === direction;\n      var previousColumnDirection = isDirectionNext ? \"prev\" : \"next\";\n\n      var isRTL = this._isRTL();\n\n      var groupCount = this._getGroupCount();\n\n      var isHorizontalGrouping = this._isHorizontalGroupedWorkSpace();\n\n      var isGroupedByDate = this.isGroupedByDate();\n\n      var totalCellCount = this._getTotalCellCount(groupCount);\n\n      var rowCellCount = isMultiSelection && !isGroupedByDate ? this._getCellCount() : totalCellCount;\n      var lastIndexInRow = rowCellCount - 1;\n      var currentIndex = $focusedCell.index();\n      var step = isGroupedByDate && isMultiSelection ? groupCount : 1;\n\n      var isEdgeCell = this._isEdgeCell(isHorizontalGrouping ? totalCellCount - 1 : lastIndexInRow, currentIndex, step, direction);\n\n      var sign = isRTL ? 1 : -1;\n      var directionSign = isDirectionNext ? 1 : -1;\n      var resultingSign = sign * directionSign;\n\n      if (isEdgeCell || isMultiSelection && this._isGroupEndCell($focusedCell, direction)) {\n        var nextIndex = currentIndex - resultingSign * step + resultingSign * rowCellCount;\n        var rowDirection = isRTL ? previousColumnDirection : nextColumnDirection;\n        $nextCell = $row[rowDirection]().children().eq(nextIndex);\n        $nextCell = this._checkForViewBounds($nextCell);\n      } else {\n        $nextCell = $row.children().eq(currentIndex - resultingSign * step);\n      }\n\n      return $nextCell;\n    }\n  }, {\n    key: \"_isEdgeCell\",\n    value: function _isEdgeCell(lastIndexInRow, cellIndex, step, direction) {\n      var isRTL = this._isRTL();\n\n      var isDirectionNext = \"next\" === direction;\n      var rightEdgeCellIndex = isRTL ? 0 : lastIndexInRow;\n      var leftEdgeCellIndex = isRTL ? lastIndexInRow : 0;\n      var edgeCellIndex = isDirectionNext ? rightEdgeCellIndex : leftEdgeCellIndex;\n      var isNextCellGreaterThanEdge = cellIndex + step > edgeCellIndex;\n      var isNextCellLessThanEdge = cellIndex - step < edgeCellIndex;\n      var isRightEdgeCell = isRTL ? isNextCellLessThanEdge : isNextCellGreaterThanEdge;\n      var isLeftEdgeCell = isRTL ? isNextCellGreaterThanEdge : isNextCellLessThanEdge;\n      return isDirectionNext ? isRightEdgeCell : isLeftEdgeCell;\n    }\n  }, {\n    key: \"_isGroupEndCell\",\n    value: function _isGroupEndCell($cell, direction) {\n      if (this.isGroupedByDate()) {\n        return false;\n      }\n\n      var isDirectionNext = \"next\" === direction;\n\n      var cellsInRow = this._getCellCount();\n\n      var currentCellIndex = $cell.index();\n      var result = currentCellIndex % cellsInRow;\n      var endCell = isDirectionNext ? cellsInRow - 1 : 0;\n      var startCell = isDirectionNext ? 0 : cellsInRow - 1;\n      return this._isRTL() ? result === startCell : result === endCell;\n    }\n  }, {\n    key: \"_moveToCell\",\n    value: function _moveToCell($cell, isMultiSelection) {\n      isMultiSelection = isMultiSelection && this.option(\"allowMultipleCellSelection\");\n\n      this._setSelectedAndFocusedCells($cell, isMultiSelection);\n\n      this._dateTableScrollable.scrollToElement($cell);\n    }\n  }, {\n    key: \"_setSelectedAndFocusedCells\",\n    value: function _setSelectedAndFocusedCells($cell, isMultiSelection) {\n      if (!isDefined($cell) || !$cell.length) {\n        return;\n      }\n\n      var updateViewData = this.isVirtualScrolling();\n      var $correctedCell = $cell;\n\n      if (isMultiSelection) {\n        $correctedCell = this._correctCellForGroup($cell);\n      }\n\n      if ($correctedCell.hasClass(DATE_TABLE_FOCUSED_CELL_CLASS)) {\n        return;\n      }\n\n      this._setSelectedCells($correctedCell, isMultiSelection);\n\n      this._setFocusedCell($correctedCell, updateViewData);\n    }\n  }, {\n    key: \"_setFocusedCell\",\n    value: function _setFocusedCell($cell) {\n      var updateViewData = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;\n\n      this._releaseFocusedCell();\n\n      var $correctedCell = $cell;\n\n      if (updateViewData) {\n        var _this$_getCoordinates = this._getCoordinatesByCell($cell),\n            rowIndex = _this$_getCoordinates.rowIndex,\n            columnIndex = _this$_getCoordinates.columnIndex;\n\n        var isAllDayCell = this._hasAllDayClass($cell);\n\n        this.virtualSelectionState.setFocusedCell(rowIndex, columnIndex, isAllDayCell);\n        var focusedCell = this.virtualSelectionState.getFocusedCell();\n        var cellData = focusedCell.cellData,\n            coordinates = focusedCell.coordinates;\n        var allDay = cellData.allDay;\n        $correctedCell = allDay && !this._isVerticalGroupedWorkSpace() ? this._dom_getAllDayPanelCell(coordinates.cellIndex) : this._dom_getDateCell(coordinates);\n      }\n\n      this._toggleFocusedCellClass(true, $correctedCell);\n\n      this._$focusedCell = $correctedCell;\n    }\n  }, {\n    key: \"_setSelectedCells\",\n    value: function _setSelectedCells($firstCell, isMultiSelection) {\n      this._releaseSelectedCells();\n\n      this._selectedCells = [];\n\n      if (this.isVirtualScrolling()) {\n        this._setSelectedCellsInVirtualMode($firstCell, isMultiSelection);\n      } else {\n        this._setSelectedCellsInStandardMode($firstCell, isMultiSelection);\n      }\n\n      var $selectedCells = $(this._selectedCells);\n\n      this._toggleFocusClass(true, $selectedCells);\n\n      this.setAria(\"label\", \"Add appointment\", $selectedCells);\n      var selectedCellData = this.getSelectedCellData().map(function (_ref) {\n        var startDate = _ref.startDate,\n            endDate = _ref.endDate,\n            allDay = _ref.allDay,\n            groups = _ref.groups,\n            groupIndex = _ref.groupIndex;\n        return {\n          startDate: startDate,\n          endDate: endDate,\n          allDay: allDay,\n          groups: groups,\n          groupIndex: groupIndex || 0\n        };\n      });\n      this.option(\"selectedCellData\", selectedCellData);\n\n      this._selectionChangedAction({\n        selectedCellData: selectedCellData\n      });\n    }\n  }, {\n    key: \"_setSelectedCellsInStandardMode\",\n    value: function _setSelectedCellsInStandardMode($firstCell, isMultiSelection) {\n      if (isMultiSelection) {\n        var $previousCell = this._$prevCell;\n        var orientation = \"day\" === this.option(\"type\") && (!this.option(\"groups\").length || \"vertical\" === this.option(\"groupOrientation\")) ? \"vertical\" : \"horizontal\";\n\n        var $targetCells = this._getCellsBetween($firstCell, $previousCell, orientation);\n\n        this._selectedCells = $targetCells.toArray();\n      } else {\n        this._selectedCells = [$firstCell.get(0)];\n        this._$prevCell = $firstCell;\n      }\n    }\n  }, {\n    key: \"_setSelectedCellsInVirtualMode\",\n    value: function _setSelectedCellsInVirtualMode($firstCell, isMultiSelection) {\n      if (isMultiSelection) {\n        var _this$_getCoordinates2 = this._getCoordinatesByCell($firstCell),\n            firstRow = _this$_getCoordinates2.rowIndex,\n            firstColumn = _this$_getCoordinates2.columnIndex;\n\n        var isFirstAllDay = this._hasAllDayClass($firstCell);\n\n        var firstCell = {\n          rowIndex: firstRow,\n          columnIndex: firstColumn,\n          allDay: isFirstAllDay\n        };\n        this.virtualSelectionState.setSelectedCells(firstCell);\n      } else {\n        this._selectedCells = [$firstCell.get(0)];\n        this._$prevCell = $firstCell;\n\n        var _this$_getCoordinates3 = this._getCoordinatesByCell($firstCell),\n            rowIndex = _this$_getCoordinates3.rowIndex,\n            columnIndex = _this$_getCoordinates3.columnIndex;\n\n        var isAllDayCell = this._hasAllDayClass($firstCell);\n\n        var _firstCell = {\n          rowIndex: rowIndex,\n          columnIndex: columnIndex,\n          allDay: isAllDayCell\n        };\n        this.virtualSelectionState.setSelectedCells(_firstCell, _firstCell);\n      }\n\n      this._setSelectedCellsByCellData(this.virtualSelectionState.getSelectedCells());\n    }\n  }, {\n    key: \"_correctCellForGroup\",\n    value: function _correctCellForGroup($cell) {\n      if (this.isVirtualScrolling()) {\n        var isVirtualCell = $cell.hasClass(VIRTUAL_CELL_CLASS);\n\n        if (isVirtualCell) {\n          return this._$focusedCell;\n        }\n\n        var cellData = this.getCellData($cell);\n        var isValidFocusedCell = this.virtualSelectionState.isValidFocusedCell(cellData);\n        return isValidFocusedCell ? $cell : this._$focusedCell;\n      }\n\n      var $focusedCell = this._$focusedCell;\n\n      var cellGroupIndex = this._getGroupIndexByCell($cell);\n\n      var focusedCellGroupIndex = this._getGroupIndexByCell($focusedCell);\n\n      var isDifferentTables = this._hasAllDayClass($cell) !== this._hasAllDayClass($focusedCell);\n\n      return focusedCellGroupIndex !== cellGroupIndex || isDifferentTables ? $focusedCell : $cell;\n    }\n  }, {\n    key: \"_getCellsBetween\",\n    value: function _getCellsBetween($first, $last, direction) {\n      var isAllDayTable = this._hasAllDayClass($last);\n\n      var $cells = this._getCells(isAllDayTable, direction);\n\n      var firstIndex = $cells.index($first);\n      var lastIndex = $cells.index($last);\n\n      if (firstIndex > lastIndex) {\n        var buffer = firstIndex;\n        firstIndex = lastIndex;\n        lastIndex = buffer;\n      }\n\n      $cells = $cells.slice(firstIndex, lastIndex + 1);\n\n      if (this._getGroupCount() > 1) {\n        var result = [];\n\n        var focusedGroupIndex = this._getGroupIndexByCell($first);\n\n        each($cells, function (_, cell) {\n          var groupIndex = this._getGroupIndexByCell($(cell));\n\n          if (focusedGroupIndex === groupIndex) {\n            result.push(cell);\n          }\n        }.bind(this));\n        $cells = $(result);\n      }\n\n      return $cells;\n    }\n  }, {\n    key: \"_hasAllDayClass\",\n    value: function _hasAllDayClass($cell) {\n      return $cell.hasClass(ALL_DAY_TABLE_CELL_CLASS);\n    }\n  }, {\n    key: \"_getGroupIndexByCell\",\n    value: function _getGroupIndexByCell($cell) {\n      if (this.isVirtualScrolling()) {\n        var _this$_getCoordinates4 = this._getCoordinatesByCell($cell),\n            rowIndex = _this$_getCoordinates4.rowIndex,\n            columnIndex = _this$_getCoordinates4.columnIndex;\n\n        var isAllDayCell = $cell.hasClass(ALL_DAY_TABLE_CELL_CLASS);\n        return this.viewDataProvider.getCellData(rowIndex, columnIndex, isAllDayCell).groupIndex;\n      }\n\n      return this._groupedStrategy.getGroupIndexByCell($cell);\n    }\n  }, {\n    key: \"_toggleFocusedCellClass\",\n    value: function _toggleFocusedCellClass(isFocused, $element) {\n      var $focusTarget = $element && $element.length ? $element : this._focusTarget();\n      $focusTarget.toggleClass(DATE_TABLE_FOCUSED_CELL_CLASS, isFocused);\n    }\n  }, {\n    key: \"_releaseSelectedAndFocusedCells\",\n    value: function _releaseSelectedAndFocusedCells() {\n      this._releaseFocusedCell();\n\n      this._releaseSelectedCells();\n\n      this.option(\"selectedCellData\", []);\n    }\n  }, {\n    key: \"_releaseFocusedCell\",\n    value: function _releaseFocusedCell() {\n      var $cell = this._$focusedCell;\n\n      if (isDefined($cell) && $cell.length) {\n        this._toggleFocusedCellClass(false, $cell);\n\n        this.setAria(\"label\", void 0, $cell);\n      }\n    }\n  }, {\n    key: \"_releaseSelectedCells\",\n    value: function _releaseSelectedCells() {\n      var $cells = $(this._selectedCells);\n\n      if (isDefined($cells) && $cells.length) {\n        this._toggleFocusClass(false, $cells);\n\n        this.setAria(\"label\", void 0, $cells);\n      }\n    }\n  }, {\n    key: \"_focusInHandler\",\n    value: function _focusInHandler(e) {\n      if ($(e.target).is(this._focusTarget()) && false !== this._isCellClick) {\n        delete this._isCellClick;\n        delete this._contextMenuHandled;\n\n        _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_focusInHandler\", this).apply(this, arguments);\n\n        var $cell = this._getFocusedCell();\n\n        this._setSelectedAndFocusedCells($cell);\n      }\n    }\n  }, {\n    key: \"_focusOutHandler\",\n    value: function _focusOutHandler() {\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_focusOutHandler\", this).apply(this, arguments);\n\n      if (!this._contextMenuHandled) {\n        var _this$virtualSelectio;\n\n        this._releaseSelectedAndFocusedCells();\n\n        null === (_this$virtualSelectio = this.virtualSelectionState) || void 0 === _this$virtualSelectio ? void 0 : _this$virtualSelectio.releaseSelectedAndFocusedCells();\n      }\n    }\n  }, {\n    key: \"_focusTarget\",\n    value: function _focusTarget() {\n      return this.$element();\n    }\n  }, {\n    key: \"_getDefaultOptions\",\n    value: function _getDefaultOptions() {\n      return extend(_get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_getDefaultOptions\", this).call(this), {\n        currentDate: new Date(),\n        intervalCount: 1,\n        startDate: null,\n        firstDayOfWeek: void 0,\n        startDayHour: 0,\n        endDayHour: 24,\n        hoursInterval: .5,\n        activeStateEnabled: true,\n        hoverStateEnabled: true,\n        groups: [],\n        showAllDayPanel: true,\n        allDayExpanded: false,\n        onCellClick: null,\n        crossScrollingEnabled: false,\n        dataCellTemplate: null,\n        timeCellTemplate: null,\n        resourceCellTemplate: null,\n        dateCellTemplate: null,\n        allowMultipleCellSelection: true,\n        indicatorTime: new Date(),\n        indicatorUpdateInterval: 5 * toMs(\"minute\"),\n        shadeUntilCurrentTime: true,\n        groupOrientation: \"horizontal\",\n        selectedCellData: [],\n        groupByDate: false,\n        scrolling: {\n          mode: \"standard\"\n        },\n        renovateRender: true,\n        height: void 0,\n        draggingMode: \"outlook\"\n      });\n    }\n  }, {\n    key: \"_optionChanged\",\n    value: function _optionChanged(args) {\n      switch (args.name) {\n        case \"startDayHour\":\n        case \"endDayHour\":\n          this.invoke(\"validateDayHours\");\n\n          this._cleanWorkSpace();\n\n          break;\n\n        case \"dateCellTemplate\":\n        case \"resourceCellTemplate\":\n        case \"dataCellTemplate\":\n        case \"timeCellTemplate\":\n        case \"hoursInterval\":\n        case \"firstDayOfWeek\":\n        case \"currentDate\":\n        case \"startDate\":\n          this._cleanWorkSpace();\n\n          break;\n\n        case \"groups\":\n          this._cleanView();\n\n          this._removeAllDayElements();\n\n          this._initGrouping();\n\n          this.repaint();\n          break;\n\n        case \"groupOrientation\":\n          this._initGroupedStrategy();\n\n          this._createAllDayPanelElements();\n\n          this._removeAllDayElements();\n\n          this._cleanWorkSpace();\n\n          this._toggleGroupByDateClass();\n\n          break;\n\n        case \"showAllDayPanel\":\n          if (this._isVerticalGroupedWorkSpace()) {\n            this._cleanView();\n\n            this._removeAllDayElements();\n\n            this._initGrouping();\n\n            this.repaint();\n          } else if (!this.isRenovatedRender()) {\n            this._toggleAllDayVisibility(true);\n          } else {\n            this.renderRWorkspace();\n          }\n\n          break;\n\n        case \"allDayExpanded\":\n          this._changeAllDayVisibility();\n\n          this._attachTablesEvents();\n\n          this.headerPanelOffsetRecalculate();\n\n          this._updateScrollable();\n\n          break;\n\n        case \"onSelectionChanged\":\n          this._createSelectionChangedAction();\n\n          break;\n\n        case \"onCellClick\":\n          this._createCellClickAction();\n\n          break;\n\n        case \"onCellContextMenu\":\n          this._attachContextMenuEvent();\n\n          break;\n\n        case \"intervalCount\":\n          this._cleanWorkSpace();\n\n          this._toggleWorkSpaceCountClass();\n\n          this._toggleFixedScrollableClass();\n\n          break;\n\n        case \"groupByDate\":\n          this._cleanWorkSpace();\n\n          this._toggleGroupByDateClass();\n\n          break;\n\n        case \"crossScrollingEnabled\":\n          this._toggleHorizontalScrollClass();\n\n          this._dateTableScrollable.option(this._dateTableScrollableConfig());\n\n          break;\n\n        case \"width\":\n          _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_optionChanged\", this).call(this, args);\n\n          this._dimensionChanged();\n\n          break;\n\n        case \"allowMultipleCellSelection\":\n        case \"selectedCellData\":\n          break;\n\n        case \"scrolling\":\n          if (this._isVirtualModeOn()) {\n            if (!this.option(\"renovateRender\")) {\n              this.option(\"renovateRender\", true);\n            } else {\n              this.repaint();\n            }\n          } else {\n            this.option(\"renovateRender\", false);\n          }\n\n          break;\n\n        case \"renovateRender\":\n          this.repaint();\n          break;\n\n        default:\n          _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_optionChanged\", this).call(this, args);\n\n      }\n    }\n  }, {\n    key: \"_cleanWorkSpace\",\n    value: function _cleanWorkSpace() {\n      var _this$virtualScrollin2;\n\n      this._cleanView();\n\n      this._toggleGroupedClass();\n\n      this._toggleWorkSpaceWithOddCells();\n\n      null === (_this$virtualScrollin2 = this.virtualScrollingDispatcher) || void 0 === _this$virtualScrollin2 ? void 0 : _this$virtualScrollin2.updateDimensions(true);\n\n      this._renderView();\n\n      this.option(\"crossScrollingEnabled\") && this._setTableSizes();\n      this.cache.clear();\n    }\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      this._headerSemaphore = new ScrollSemaphore();\n      this._sideBarSemaphore = new ScrollSemaphore();\n      this._dataTableSemaphore = new ScrollSemaphore();\n      this._viewDataProvider = null;\n      this._virtualSelectionState = null;\n      this._activeStateUnit = CELL_SELECTOR;\n      this._maxAllowedVerticalPosition = [];\n      this._maxAllowedPosition = [];\n\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_init\", this).call(this);\n\n      this._initGrouping();\n\n      this._toggleHorizontalScrollClass();\n\n      this._toggleWorkSpaceCountClass();\n\n      this._toggleGroupByDateClass();\n\n      this._toggleWorkSpaceWithOddCells();\n\n      this.$element().addClass(COMPONENT_CLASS).addClass(this._getElementClass());\n    }\n  }, {\n    key: \"_initGrouping\",\n    value: function _initGrouping() {\n      this._initGroupedStrategy();\n\n      this._toggleGroupingDirectionClass();\n\n      this._toggleGroupByDateClass();\n    }\n  }, {\n    key: \"_initGroupedStrategy\",\n    value: function _initGroupedStrategy() {\n      var strategyName = this.option(\"groups\").length ? this.option(\"groupOrientation\") : this._getDefaultGroupStrategy();\n      var Strategy = \"vertical\" === strategyName ? VerticalGroupedStrategy : HorizontalGroupedStrategy;\n      this._groupedStrategy = new Strategy(this);\n    }\n  }, {\n    key: \"_getDefaultGroupStrategy\",\n    value: function _getDefaultGroupStrategy() {\n      return \"horizontal\";\n    }\n  }, {\n    key: \"_isVerticalGroupedWorkSpace\",\n    value: function _isVerticalGroupedWorkSpace() {\n      return !!this.option(\"groups\").length && \"vertical\" === this.option(\"groupOrientation\");\n    }\n  }, {\n    key: \"_isHorizontalGroupedWorkSpace\",\n    value: function _isHorizontalGroupedWorkSpace() {\n      return !!this.option(\"groups\").length && \"horizontal\" === this.option(\"groupOrientation\");\n    }\n  }, {\n    key: \"_toggleHorizontalScrollClass\",\n    value: function _toggleHorizontalScrollClass() {\n      this.$element().toggleClass(WORKSPACE_WITH_BOTH_SCROLLS_CLASS, this.option(\"crossScrollingEnabled\"));\n    }\n  }, {\n    key: \"_toggleGroupByDateClass\",\n    value: function _toggleGroupByDateClass() {\n      this.$element().toggleClass(WORKSPACE_WITH_GROUP_BY_DATE_CLASS, this.isGroupedByDate());\n    }\n  }, {\n    key: \"_toggleWorkSpaceCountClass\",\n    value: function _toggleWorkSpaceCountClass() {\n      this.$element().toggleClass(WORKSPACE_WITH_COUNT_CLASS, this._isWorkSpaceWithCount());\n    }\n  }, {\n    key: \"_isWorkSpaceWithCount\",\n    value: function _isWorkSpaceWithCount() {\n      return this.option(\"intervalCount\") > 1;\n    }\n  }, {\n    key: \"_toggleWorkSpaceWithOddCells\",\n    value: function _toggleWorkSpaceWithOddCells() {\n      this.$element().toggleClass(WORKSPACE_WITH_ODD_CELLS_CLASS, this._isWorkspaceWithOddCells());\n    }\n  }, {\n    key: \"_isWorkspaceWithOddCells\",\n    value: function _isWorkspaceWithOddCells() {\n      return .5 === this.option(\"hoursInterval\") && !this.isVirtualScrolling();\n    }\n  }, {\n    key: \"_toggleGroupingDirectionClass\",\n    value: function _toggleGroupingDirectionClass() {\n      this.$element().toggleClass(VERTICAL_GROUPED_WORKSPACE_CLASS, this._isVerticalGroupedWorkSpace());\n    }\n  }, {\n    key: \"_getRealGroupOrientation\",\n    value: function _getRealGroupOrientation() {\n      return this._isVerticalGroupedWorkSpace() ? \"vertical\" : \"horizontal\";\n    }\n  }, {\n    key: \"_getTimePanelClass\",\n    value: function _getTimePanelClass() {\n      return TIME_PANEL_CLASS;\n    }\n  }, {\n    key: \"_getDateTableClass\",\n    value: function _getDateTableClass() {\n      return DATE_TABLE_CLASS;\n    }\n  }, {\n    key: \"_getDateTableRowClass\",\n    value: function _getDateTableRowClass() {\n      return DATE_TABLE_ROW_CLASS;\n    }\n  }, {\n    key: \"_getDateTableCellClass\",\n    value: function _getDateTableCellClass(i, j) {\n      var cellClass = DATE_TABLE_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS + \" \" + VERTICAL_SIZES_CLASS;\n      return this._needApplyLastGroupCellClass() ? this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, j + 1, i, j) : cellClass;\n    }\n  }, {\n    key: \"_needApplyLastGroupCellClass\",\n    value: function _needApplyLastGroupCellClass() {\n      return true;\n    }\n  }, {\n    key: \"_getGroupRowClass\",\n    value: function _getGroupRowClass() {\n      return GROUP_ROW_CLASS;\n    }\n  }, {\n    key: \"_getGroupHeaderClass\",\n    value: function _getGroupHeaderClass(i) {\n      var cellClass = GROUP_HEADER_CLASS;\n      return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1);\n    }\n  }, {\n    key: \"_getGroupHeaderContentClass\",\n    value: function _getGroupHeaderContentClass() {\n      return GROUP_HEADER_CONTENT_CLASS;\n    }\n  }, {\n    key: \"_initWorkSpaceUnits\",\n    value: function _initWorkSpaceUnits() {\n      this._$headerPanel = $(\"<table>\");\n      this._$thead = $(\"<thead>\").appendTo(this._$headerPanel);\n      this._$fixedContainer = $(\"<div>\").addClass(FIXED_CONTAINER_CLASS);\n      this._$allDayContainer = $(\"<div>\").addClass(ALL_DAY_CONTAINER_CLASS);\n\n      this._initAllDayPanelElements();\n\n      if (this.isRenovatedRender()) {\n        this.createRAllDayPanelElements();\n      } else {\n        this._createAllDayPanelElements();\n      }\n\n      this._$timePanel = $(\"<table>\").addClass(this._getTimePanelClass());\n      this._$dateTable = $(\"<table>\");\n      this._$groupTable = $(\"<div>\").addClass(WORKSPACE_VERTICAL_GROUP_TABLE_CLASS);\n    }\n  }, {\n    key: \"_initAllDayPanelElements\",\n    value: function _initAllDayPanelElements() {\n      this._allDayTitles = [];\n      this._allDayTables = [];\n      this._allDayPanels = [];\n    }\n  }, {\n    key: \"createRAllDayPanelElements\",\n    value: function createRAllDayPanelElements() {\n      this._$allDayPanel = $(\"<div>\");\n      this._$allDayTitle = $(\"<div>\").appendTo(this.$element());\n    }\n  }, {\n    key: \"_createAllDayPanelElements\",\n    value: function _createAllDayPanelElements() {\n      var groupCount = this._getGroupCount();\n\n      if (this._isVerticalGroupedWorkSpace() && 0 !== groupCount) {\n        for (var i = 0; i < groupCount; i++) {\n          var $allDayTitle = $(\"<div>\").addClass(ALL_DAY_TITLE_CLASS).text(messageLocalization.format(\"dxScheduler-allDay\"));\n\n          this._allDayTitles.push($allDayTitle);\n\n          this._$allDayTable = $(\"<table>\");\n\n          this._allDayTables.push(this._$allDayTable);\n\n          this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);\n\n          this._allDayPanels.push(this._$allDayPanel);\n        }\n      } else {\n        this._$allDayTitle = $(\"<div>\").addClass(ALL_DAY_TITLE_CLASS).text(messageLocalization.format(\"dxScheduler-allDay\")).appendTo(this.$element());\n        this._$allDayTable = $(\"<table>\");\n        this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);\n      }\n    }\n  }, {\n    key: \"_initDateTableScrollable\",\n    value: function _initDateTableScrollable() {\n      var $dateTableScrollable = $(\"<div>\").addClass(SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS);\n      this._dateTableScrollable = this._createComponent($dateTableScrollable, Scrollable, this._dateTableScrollableConfig());\n    }\n  }, {\n    key: \"_dateTableScrollableConfig\",\n    value: function _dateTableScrollableConfig() {\n      var config = {\n        useKeyboard: false,\n        bounceEnabled: false,\n        updateManually: true\n      };\n\n      if (this._needCreateCrossScrolling()) {\n        config = extend(config, this._createCrossScrollingConfig());\n      }\n\n      return config;\n    }\n  }, {\n    key: \"_createCrossScrollingConfig\",\n    value: function _createCrossScrollingConfig() {\n      var _this = this;\n\n      var config = {};\n      config.direction = \"both\";\n\n      config.onScroll = function (e) {\n        _this._dataTableSemaphore.take();\n\n        _this._sideBarSemaphore.isFree() && _this._sidebarScrollable && _this._sidebarScrollable.scrollTo({\n          top: e.scrollOffset.top\n        });\n        _this._headerSemaphore.isFree() && _this._headerScrollable && _this._headerScrollable.scrollTo({\n          left: e.scrollOffset.left\n        });\n\n        _this._dataTableSemaphore.release();\n      };\n\n      config.onEnd = function () {\n        _this.notifyObserver(\"updateResizableArea\", {});\n      };\n\n      return config;\n    }\n  }, {\n    key: \"_createWorkSpaceElements\",\n    value: function _createWorkSpaceElements() {\n      if (this.option(\"crossScrollingEnabled\")) {\n        this._createWorkSpaceScrollableElements();\n      } else {\n        this._createWorkSpaceStaticElements();\n      }\n    }\n  }, {\n    key: \"_createWorkSpaceStaticElements\",\n    value: function _createWorkSpaceStaticElements() {\n      if (this._isVerticalGroupedWorkSpace()) {\n        this._dateTableScrollable.$content().append(this._$allDayContainer, this._$groupTable, this._$timePanel, this._$dateTable);\n\n        this.$element().append(this._$fixedContainer, this._$headerPanel, this._dateTableScrollable.$element());\n      } else {\n        this._dateTableScrollable.$content().append(this._$timePanel, this._$dateTable);\n\n        this.$element().append(this._$fixedContainer, this._$headerPanel, this._$allDayContainer, this._$allDayPanel, this._dateTableScrollable.$element());\n      }\n    }\n  }, {\n    key: \"_createWorkSpaceScrollableElements\",\n    value: function _createWorkSpaceScrollableElements() {\n      this.$element().append(this._$fixedContainer);\n\n      this._createHeaderScrollable();\n\n      this._createSidebarScrollable();\n\n      this.$element().append(this._dateTableScrollable.$element());\n\n      this._headerScrollable.$content().append(this._$headerPanel);\n\n      this._dateTableScrollable.$content().append(this._$dateTable);\n\n      if (this._isVerticalGroupedWorkSpace()) {\n        this._dateTableScrollable.$content().prepend(this._$allDayContainer);\n\n        this._sidebarScrollable.$content().append(this._$groupTable, this._$timePanel);\n      } else {\n        this._headerScrollable.$content().append(this._$allDayContainer, this._$allDayPanel);\n      }\n\n      this._sidebarScrollable.$content().append(this._$timePanel);\n    }\n  }, {\n    key: \"_createHeaderScrollable\",\n    value: function _createHeaderScrollable() {\n      var $headerScrollable = $(\"<div>\").addClass(SCHEDULER_HEADER_SCROLLABLE_CLASS).appendTo(this.$element());\n      this._headerScrollable = this._createComponent($headerScrollable, Scrollable, this._headerScrollableConfig());\n    }\n  }, {\n    key: \"_headerScrollableConfig\",\n    value: function _headerScrollableConfig() {\n      var _this2 = this;\n\n      var config = {\n        useKeyboard: false,\n        showScrollbar: false,\n        direction: \"horizontal\",\n        useNative: false,\n        updateManually: true,\n        bounceEnabled: false,\n        onScroll: function onScroll(e) {\n          _this2._headerSemaphore.take();\n\n          _this2._dataTableSemaphore.isFree() && _this2._dateTableScrollable.scrollTo({\n            left: e.scrollOffset.left\n          });\n\n          _this2._headerSemaphore.release();\n        }\n      };\n      return config;\n    }\n  }, {\n    key: \"_createSidebarScrollable\",\n    value: function _createSidebarScrollable() {\n      var _this3 = this;\n\n      var $timePanelScrollable = $(\"<div>\").addClass(SCHEDULER_SIDEBAR_SCROLLABLE_CLASS).appendTo(this.$element());\n      this._sidebarScrollable = this._createComponent($timePanelScrollable, Scrollable, {\n        useKeyboard: false,\n        showScrollbar: false,\n        direction: \"vertical\",\n        useNative: false,\n        updateManually: true,\n        bounceEnabled: false,\n        onScroll: function onScroll(e) {\n          _this3._sideBarSemaphore.take();\n\n          _this3._dataTableSemaphore.isFree() && _this3._dateTableScrollable.scrollTo({\n            top: e.scrollOffset.top\n          });\n\n          _this3._sideBarSemaphore.release();\n        }\n      });\n    }\n  }, {\n    key: \"_visibilityChanged\",\n    value: function _visibilityChanged(visible) {\n      this.cache.clear();\n\n      if (visible) {\n        this._updateGroupTableHeight();\n      }\n\n      if (visible && this._needCreateCrossScrolling()) {\n        this._setTableSizes();\n      }\n    }\n  }, {\n    key: \"_attachTableClasses\",\n    value: function _attachTableClasses() {\n      this._addTableClass(this._$dateTable, this._getDateTableClass());\n\n      if (this._isVerticalGroupedWorkSpace()) {\n        var groupCount = this._getGroupCount();\n\n        for (var i = 0; i < groupCount; i++) {\n          this._addTableClass(this._allDayTables[i], ALL_DAY_TABLE_CLASS);\n        }\n      } else {\n        this._addTableClass(this._$allDayTable, ALL_DAY_TABLE_CLASS);\n      }\n    }\n  }, {\n    key: \"_attachHeaderTableClasses\",\n    value: function _attachHeaderTableClasses() {\n      this._addTableClass(this._$headerPanel, HEADER_PANEL_CLASS);\n    }\n  }, {\n    key: \"_addTableClass\",\n    value: function _addTableClass($el, className) {\n      $el && !$el.hasClass(className) && $el.addClass(className);\n    }\n  }, {\n    key: \"_setTableSizes\",\n    value: function _setTableSizes() {\n      this._attachTableClasses();\n\n      var cellWidth = this.getCellWidth();\n\n      if (cellWidth < this.getCellMinWidth()) {\n        cellWidth = this.getCellMinWidth();\n      }\n\n      var minWidth = this.getWorkSpaceMinWidth();\n\n      var groupCount = this._getGroupCount();\n\n      var totalCellCount = this._getTotalCellCount(groupCount);\n\n      var width = cellWidth * totalCellCount;\n\n      if (width < minWidth) {\n        width = minWidth;\n      }\n\n      this._$headerPanel.width(width);\n\n      this._$dateTable.width(width);\n\n      this._$allDayTable && this._$allDayTable.width(width);\n\n      this._attachHeaderTableClasses();\n\n      this._updateGroupTableHeight();\n    }\n  }, {\n    key: \"getWorkSpaceMinWidth\",\n    value: function getWorkSpaceMinWidth() {\n      return this._groupedStrategy.getWorkSpaceMinWidth();\n    }\n  }, {\n    key: \"_dimensionChanged\",\n    value: function _dimensionChanged() {\n      if (this.option(\"crossScrollingEnabled\")) {\n        this._setTableSizes();\n      }\n\n      this.headerPanelOffsetRecalculate();\n      this.cache.clear();\n\n      this._cleanAllowedPositions();\n    }\n  }, {\n    key: \"_needCreateCrossScrolling\",\n    value: function _needCreateCrossScrolling() {\n      return this.option(\"crossScrollingEnabled\");\n    }\n  }, {\n    key: \"_getElementClass\",\n    value: function _getElementClass() {\n      return noop();\n    }\n  }, {\n    key: \"_getRowCount\",\n    value: function _getRowCount() {\n      return noop();\n    }\n  }, {\n    key: \"_getRowCountWithAllDayRows\",\n    value: function _getRowCountWithAllDayRows() {\n      var allDayRowCount = this._isShowAllDayPanel() ? 1 : 0;\n      return this._getRowCount() + allDayRowCount;\n    }\n  }, {\n    key: \"_getCellCount\",\n    value: function _getCellCount() {\n      return noop();\n    }\n  }, {\n    key: \"_initMarkup\",\n    value: function _initMarkup() {\n      this.cache.clear();\n\n      this._initWorkSpaceUnits();\n\n      this._initDateTableScrollable();\n\n      this._createWorkSpaceElements();\n\n      this._initVirtualScrolling();\n\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_initMarkup\", this).call(this);\n\n      if (!this.option(\"crossScrollingEnabled\")) {\n        this._attachTableClasses();\n\n        this._attachHeaderTableClasses();\n      }\n\n      this._toggleGroupedClass();\n\n      this._toggleFixedScrollableClass();\n\n      this._renderView();\n\n      this._attachEvents();\n\n      this._setFocusOnCellByOption(this.option(\"selectedCellData\"));\n    }\n  }, {\n    key: \"isRenovatedRender\",\n    value: function isRenovatedRender() {\n      return this.renovatedRenderSupported() && this.option(\"renovateRender\");\n    }\n  }, {\n    key: \"_isVirtualModeOn\",\n    value: function _isVirtualModeOn() {\n      return \"virtual\" === this.option(\"scrolling.mode\");\n    }\n  }, {\n    key: \"isVirtualScrolling\",\n    value: function isVirtualScrolling() {\n      return this.isRenovatedRender() && this._isVirtualModeOn();\n    }\n  }, {\n    key: \"_initVirtualScrolling\",\n    value: function _initVirtualScrolling() {\n      if (this.virtualScrollingDispatcher) {\n        this.virtualScrollingDispatcher.dispose();\n        this.virtualScrollingDispatcher = null;\n      }\n\n      if (this.isVirtualScrolling()) {\n        this.virtualScrollingDispatcher = new VirtualScrollingDispatcher(this);\n      }\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_render\", this).call(this);\n\n      this._renderDateTimeIndication();\n\n      this._setIndicationUpdateInterval();\n    }\n  }, {\n    key: \"_toggleGroupedClass\",\n    value: function _toggleGroupedClass() {\n      this.$element().toggleClass(GROUPED_WORKSPACE_CLASS, this._getGroupCount() > 0);\n    }\n  }, {\n    key: \"_toggleFixedScrollableClass\",\n    value: function _toggleFixedScrollableClass() {\n      return noop();\n    }\n  }, {\n    key: \"_renderView\",\n    value: function _renderView() {\n      this._setFirstViewDate();\n\n      if (this.isRenovatedRender()) {\n        if (this._isVerticalGroupedWorkSpace()) {\n          this.renderRGroupPanel();\n        }\n      } else {\n        this._applyCellTemplates(this._renderGroupHeader());\n      }\n\n      if (this.isRenovatedRender()) {\n        this.renderRWorkspace();\n      } else {\n        this._renderDateHeader();\n\n        this._renderTimePanel();\n\n        this._renderGroupAllDayPanel();\n\n        this._renderDateTable();\n\n        this._renderAllDayPanel();\n      }\n\n      this._updateGroupTableHeight();\n\n      this._shader = new VerticalShader(this);\n    }\n  }, {\n    key: \"onDataSourceChanged\",\n    value: function onDataSourceChanged() {}\n  }, {\n    key: \"preRenderAppointments\",\n    value: function preRenderAppointments(options) {\n      this.option(\"allDayExpanded\", options.allDayExpanded);\n    }\n  }, {\n    key: \"isGroupedAllDayPanel\",\n    value: function isGroupedAllDayPanel() {\n      return this._isShowAllDayPanel() && this._isVerticalGroupedWorkSpace();\n    }\n  }, {\n    key: \"generateRenderOptions\",\n    value: function generateRenderOptions(isProvideVirtualCellsWidth) {\n      var _this$_getToday;\n\n      var groupCount = this._getGroupCount();\n\n      var verticalGroupCount = !this._isVerticalGroupedWorkSpace() ? 1 : groupCount;\n      var horizontalGroupCount = this._isVerticalGroupedWorkSpace() ? 1 : groupCount;\n      var allDayElements = this._insertAllDayRowsIntoDateTable() ? this._allDayTitles : void 0;\n\n      var rowCountInGroup = this._getRowCount();\n\n      var cellCount = this._getTotalCellCount(groupCount);\n\n      var rowCount = this._getTotalRowCount(groupCount, this._isVerticalGroupedWorkSpace());\n\n      var groupOrientation = groupCount > 0 ? this.option(\"groupOrientation\") : this._getDefaultGroupStrategy();\n      var options = {\n        horizontalGroupCount: horizontalGroupCount,\n        verticalGroupCount: verticalGroupCount,\n        rowCountInGroup: rowCountInGroup,\n        cellCount: cellCount,\n        cellCountInGroupRow: this._getCellCount(),\n        cellDataGetters: [this._getCellData.bind(this)],\n        allDayElements: allDayElements,\n        startRowIndex: 0,\n        startCellIndex: 0,\n        groupOrientation: groupOrientation,\n        rowCount: rowCount,\n        totalRowCount: rowCount,\n        totalCellCount: cellCount,\n        groupCount: groupCount,\n        getDateHeaderText: this._getHeaderText.bind(this),\n        getDateHeaderDate: this._getDateByIndex.bind(this),\n        getTimeCellDate: this._getTimeCellDate.bind(this),\n        today: null === (_this$_getToday = this._getToday) || void 0 === _this$_getToday ? void 0 : _this$_getToday.call(this),\n        groupByDate: this.isGroupedByDate(),\n        groupsList: this._getAllGroups(),\n        isHorizontalGrouping: this._isHorizontalGroupedWorkSpace(),\n        isVerticalGrouping: this._isVerticalGroupedWorkSpace(),\n        isProvideVirtualCellsWidth: isProvideVirtualCellsWidth\n      };\n\n      if (this.isVirtualScrolling()) {\n        extend(options, this.virtualScrollingDispatcher.getRenderState());\n      }\n\n      return options;\n    }\n  }, {\n    key: \"renovatedRenderSupported\",\n    value: function renovatedRenderSupported() {\n      return false;\n    }\n  }, {\n    key: \"renderRWorkspace\",\n    value: function renderRWorkspace() {\n      var _this$virtualScrollin3;\n\n      var isGenerateNewViewData = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;\n\n      this._cleanAllowedPositions();\n\n      this.viewDataProvider.update(isGenerateNewViewData);\n      this.renderRHeaderPanel();\n      this.renderRTimeTable();\n      this.renderRDateTable();\n      this.renderRAllDayPanel();\n      this.updateRSelection();\n      null === (_this$virtualScrollin3 = this.virtualScrollingDispatcher) || void 0 === _this$virtualScrollin3 ? void 0 : _this$virtualScrollin3.updateDimensions();\n    }\n  }, {\n    key: \"renderRDateTable\",\n    value: function renderRDateTable() {\n      this.renderRComponent(this._$dateTable, dxrDateTableLayout, \"renovatedDateTable\", this._getRDateTableProps());\n    }\n  }, {\n    key: \"renderRGroupPanel\",\n    value: function renderRGroupPanel() {\n      var options = {\n        groups: this.option(\"groups\"),\n        groupOrientation: this.option(\"groupOrientation\"),\n        groupByDate: this.isGroupedByDate(),\n        resourceCellTemplate: this.option(\"resourceCellTemplate\"),\n        className: this.verticalGroupTableClass,\n        baseColSpan: this.isGroupedByDate() ? 1 : this._getCellCount(),\n        columnCountPerGroup: this._getCellCount()\n      };\n\n      if (this.option(\"groups\").length) {\n        this._attachGroupCountAttr();\n\n        this.renderRComponent(this._getGroupHeaderContainer(), dxrGroupPanel, \"renovatedGroupPanel\", options);\n      } else {\n        this._detachGroupCountAttr();\n      }\n    }\n  }, {\n    key: \"renderRAllDayPanel\",\n    value: function renderRAllDayPanel() {\n      var visible = this._isShowAllDayPanel() && !this.isGroupedAllDayPanel();\n\n      if (this.supportAllDayRow() && !this._isVerticalGroupedWorkSpace()) {\n        this._toggleAllDayVisibility(false);\n\n        var groupCount = this._getGroupCount();\n\n        var cellCount = this._getTotalCellCount(groupCount);\n\n        var options = {\n          viewData: this.viewDataProvider.viewData,\n          visible: visible,\n          dataCellTemplate: this.option(\"dataCellTemplate\"),\n          startCellIndex: 0,\n          cellCount: cellCount\n        };\n\n        if (this.isVirtualScrolling()) {\n          var horizontalVirtualScrolling = this.virtualScrollingDispatcher.horizontalVirtualScrolling;\n          var renderState = null === horizontalVirtualScrolling || void 0 === horizontalVirtualScrolling ? void 0 : horizontalVirtualScrolling.getRenderState();\n          extend(options, _extends({}, renderState));\n        }\n\n        this.renderRComponent(this._$allDayPanel, dxrAllDayPanelLayout, \"renovatedAllDayPanel\", options);\n        this.renderRComponent(this._$allDayTitle, dxrAllDayPanelTitle, \"renovatedAllDayPanelTitle\", {\n          visible: visible\n        });\n        this._$allDayTable = this.renovatedAllDayPanel.$element().find(\".\".concat(ALL_DAY_TABLE_CLASS));\n      }\n\n      this._toggleAllDayVisibility(true);\n    }\n  }, {\n    key: \"renderRTimeTable\",\n    value: function renderRTimeTable() {\n      this.renderRComponent(this._$timePanel, dxrTimePanelTableLayout, \"renovatedTimePanel\", {\n        timePanelData: this.viewDataProvider.timePanelData,\n        timeCellTemplate: this.option(\"timeCellTemplate\"),\n        groupOrientation: this.option(\"groupOrientation\")\n      });\n    }\n  }, {\n    key: \"renderRHeaderPanel\",\n    value: function renderRHeaderPanel() {\n      var isRenderDateHeader = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;\n\n      if (this.option(\"groups\").length) {\n        this._attachGroupCountAttr();\n      } else {\n        this._detachGroupCountAttr();\n      }\n\n      this.renderRComponent(this._$thead, this.renovatedHeaderPanelComponent, \"renovatedHeaderPanel\", {\n        dateHeaderData: this.viewDataProvider.dateHeaderData,\n        dateCellTemplate: this.option(\"dateCellTemplate\"),\n        timeCellTemplate: this.option(\"timeCellTemplate\"),\n        groups: this.option(\"groups\"),\n        groupByDate: this.isGroupedByDate(),\n        groupOrientation: this.option(\"groupOrientation\"),\n        resourceCellTemplate: this.option(\"resourceCellTemplate\"),\n        className: this.verticalGroupTableClass,\n        groupPanelCellBaseColSpan: this.isGroupedByDate() ? 1 : this._getCellCount(),\n        columnCountPerGroup: this._getCellCount(),\n        isRenderDateHeader: isRenderDateHeader\n      });\n    }\n  }, {\n    key: \"renderRComponent\",\n    value: function renderRComponent(parentElement, componentClass, componentName, viewModel) {\n      var component = this[componentName];\n\n      if (!component) {\n        var container = getPublicElement(parentElement);\n        component = this._createComponent(container, componentClass, _extends({}, viewModel, {\n          groupOrientation: this.option(\"groupOrientation\")\n        }));\n        this[componentName] = component;\n      } else {\n        component.option(viewModel);\n      }\n    }\n  }, {\n    key: \"updateRSelection\",\n    value: function updateRSelection() {\n      var isVerticalGrouping = this._isVerticalGroupedWorkSpace();\n\n      var focusedCell = this.virtualSelectionState.getFocusedCell();\n      var selectedCells = this.virtualSelectionState.getSelectedCells();\n\n      if (null !== focusedCell && void 0 !== focusedCell && focusedCell.coordinates) {\n        var coordinates = focusedCell.coordinates,\n            cellData = focusedCell.cellData;\n        var $cell = !isVerticalGrouping && cellData.allDay ? this._dom_getAllDayPanelCell(coordinates.cellIndex) : this._dom_getDateCell(coordinates);\n        $cell && this._setFocusedCell($cell);\n      }\n\n      selectedCells && this._setSelectedCellsByCellData(selectedCells);\n    }\n  }, {\n    key: \"_updateGroupTableHeight\",\n    value: function _updateGroupTableHeight() {\n      if (this._isVerticalGroupedWorkSpace() && hasWindow()) {\n        this._setHorizontalGroupHeaderCellsHeight();\n      }\n    }\n  }, {\n    key: \"_renderDateTimeIndication\",\n    value: function _renderDateTimeIndication() {\n      return noop();\n    }\n  }, {\n    key: \"_setIndicationUpdateInterval\",\n    value: function _setIndicationUpdateInterval() {\n      return noop();\n    }\n  }, {\n    key: \"_refreshDateTimeIndication\",\n    value: function _refreshDateTimeIndication() {\n      return noop();\n    }\n  }, {\n    key: \"_setFocusOnCellByOption\",\n    value: function _setFocusOnCellByOption(data) {\n      this._releaseSelectedAndFocusedCells();\n\n      this._setSelectedCellsByCellData(data);\n    }\n  }, {\n    key: \"_setSelectedCellsByCellData\",\n    value: function _setSelectedCellsByCellData(data) {\n      var _this4 = this;\n\n      var _data$;\n\n      var cells = [];\n\n      var $cells = this._getAllCells(null === data || void 0 === data ? void 0 : null === (_data$ = data[0]) || void 0 === _data$ ? void 0 : _data$.allDay);\n\n      var cellsInRow = this._getTotalCellCount(this._getGroupCount());\n\n      if (this.isVirtualScrolling()) {\n        var renderState = this.virtualScrollingDispatcher.getRenderState();\n        cellsInRow = renderState.cellCount || cellsInRow;\n      }\n\n      data.forEach(function (cellData) {\n        var groups = cellData.groups,\n            startDate = cellData.startDate,\n            allDay = cellData.allDay,\n            index = cellData.index;\n        var groupIndex = cellData.groupIndex;\n\n        if (!groupIndex) {\n          groupIndex = _this4._isGroupsSpecified(groups) ? _this4._getGroupIndexByResourceId(groups) : 0;\n        }\n\n        var coordinates = _this4.isVirtualScrolling() ? _this4.viewDataProvider.findCellPositionInMap({\n          groupIndex: groupIndex,\n          startDate: startDate,\n          isAllDay: allDay,\n          index: index\n        }) : _this4.getCoordinatesByDate(startDate, groupIndex, allDay);\n\n        if (coordinates) {\n          var rowIndex = coordinates.rowIndex,\n              cellIndex = coordinates.cellIndex;\n\n          var _index = rowIndex * cellsInRow + cellIndex;\n\n          var $cell = $cells[_index];\n\n          if (isDefined($cell)) {\n            _this4._toggleFocusClass(true, $($cell));\n\n            cells.push($cell);\n          }\n        }\n      });\n      this._selectedCells = cells;\n    }\n  }, {\n    key: \"_isGroupsSpecified\",\n    value: function _isGroupsSpecified(resources) {\n      return this.option(\"groups\").length && resources;\n    }\n  }, {\n    key: \"_getGroupIndexByResourceId\",\n    value: function _getGroupIndexByResourceId(id) {\n      var groups = this.option(\"groups\");\n      var resourceTree = this.invoke(\"createResourcesTree\", groups);\n\n      if (!resourceTree.length) {\n        return 0;\n      }\n\n      return this._getGroupIndexRecursively(resourceTree, id);\n    }\n  }, {\n    key: \"_getGroupIndexRecursively\",\n    value: function _getGroupIndexRecursively(resourceTree, id) {\n      var _this5 = this;\n\n      var currentKey = resourceTree[0].name;\n      var currentValue = id[currentKey];\n      return resourceTree.reduce(function (prevIndex, _ref2) {\n        var leafIndex = _ref2.leafIndex,\n            value = _ref2.value,\n            children = _ref2.children;\n        var areValuesEqual = currentValue === value;\n\n        if (areValuesEqual && void 0 !== leafIndex) {\n          return leafIndex;\n        }\n\n        if (areValuesEqual) {\n          return _this5._getGroupIndexRecursively(children, id);\n        }\n\n        return prevIndex;\n      }, 0);\n    }\n  }, {\n    key: \"_getCalculatedFirstDayOfWeek\",\n    value: function _getCalculatedFirstDayOfWeek() {\n      var firstDayOfWeekOption = this._firstDayOfWeek();\n\n      var firstDayOfWeek = isDefined(firstDayOfWeekOption) ? firstDayOfWeekOption : dateLocalization.firstDayOfWeekIndex();\n      return firstDayOfWeek;\n    }\n  }, {\n    key: \"_setFirstViewDate\",\n    value: function _setFirstViewDate() {\n      var firstDayOfWeek = this._getCalculatedFirstDayOfWeek();\n\n      this._firstViewDate = dateUtils.getFirstWeekDate(this._getViewStartByOptions(), firstDayOfWeek);\n\n      this._setStartDayHour(this._firstViewDate);\n    }\n  }, {\n    key: \"_getViewStartByOptions\",\n    value: function _getViewStartByOptions() {\n      if (!this.option(\"startDate\")) {\n        return this.option(\"currentDate\");\n      } else {\n        var startDate = dateUtils.trimTime(this._getStartViewDate());\n        var currentDate = this.option(\"currentDate\");\n        var diff = startDate.getTime() <= currentDate.getTime() ? 1 : -1;\n        var endDate = new Date(startDate.getTime() + this._getIntervalDuration() * diff);\n\n        while (!this._dateInRange(currentDate, startDate, endDate, diff)) {\n          startDate = endDate;\n          endDate = new Date(startDate.getTime() + this._getIntervalDuration() * diff);\n        }\n\n        return diff > 0 ? startDate : endDate;\n      }\n    }\n  }, {\n    key: \"_getHeaderDate\",\n    value: function _getHeaderDate() {\n      return this.getStartViewDate();\n    }\n  }, {\n    key: \"_getStartViewDate\",\n    value: function _getStartViewDate() {\n      return this.option(\"startDate\");\n    }\n  }, {\n    key: \"_dateInRange\",\n    value: function _dateInRange(date, startDate, endDate, diff) {\n      return diff > 0 ? dateUtils.dateInRange(date, startDate, new Date(endDate.getTime() - 1)) : dateUtils.dateInRange(date, endDate, startDate, \"date\");\n    }\n  }, {\n    key: \"_getIntervalDuration\",\n    value: function _getIntervalDuration() {\n      return toMs(\"day\") * this.option(\"intervalCount\");\n    }\n  }, {\n    key: \"_setStartDayHour\",\n    value: function _setStartDayHour(date) {\n      var startDayHour = this.option(\"startDayHour\");\n\n      if (isDefined(startDayHour)) {\n        date.setHours(startDayHour, startDayHour % 1 * 60, 0, 0);\n      }\n    }\n  }, {\n    key: \"_firstDayOfWeek\",\n    value: function _firstDayOfWeek() {\n      return this.option(\"firstDayOfWeek\");\n    }\n  }, {\n    key: \"_attachEvents\",\n    value: function _attachEvents() {\n      this._createSelectionChangedAction();\n\n      this._attachClickEvent();\n\n      this._attachContextMenuEvent();\n    }\n  }, {\n    key: \"_attachClickEvent\",\n    value: function _attachClickEvent() {\n      var that = this;\n\n      var pointerDownAction = this._createAction(function (e) {\n        that._pointerDownHandler(e.event);\n      });\n\n      this._createCellClickAction();\n\n      var cellSelector = \".\" + DATE_TABLE_CELL_CLASS + \",.\" + ALL_DAY_TABLE_CELL_CLASS;\n      var $element = this.$element();\n      eventsEngine.off($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME);\n      eventsEngine.off($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME);\n      eventsEngine.on($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME, function (e) {\n        if (isMouseEvent(e) && e.which > 1) {\n          e.preventDefault();\n          return;\n        }\n\n        pointerDownAction({\n          event: e\n        });\n      });\n      eventsEngine.on($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME, cellSelector, function (e) {\n        var $cell = $(e.target);\n\n        that._cellClickAction({\n          event: e,\n          cellElement: getPublicElement($cell),\n          cellData: that.getCellData($cell)\n        });\n      });\n    }\n  }, {\n    key: \"_createCellClickAction\",\n    value: function _createCellClickAction() {\n      var _this6 = this;\n\n      this._cellClickAction = this._createActionByOption(\"onCellClick\", {\n        afterExecute: function afterExecute(e) {\n          return _this6._cellClickHandler(e.args[0].event);\n        }\n      });\n    }\n  }, {\n    key: \"_createSelectionChangedAction\",\n    value: function _createSelectionChangedAction() {\n      this._selectionChangedAction = this._createActionByOption(\"onSelectionChanged\");\n    }\n  }, {\n    key: \"_cellClickHandler\",\n    value: function _cellClickHandler(e) {\n      var $target = $(e.target);\n\n      if (this._showPopup && this._hasFocusClass($target)) {\n        delete this._showPopup;\n\n        this._showAddAppointmentPopup($target);\n      }\n    }\n  }, {\n    key: \"_pointerDownHandler\",\n    value: function _pointerDownHandler(e) {\n      var $target = $(e.target);\n\n      if (!$target.hasClass(DATE_TABLE_CELL_CLASS) && !$target.hasClass(ALL_DAY_TABLE_CELL_CLASS)) {\n        this._isCellClick = false;\n        return;\n      }\n\n      this._isCellClick = true;\n\n      if ($target.hasClass(DATE_TABLE_FOCUSED_CELL_CLASS)) {\n        this._showPopup = true;\n      } else {\n        this._setSelectedAndFocusedCells($target);\n      }\n    }\n  }, {\n    key: \"_showAddAppointmentPopup\",\n    value: function _showAddAppointmentPopup($cell) {\n      var firstCellData = this.getCellData($cell.first());\n      var lastCellData = this.getCellData($cell.last());\n\n      if (this.isVirtualScrolling()) {\n        var selectedCells = this.virtualSelectionState.getSelectedCells();\n        firstCellData = selectedCells[0];\n        lastCellData = selectedCells[selectedCells.length - 1];\n      }\n\n      var result = {\n        startDate: firstCellData.startDate,\n        endDate: lastCellData.endDate\n      };\n\n      if (void 0 !== lastCellData.allDay) {\n        result.allDay = lastCellData.allDay;\n      }\n\n      this.invoke(\"showAddAppointmentPopup\", result, lastCellData.groups);\n    }\n  }, {\n    key: \"_attachContextMenuEvent\",\n    value: function _attachContextMenuEvent() {\n      this._createContextMenuAction();\n\n      var cellSelector = \".\" + DATE_TABLE_CELL_CLASS + \",.\" + ALL_DAY_TABLE_CELL_CLASS;\n      var $element = this.$element();\n      var eventName = addNamespace(contextMenuEventName, this.NAME);\n      eventsEngine.off($element, eventName, cellSelector);\n      eventsEngine.on($element, eventName, cellSelector, this._contextMenuHandler.bind(this));\n    }\n  }, {\n    key: \"_contextMenuHandler\",\n    value: function _contextMenuHandler(e) {\n      var $cell = $(e.target);\n\n      this._contextMenuAction({\n        event: e,\n        cellElement: getPublicElement($cell),\n        cellData: this.getCellData($cell)\n      });\n\n      this._contextMenuHandled = true;\n    }\n  }, {\n    key: \"_createContextMenuAction\",\n    value: function _createContextMenuAction() {\n      this._contextMenuAction = this._createActionByOption(\"onCellContextMenu\");\n    }\n  }, {\n    key: \"_getGroupHeaderContainer\",\n    value: function _getGroupHeaderContainer() {\n      if (this._isVerticalGroupedWorkSpace()) {\n        return this._$groupTable;\n      }\n\n      return this._$thead;\n    }\n  }, {\n    key: \"_getDateHeaderContainer\",\n    value: function _getDateHeaderContainer() {\n      return this._$thead;\n    }\n  }, {\n    key: \"_renderGroupHeader\",\n    value: function _renderGroupHeader() {\n      var $container = this._getGroupHeaderContainer();\n\n      var groupCount = this._getGroupCount();\n\n      var cellTemplates = [];\n\n      if (groupCount) {\n        var groupRows = this._makeGroupRows(this.option(\"groups\"), this.option(\"groupByDate\"));\n\n        this._attachGroupCountAttr();\n\n        $container.append(groupRows.elements);\n        cellTemplates = groupRows.cellTemplates;\n      } else {\n        this._detachGroupCountAttr();\n      }\n\n      return cellTemplates;\n    }\n  }, {\n    key: \"_applyCellTemplates\",\n    value: function _applyCellTemplates(templates) {\n      null === templates || void 0 === templates ? void 0 : templates.forEach(function (template) {\n        template();\n      });\n    }\n  }, {\n    key: \"_detachGroupCountAttr\",\n    value: function _detachGroupCountAttr() {\n      var groupedAttr = this._groupedStrategy.getGroupCountAttr();\n\n      this.$element().removeAttr(groupedAttr.attr);\n    }\n  }, {\n    key: \"_attachGroupCountAttr\",\n    value: function _attachGroupCountAttr() {\n      var groupedAttr = this._groupedStrategy.getGroupCountAttr(this.option(\"groups\"));\n\n      this.$element().attr(groupedAttr.attr, groupedAttr.count);\n    }\n  }, {\n    key: \"headerPanelOffsetRecalculate\",\n    value: function headerPanelOffsetRecalculate() {\n      if (!this.option(\"resourceCellTemplate\") && !this.option(\"dateCellTemplate\")) {\n        return;\n      }\n\n      var headerPanelHeight = this.getHeaderPanelHeight();\n      var headerHeight = this.invoke(\"getHeaderHeight\");\n      var allDayPanelHeight = this.isAllDayPanelVisible ? this._groupedStrategy.getAllDayTableHeight() : 0;\n      headerPanelHeight && this._headerScrollable && this._headerScrollable.$element().height(headerPanelHeight + allDayPanelHeight);\n      headerPanelHeight && this._dateTableScrollable.$element().css({\n        paddingBottom: allDayPanelHeight + headerPanelHeight + \"px\",\n        marginBottom: -1 * (parseInt(headerPanelHeight, 10) + allDayPanelHeight) + \"px\"\n      });\n      headerPanelHeight && this._sidebarScrollable && this._sidebarScrollable.$element().css({\n        paddingBottom: allDayPanelHeight + headerPanelHeight + \"px\",\n        marginBottom: -1 * (parseInt(headerPanelHeight, 10) + allDayPanelHeight) + \"px\"\n      });\n      this._$allDayTitle && this._$allDayTitle.css(\"top\", headerHeight + headerPanelHeight + \"px\");\n    }\n  }, {\n    key: \"_makeGroupRows\",\n    value: function _makeGroupRows(groups, groupByDate) {\n      var tableCreatorStrategy = this._isVerticalGroupedWorkSpace() ? tableCreator.VERTICAL : tableCreator.HORIZONTAL;\n      return tableCreator.makeGroupedTable(tableCreatorStrategy, groups, {\n        groupHeaderRowClass: this._getGroupRowClass(),\n        groupRowClass: this._getGroupRowClass(),\n        groupHeaderClass: this._getGroupHeaderClass.bind(this),\n        groupHeaderContentClass: this._getGroupHeaderContentClass()\n      }, this._getCellCount() || 1, this.option(\"resourceCellTemplate\"), this._getGroupCount(), groupByDate);\n    }\n  }, {\n    key: \"_getDateHeaderTemplate\",\n    value: function _getDateHeaderTemplate() {\n      return this.option(\"dateCellTemplate\");\n    }\n  }, {\n    key: \"_renderDateHeader\",\n    value: function _renderDateHeader() {\n      var container = this._getDateHeaderContainer();\n\n      var $headerRow = $(\"<tr>\").addClass(HEADER_ROW_CLASS);\n\n      var count = this._getCellCount();\n\n      var cellTemplate = this._getDateHeaderTemplate();\n\n      var repeatCount = this._getCalculateHeaderCellRepeatCount();\n\n      var templateCallbacks = [];\n      var groupByDate = this.isGroupedByDate();\n\n      if (!groupByDate) {\n        for (var rowIndex = 0; rowIndex < repeatCount; rowIndex++) {\n          for (var cellIndex = 0; cellIndex < count; cellIndex++) {\n            var templateIndex = rowIndex * count + cellIndex;\n\n            this._renderDateHeaderTemplate($headerRow, cellIndex, templateIndex, cellTemplate, templateCallbacks);\n          }\n        }\n\n        container.append($headerRow);\n      } else {\n        var colSpan = groupByDate ? this._getGroupCount() : 1;\n\n        for (var _cellIndex = 0; _cellIndex < count; _cellIndex++) {\n          var _templateIndex = _cellIndex * repeatCount;\n\n          var cellElement = this._renderDateHeaderTemplate($headerRow, _cellIndex, _templateIndex, cellTemplate, templateCallbacks);\n\n          cellElement.attr(\"colSpan\", colSpan);\n        }\n\n        container.prepend($headerRow);\n      }\n\n      this._applyCellTemplates(templateCallbacks);\n\n      return $headerRow;\n    }\n  }, {\n    key: \"_renderDateHeaderTemplate\",\n    value: function _renderDateHeaderTemplate(container, panelCellIndex, templateIndex, cellTemplate, templateCallbacks) {\n      var text = this._getHeaderText(panelCellIndex);\n\n      var $cell = $(\"<th>\").addClass(this._getHeaderPanelCellClass(panelCellIndex)).attr(\"title\", text);\n\n      if (null !== cellTemplate && void 0 !== cellTemplate && cellTemplate.render) {\n        templateCallbacks.push(cellTemplate.render.bind(cellTemplate, {\n          model: _extends({\n            text: text,\n            date: this._getDateByIndex(panelCellIndex)\n          }, this._getGroupsForDateHeaderTemplate(templateIndex)),\n          index: templateIndex,\n          container: getPublicElement($cell)\n        }));\n      } else {\n        $cell.text(text);\n      }\n\n      container.append($cell);\n      return $cell;\n    }\n  }, {\n    key: \"_getGroupsForDateHeaderTemplate\",\n    value: function _getGroupsForDateHeaderTemplate(templateIndex) {\n      var indexMultiplier = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n      var groupIndex;\n      var groups;\n\n      if (this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate()) {\n        groupIndex = this._getGroupIndex(0, templateIndex * indexMultiplier);\n\n        var groupsArray = this._getCellGroups(groupIndex);\n\n        groups = this._getGroupsObjectFromGroupsArray(groupsArray);\n      }\n\n      return {\n        groups: groups,\n        groupIndex: groupIndex\n      };\n    }\n  }, {\n    key: \"_getHeaderPanelCellClass\",\n    value: function _getHeaderPanelCellClass(i) {\n      var cellClass = HEADER_PANEL_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS;\n      return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1, void 0, void 0, this.isGroupedByDate());\n    }\n  }, {\n    key: \"_getCalculateHeaderCellRepeatCount\",\n    value: function _getCalculateHeaderCellRepeatCount() {\n      return this._groupedStrategy.calculateHeaderCellRepeatCount();\n    }\n  }, {\n    key: \"_renderAllDayPanel\",\n    value: function _renderAllDayPanel(index) {\n      var cellCount = this._getCellCount();\n\n      if (!this._isVerticalGroupedWorkSpace()) {\n        cellCount *= this._getGroupCount() || 1;\n      }\n\n      var cellTemplates = this._renderTableBody({\n        container: this._allDayPanels.length ? getPublicElement(this._allDayTables[index]) : getPublicElement(this._$allDayTable),\n        rowCount: 1,\n        cellCount: cellCount,\n        cellClass: this._getAllDayPanelCellClass.bind(this),\n        rowClass: ALL_DAY_TABLE_ROW_CLASS,\n        cellTemplate: this.option(\"dataCellTemplate\"),\n        getCellData: this._getAllDayCellData.bind(this),\n        groupIndex: index\n      }, true);\n\n      this._toggleAllDayVisibility(true);\n\n      this._applyCellTemplates(cellTemplates);\n    }\n  }, {\n    key: \"_renderGroupAllDayPanel\",\n    value: function _renderGroupAllDayPanel() {\n      if (this._isVerticalGroupedWorkSpace()) {\n        var groupCount = this._getGroupCount();\n\n        for (var i = 0; i < groupCount; i++) {\n          this._renderAllDayPanel(i);\n        }\n      }\n    }\n  }, {\n    key: \"_getAllDayPanelCellClass\",\n    value: function _getAllDayPanelCellClass(i, j) {\n      var cellClass = ALL_DAY_TABLE_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS;\n      return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, j + 1);\n    }\n  }, {\n    key: \"_getAllDayCellData\",\n    value: function _getAllDayCellData(cell, rowIndex, cellIndex, groupIndex) {\n      var startDate = this._getDateByCellIndexes(rowIndex, cellIndex);\n\n      var cellGroupIndex = groupIndex || this._getGroupIndex(rowIndex, cellIndex);\n\n      startDate = dateUtils.trimTime(startDate);\n      var data = {\n        startDate: startDate,\n        endDate: startDate,\n        allDay: true,\n        groupIndex: cellGroupIndex\n      };\n\n      var groupsArray = this._getCellGroups(cellGroupIndex);\n\n      if (groupsArray.length) {\n        data.groups = this._getGroupsObjectFromGroupsArray(groupsArray);\n      }\n\n      return {\n        key: CELL_DATA,\n        value: data\n      };\n    }\n  }, {\n    key: \"_toggleAllDayVisibility\",\n    value: function _toggleAllDayVisibility(isUpdateScrollable) {\n      var showAllDayPanel = this._isShowAllDayPanel();\n\n      this._$allDayPanel.toggle(showAllDayPanel);\n\n      this._$allDayTitle && this._$allDayTitle.toggleClass(ALL_DAY_TITLE_HIDDEN_CLASS, !showAllDayPanel);\n      this.$element().toggleClass(WORKSPACE_WITH_ALL_DAY_CLASS, showAllDayPanel);\n\n      this._changeAllDayVisibility();\n\n      isUpdateScrollable && this._updateScrollable();\n    }\n  }, {\n    key: \"_changeAllDayVisibility\",\n    value: function _changeAllDayVisibility() {\n      this.$element().toggleClass(WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS, !this.option(\"allDayExpanded\") && this._isShowAllDayPanel());\n    }\n  }, {\n    key: \"_updateScrollable\",\n    value: function _updateScrollable() {\n      this._dateTableScrollable.update();\n\n      this._headerScrollable && this._headerScrollable.update();\n      this._sidebarScrollable && this._sidebarScrollable.update();\n    }\n  }, {\n    key: \"_renderTimePanel\",\n    value: function _renderTimePanel() {\n      var _this7 = this;\n\n      var repeatCount = this._groupedStrategy.calculateTimeCellRepeatCount();\n\n      var startViewDate = timeZoneUtils.getDateWithoutTimezoneChange(this.getStartViewDate());\n\n      this._renderTableBody({\n        container: getPublicElement(this._$timePanel),\n        rowCount: this._getTimePanelRowCount() * repeatCount,\n        cellCount: 1,\n        cellClass: this._getTimeCellClass.bind(this),\n        rowClass: TIME_PANEL_ROW_CLASS,\n        cellTemplate: this.option(\"timeCellTemplate\"),\n        getCellText: function (i) {\n          var index = i % _this7._getRowCount();\n\n          if (index % 2 === 0) {\n            return dateLocalization.format(_this7._getTimeCellDateCore(startViewDate, i), \"shorttime\");\n          }\n\n          return \"\";\n        }.bind(this),\n        getCellDate: this._getTimeCellDate.bind(this),\n        groupCount: this._getGroupCount(),\n        allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayTitles : void 0,\n        getTemplateData: function (rowIndex) {\n          if (!_this7._isVerticalGroupedWorkSpace()) {\n            return {};\n          }\n\n          var groupIndex = _this7._getGroupIndex(rowIndex, 0);\n\n          var groupsArray = _this7._getCellGroups(groupIndex);\n\n          var groups = _this7._getGroupsObjectFromGroupsArray(groupsArray);\n\n          return {\n            groupIndex: groupIndex,\n            groups: groups\n          };\n        }.bind(this)\n      });\n    }\n  }, {\n    key: \"_getTimePanelRowCount\",\n    value: function _getTimePanelRowCount() {\n      return this._getCellCountInDay();\n    }\n  }, {\n    key: \"_getCellCountInDay\",\n    value: function _getCellCountInDay(skipRound) {\n      var result = this._calculateDayDuration() / this.option(\"hoursInterval\");\n      return skipRound ? result : Math.ceil(result);\n    }\n  }, {\n    key: \"_calculateDayDuration\",\n    value: function _calculateDayDuration() {\n      return this.option(\"endDayHour\") - this.option(\"startDayHour\");\n    }\n  }, {\n    key: \"_getTimeCellClass\",\n    value: function _getTimeCellClass(i) {\n      var cellClass = TIME_PANEL_CELL_CLASS + \" \" + VERTICAL_SIZES_CLASS;\n      return this._isVerticalGroupedWorkSpace() ? this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i, i) : cellClass;\n    }\n  }, {\n    key: \"_getTimeCellDate\",\n    value: function _getTimeCellDate(i) {\n      return this._getTimeCellDateCore(this.getStartViewDate(), i);\n    }\n  }, {\n    key: \"_getTimeCellDateCore\",\n    value: function _getTimeCellDateCore(startViewDate, i) {\n      var result = new Date(startViewDate);\n      var timeCellDuration = Math.round(this.getCellDuration());\n\n      var cellCountInDay = this._getCellCountInDay(true);\n\n      result.setMilliseconds(result.getMilliseconds() + timeCellDuration * (i % cellCountInDay) - this._getTimeOffsetForStartViewDate());\n      return result;\n    }\n  }, {\n    key: \"_renderDateTable\",\n    value: function _renderDateTable() {\n      var groupCount = this._getGroupCount();\n\n      this._renderTableBody({\n        container: getPublicElement(this._$dateTable),\n        rowCount: this._getTotalRowCount(groupCount),\n        cellCount: this._getTotalCellCount(groupCount),\n        cellClass: this._getDateTableCellClass.bind(this),\n        rowClass: this._getDateTableRowClass(),\n        cellTemplate: this.option(\"dataCellTemplate\"),\n        getCellData: this._getCellData.bind(this),\n        allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayPanels : void 0,\n        groupCount: groupCount,\n        groupByDate: this.option(\"groupByDate\")\n      });\n    }\n  }, {\n    key: \"_insertAllDayRowsIntoDateTable\",\n    value: function _insertAllDayRowsIntoDateTable() {\n      return this._groupedStrategy.insertAllDayRowsIntoDateTable();\n    }\n  }, {\n    key: \"_getTotalCellCount\",\n    value: function _getTotalCellCount(groupCount) {\n      return this._groupedStrategy.getTotalCellCount(groupCount);\n    }\n  }, {\n    key: \"_getTotalRowCount\",\n    value: function _getTotalRowCount(groupCount, includeAllDayPanelRows) {\n      var result = this._groupedStrategy.getTotalRowCount(groupCount);\n\n      if (includeAllDayPanelRows && groupCount > 1 && this.isAllDayPanelVisible) {\n        result += groupCount;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getCellData\",\n    value: function _getCellData(cell, rowIndex, cellIndex) {\n      var data = this._prepareCellData(rowIndex, cellIndex, cell);\n\n      return {\n        key: CELL_DATA,\n        value: data\n      };\n    }\n  }, {\n    key: \"_prepareCellData\",\n    value: function _prepareCellData(rowIndex, cellIndex) {\n      var startDate = this._getDateByCellIndexes(rowIndex, cellIndex);\n\n      var endDate = this.calculateEndDate(startDate);\n\n      var groupIndex = this._getGroupIndex(rowIndex, cellIndex);\n\n      var data = {\n        startDate: startDate,\n        endDate: endDate,\n        allDay: this._getTableAllDay(),\n        groupIndex: groupIndex\n      };\n\n      var groupsArray = this._getCellGroups(groupIndex);\n\n      if (groupsArray.length) {\n        data.groups = this._getGroupsObjectFromGroupsArray(groupsArray);\n      }\n\n      return data;\n    }\n  }, {\n    key: \"_getGroupIndex\",\n    value: function _getGroupIndex(rowIndex, cellIndex) {\n      return this._groupedStrategy.getGroupIndex(rowIndex, cellIndex);\n    }\n  }, {\n    key: \"_getTableAllDay\",\n    value: function _getTableAllDay() {\n      return false;\n    }\n  }, {\n    key: \"calculateEndDate\",\n    value: function calculateEndDate(startDate) {\n      var result = new Date(startDate);\n      result.setMilliseconds(result.getMilliseconds() + Math.round(this._getInterval()));\n      return result;\n    }\n  }, {\n    key: \"_getGroupCount\",\n    value: function _getGroupCount() {\n      var groups = this.option(\"groups\");\n      var result = 0;\n\n      for (var i = 0, len = groups.length; i < len; i++) {\n        if (!i) {\n          result = groups[i].items.length;\n        } else {\n          result *= groups[i].items.length;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getPathToLeaf\",\n    value: function _getPathToLeaf(leafIndex) {\n      var tree = this.invoke(\"createResourcesTree\", this.option(\"groups\"));\n\n      var leaf = function findLeafByIndex(data, index) {\n        for (var i = 0; i < data.length; i++) {\n          if (data[i].leafIndex === index) {\n            return data[i];\n          } else {\n            var _leaf = findLeafByIndex(data[i].children, index);\n\n            if (_leaf) {\n              return _leaf;\n            }\n          }\n        }\n      }(tree, leafIndex);\n\n      return function makeBranch(leaf, result) {\n        result = result || [];\n        result.push(leaf.value);\n\n        if (leaf.parent) {\n          makeBranch(leaf.parent, result);\n        }\n\n        return result;\n      }(leaf).reverse();\n    }\n  }, {\n    key: \"_getAllGroups\",\n    value: function _getAllGroups() {\n      var _this8 = this;\n\n      var groupCount = this._getGroupCount();\n\n      return _toConsumableArray(new Array(groupCount)).map(function (_, groupIndex) {\n        var groupsArray = _this8._getCellGroups(groupIndex);\n\n        return _this8._getGroupsObjectFromGroupsArray(groupsArray);\n      });\n    }\n  }, {\n    key: \"_getCellGroups\",\n    value: function _getCellGroups(groupIndex) {\n      var result = [];\n\n      if (this._getGroupCount()) {\n        var groups = this.option(\"groups\");\n\n        if (groupIndex < 0) {\n          return;\n        }\n\n        var path = this._getPathToLeaf(groupIndex);\n\n        for (var i = 0; i < groups.length; i++) {\n          result.push({\n            name: groups[i].name,\n            id: path[i]\n          });\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getGroupsObjectFromGroupsArray\",\n    value: function _getGroupsObjectFromGroupsArray(groupsArray) {\n      return groupsArray.reduce(function (currentGroups, _ref3) {\n        var name = _ref3.name,\n            id = _ref3.id;\n        return _extends({}, currentGroups, _defineProperty({}, name, id));\n      }, {});\n    }\n  }, {\n    key: \"_attachTablesEvents\",\n    value: function _attachTablesEvents() {\n      var element = this.$element();\n\n      this._attachDragEvents(element);\n\n      this._attachPointerEvents(element);\n    }\n  }, {\n    key: \"_detachDragEvents\",\n    value: function _detachDragEvents(element) {\n      eventsEngine.off(element, DragEventNames.ENTER);\n      eventsEngine.off(element, DragEventNames.LEAVE);\n      eventsEngine.off(element, DragEventNames.DROP);\n    }\n  }, {\n    key: \"_attachDragEvents\",\n    value: function _attachDragEvents(element) {\n      var _this9 = this;\n\n      this._detachDragEvents(element);\n\n      eventsEngine.on(element, DragEventNames.ENTER, DRAG_AND_DROP_SELECTOR, {\n        checkDropTarget: function checkDropTarget(target, event) {\n          return !_this9._isOutsideScrollable(target, event);\n        }\n      }, function (e) {\n        _this9.removeDroppableCellClass();\n\n        $(e.target).addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n      });\n      eventsEngine.on(element, DragEventNames.LEAVE, function () {\n        return _this9.removeDroppableCellClass();\n      });\n      eventsEngine.on(element, DragEventNames.DROP, DRAG_AND_DROP_SELECTOR, function () {\n        return _this9.removeDroppableCellClass();\n      });\n    }\n  }, {\n    key: \"_attachPointerEvents\",\n    value: function _attachPointerEvents(element) {\n      var _this10 = this;\n\n      var isPointerDown = false;\n      eventsEngine.off(element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME);\n      eventsEngine.off(element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME);\n      eventsEngine.on(element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME, DRAG_AND_DROP_SELECTOR, function (e) {\n        if (isMouseEvent(e) && 1 === e.which) {\n          isPointerDown = true;\n\n          _this10.$element().addClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);\n\n          eventsEngine.off(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);\n          eventsEngine.on(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME, function () {\n            isPointerDown = false;\n\n            _this10.$element().removeClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);\n          });\n        }\n      });\n      eventsEngine.on(element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME, DRAG_AND_DROP_SELECTOR, function (e) {\n        if (isPointerDown && _this10._dateTableScrollable && !_this10._dateTableScrollable.option(\"scrollByContent\")) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          _this10._moveToCell($(e.target), true);\n        }\n      });\n    }\n  }, {\n    key: \"_getDateTables\",\n    value: function _getDateTables() {\n      return this._$dateTable.add(this._$allDayTable);\n    }\n  }, {\n    key: \"_getDateTable\",\n    value: function _getDateTable() {\n      return this._$dateTable;\n    }\n  }, {\n    key: \"_getAllDayTable\",\n    value: function _getAllDayTable() {\n      return this._$allDayTable;\n    }\n  }, {\n    key: \"_getInterval\",\n    value: function _getInterval() {\n      if (void 0 === this._interval) {\n        this._interval = this.option(\"hoursInterval\") * HOUR_MS;\n      }\n\n      return this._interval;\n    }\n  }, {\n    key: \"_getHeaderText\",\n    value: function _getHeaderText(headerIndex) {\n      return dateLocalization.format(this._getDateForHeaderText(headerIndex), this._getFormat());\n    }\n  }, {\n    key: \"_getDateForHeaderText\",\n    value: function _getDateForHeaderText(index) {\n      return this._getDateByIndex(index);\n    }\n  }, {\n    key: \"_getDateByIndex\",\n    value: function _getDateByIndex() {\n      return abstract();\n    }\n  }, {\n    key: \"_getFormat\",\n    value: function _getFormat() {\n      return abstract();\n    }\n  }, {\n    key: \"_calculateCellIndex\",\n    value: function _calculateCellIndex(rowIndex, cellIndex) {\n      return this._groupedStrategy.calculateCellIndex(rowIndex, cellIndex);\n    }\n  }, {\n    key: \"_renderTableBody\",\n    value: function _renderTableBody(options, delayCellTemplateRendering) {\n      var result = [];\n\n      if (!delayCellTemplateRendering) {\n        this._applyCellTemplates(tableCreator.makeTable(options));\n      } else {\n        result = tableCreator.makeTable(options);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_removeAllDayElements\",\n    value: function _removeAllDayElements() {\n      this._$allDayTable && this._$allDayTable.remove();\n      this._$allDayTitle && this._$allDayTitle.remove();\n    }\n  }, {\n    key: \"_cleanView\",\n    value: function _cleanView() {\n      var _this$virtualSelectio2, _this$_shader;\n\n      this.cache.clear();\n\n      this._cleanTableWidths();\n\n      this._cleanAllowedPositions();\n\n      null === (_this$virtualSelectio2 = this.virtualSelectionState) || void 0 === _this$virtualSelectio2 ? void 0 : _this$virtualSelectio2.releaseSelectedAndFocusedCells();\n\n      if (!this.isRenovatedRender()) {\n        var _this$_$allDayTable, _this$_$sidebarTable;\n\n        this._$thead.empty();\n\n        this._$dateTable.empty();\n\n        this._$timePanel.empty();\n\n        this._$groupTable.empty();\n\n        null === (_this$_$allDayTable = this._$allDayTable) || void 0 === _this$_$allDayTable ? void 0 : _this$_$allDayTable.empty();\n        null === (_this$_$sidebarTable = this._$sidebarTable) || void 0 === _this$_$sidebarTable ? void 0 : _this$_$sidebarTable.empty();\n      }\n\n      null === (_this$_shader = this._shader) || void 0 === _this$_shader ? void 0 : _this$_shader.clean();\n      delete this._hiddenInterval;\n      delete this._interval;\n    }\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      eventsEngine.off(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);\n\n      this._disposeRenovatedComponents();\n\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_clean\", this).call(this);\n    }\n  }, {\n    key: \"_cleanTableWidths\",\n    value: function _cleanTableWidths() {\n      this._$headerPanel.css(\"width\", \"\");\n\n      this._$dateTable.css(\"width\", \"\");\n\n      this._$allDayTable && this._$allDayTable.css(\"width\", \"\");\n    }\n  }, {\n    key: \"_disposeRenovatedComponents\",\n    value: function _disposeRenovatedComponents() {\n      var _this$renovatedAllDay, _this$renovatedDateTa, _this$renovatedTimePa, _this$renovatedGroupP, _this$renovatedHeader;\n\n      null === (_this$renovatedAllDay = this.renovatedAllDayPanel) || void 0 === _this$renovatedAllDay ? void 0 : _this$renovatedAllDay.dispose();\n      this.renovatedAllDayPanel = void 0;\n      null === (_this$renovatedDateTa = this.renovatedDateTable) || void 0 === _this$renovatedDateTa ? void 0 : _this$renovatedDateTa.dispose();\n      this.renovatedDateTable = void 0;\n      null === (_this$renovatedTimePa = this.renovatedTimePanel) || void 0 === _this$renovatedTimePa ? void 0 : _this$renovatedTimePa.dispose();\n      this.renovatedTimePanel = void 0;\n      null === (_this$renovatedGroupP = this.renovatedGroupPanel) || void 0 === _this$renovatedGroupP ? void 0 : _this$renovatedGroupP.dispose();\n      this.renovatedGroupPanel = void 0;\n      null === (_this$renovatedHeader = this.renovatedHeaderPanel) || void 0 === _this$renovatedHeader ? void 0 : _this$renovatedHeader.dispose();\n      this.renovatedHeaderPanel = void 0;\n    }\n  }, {\n    key: \"getWorkArea\",\n    value: function getWorkArea() {\n      return this._dateTableScrollable.$content();\n    }\n  }, {\n    key: \"getScrollable\",\n    value: function getScrollable() {\n      return this._dateTableScrollable;\n    }\n  }, {\n    key: \"getScrollableScrollTop\",\n    value: function getScrollableScrollTop() {\n      return this._dateTableScrollable.scrollTop();\n    }\n  }, {\n    key: \"getGroupedScrollableScrollTop\",\n    value: function getGroupedScrollableScrollTop(allDay) {\n      return this._groupedStrategy.getScrollableScrollTop(allDay);\n    }\n  }, {\n    key: \"getScrollableScrollLeft\",\n    value: function getScrollableScrollLeft() {\n      return this._dateTableScrollable.scrollLeft();\n    }\n  }, {\n    key: \"getScrollableOuterWidth\",\n    value: function getScrollableOuterWidth() {\n      return this._dateTableScrollable.scrollWidth();\n    }\n  }, {\n    key: \"getScrollableContainer\",\n    value: function getScrollableContainer() {\n      return this._dateTableScrollable._container();\n    }\n  }, {\n    key: \"getHeaderPanelHeight\",\n    value: function getHeaderPanelHeight() {\n      return this._$headerPanel && this._$headerPanel.outerHeight(true);\n    }\n  }, {\n    key: \"getTimePanelWidth\",\n    value: function getTimePanelWidth() {\n      return this._$timePanel && getBoundingRect(this._$timePanel.get(0)).width;\n    }\n  }, {\n    key: \"getGroupTableWidth\",\n    value: function getGroupTableWidth() {\n      return this._$groupTable ? this._$groupTable.outerWidth() : 0;\n    }\n  }, {\n    key: \"getWorkSpaceLeftOffset\",\n    value: function getWorkSpaceLeftOffset() {\n      return this._groupedStrategy.getLeftOffset();\n    }\n  }, {\n    key: \"getGroupedStrategy\",\n    value: function getGroupedStrategy() {\n      return this._groupedStrategy;\n    }\n  }, {\n    key: \"_getCellCoordinatesByIndex\",\n    value: function _getCellCoordinatesByIndex(index) {\n      var cellIndex = Math.floor(index / this._getRowCount());\n      var rowIndex = index - this._getRowCount() * cellIndex;\n      return {\n        cellIndex: cellIndex,\n        rowIndex: rowIndex\n      };\n    }\n  }, {\n    key: \"_getDateByCellIndexes\",\n    value: function _getDateByCellIndexes(rowIndex, cellIndex, patchedIndexes) {\n      cellIndex = !patchedIndexes ? this._patchCellIndex(cellIndex) : cellIndex;\n      var firstViewDate = this.getStartViewDate();\n      var firstViewDateTime = firstViewDate.getTime();\n\n      var millisecondsOffset = this._getMillisecondsOffset(rowIndex, cellIndex);\n\n      var offsetByCount = this._getOffsetByCount(cellIndex);\n\n      var startViewDateOffset = this._getTimeOffsetForStartViewDate();\n\n      var currentDate = new Date(firstViewDateTime + millisecondsOffset + offsetByCount - startViewDateOffset);\n      currentDate.setTime(currentDate.getTime() + dateUtils.getTimezonesDifference(firstViewDate, currentDate));\n      return currentDate;\n    }\n  }, {\n    key: \"_patchCellIndex\",\n    value: function _patchCellIndex(cellIndex) {\n      if (this.isGroupedByDate()) {\n        cellIndex = Math.floor(cellIndex / this._getGroupCount());\n      }\n\n      return cellIndex;\n    }\n  }, {\n    key: \"_getOffsetByCount\",\n    value: function _getOffsetByCount() {\n      return 0;\n    }\n  }, {\n    key: \"_getMillisecondsOffset\",\n    value: function _getMillisecondsOffset(rowIndex, cellIndex) {\n      return this._getInterval() * this._calculateCellIndex(rowIndex, cellIndex) + this._calculateHiddenInterval(rowIndex, cellIndex);\n    }\n  }, {\n    key: \"_calculateHiddenInterval\",\n    value: function _calculateHiddenInterval(rowIndex, cellIndex) {\n      var dayCount = cellIndex % this._getCellCount();\n\n      return dayCount * this._getHiddenInterval();\n    }\n  }, {\n    key: \"_getHiddenInterval\",\n    value: function _getHiddenInterval() {\n      if (void 0 === this._hiddenInterval) {\n        this._hiddenInterval = DAY_MS - this.getVisibleDayDuration();\n      }\n\n      return this._hiddenInterval;\n    }\n  }, {\n    key: \"_getIntervalBetween\",\n    value: function _getIntervalBetween(currentDate, allDay) {\n      var firstViewDate = this.getStartViewDate();\n      var startDayTime = this.option(\"startDayHour\") * HOUR_MS;\n      var timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate);\n      var fullInterval = currentDate.getTime() - firstViewDate.getTime() - timeZoneOffset;\n\n      var days = this._getDaysOfInterval(fullInterval, startDayTime);\n\n      var weekendsCount = this._getWeekendsCount(days);\n\n      var result = (days - weekendsCount) * DAY_MS;\n\n      if (!allDay) {\n        result = fullInterval - days * this._getHiddenInterval() - weekendsCount * this.getVisibleDayDuration();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getWeekendsCount\",\n    value: function _getWeekendsCount() {\n      return 0;\n    }\n  }, {\n    key: \"_getDaysOfInterval\",\n    value: function _getDaysOfInterval(fullInterval, startDayTime) {\n      return Math.floor((fullInterval + startDayTime) / DAY_MS);\n    }\n  }, {\n    key: \"_getGroupIndexes\",\n    value: function _getGroupIndexes(appointmentResources) {\n      var result = [];\n\n      if (this._isGroupsSpecified(appointmentResources)) {\n        var tree = this.invoke(\"createResourcesTree\", this.option(\"groups\"));\n        result = this.invoke(\"getResourceTreeLeaves\", tree, appointmentResources);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_updateIndex\",\n    value: function _updateIndex(index) {\n      return index * this._getRowCount();\n    }\n  }, {\n    key: \"_getDroppableCell\",\n    value: function _getDroppableCell() {\n      return this._getDateTables().find(\".\" + DATE_TABLE_DROPPABLE_CELL_CLASS);\n    }\n  }, {\n    key: \"_getWorkSpaceWidth\",\n    value: function _getWorkSpaceWidth() {\n      var _this11 = this;\n\n      return this.cache.get(\"workspaceWidth\", function () {\n        if (_this11._needCreateCrossScrolling()) {\n          return getBoundingRect(_this11._$dateTable.get(0)).width;\n        }\n\n        return getBoundingRect(_this11.$element().get(0)).width - _this11.getTimePanelWidth();\n      });\n    }\n  }, {\n    key: \"_getCellPositionByIndex\",\n    value: function _getCellPositionByIndex(index, groupIndex, inAllDayRow) {\n      var cellCoordinates = this._getCellCoordinatesByIndex(index);\n\n      var $cell = this._getCellByCoordinates(cellCoordinates, groupIndex, inAllDayRow);\n\n      return this._getCellPositionWithCache($cell, cellCoordinates, groupIndex);\n    }\n  }, {\n    key: \"_getCellPositionWithCache\",\n    value: function _getCellPositionWithCache($cell, cellCoordinates, groupIndex) {\n      var result = this._getCellPosition($cell);\n\n      this.setCellDataCache(cellCoordinates, groupIndex, $cell);\n\n      if (result) {\n        result.rowIndex = cellCoordinates.rowIndex;\n        result.cellIndex = cellCoordinates.cellIndex;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getCellPosition\",\n    value: function _getCellPosition($cell) {\n      var position = $cell.position();\n\n      if (this.option(\"rtlEnabled\")) {\n        position.left += getBoundingRect($cell.get(0)).width;\n      }\n\n      return position;\n    }\n  }, {\n    key: \"_getCellByCoordinates\",\n    value: function _getCellByCoordinates(cellCoordinates, groupIndex, inAllDayRow) {\n      var indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex, inAllDayRow);\n\n      return this._dom_getDateCell(indexes);\n    }\n  }, {\n    key: \"_dom_getDateCell\",\n    value: function _dom_getDateCell(position) {\n      return this._$dateTable.find(\"tr:not(.\".concat(VIRTUAL_ROW_CLASS, \")\")).eq(position.rowIndex).find(\"td:not(.\".concat(VIRTUAL_CELL_CLASS, \")\")).eq(position.cellIndex);\n    }\n  }, {\n    key: \"_dom_getAllDayPanelCell\",\n    value: function _dom_getAllDayPanelCell(cellIndex) {\n      return this._$allDayPanel.find(\"tr\").eq(0).find(\"td\").eq(cellIndex);\n    }\n  }, {\n    key: \"_getCells\",\n    value: function _getCells(allDay, direction) {\n      var cellClass = allDay ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS;\n\n      if (\"vertical\" === direction) {\n        var result = [];\n\n        for (var i = 1;; i++) {\n          var cells = this.$element().find(\"tr .\".concat(cellClass, \":nth-child(\").concat(i, \")\"));\n\n          if (!cells.length) {\n            break;\n          }\n\n          result = result.concat(cells.toArray());\n        }\n\n        return $(result);\n      } else {\n        return this.$element().find(\".\" + cellClass);\n      }\n    }\n  }, {\n    key: \"_getAllCells\",\n    value: function _getAllCells(allDay) {\n      if (this._isVerticalGroupedWorkSpace()) {\n        return this._$dateTable.find(\"td:not(.\".concat(VIRTUAL_CELL_CLASS, \")\"));\n      }\n\n      var cellClass = allDay && this.supportAllDayRow() ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS;\n      return this.$element().find(\".\" + cellClass);\n    }\n  }, {\n    key: \"_setHorizontalGroupHeaderCellsHeight\",\n    value: function _setHorizontalGroupHeaderCellsHeight() {\n      var height = getBoundingRect(this._$dateTable.get(0)).height;\n\n      this._$groupTable.outerHeight(height);\n    }\n  }, {\n    key: \"_getDateTableBorder\",\n    value: function _getDateTableBorder() {\n      return DATE_TABLE_CELL_BORDER;\n    }\n  }, {\n    key: \"_getDateTableBorderOffset\",\n    value: function _getDateTableBorderOffset() {\n      return 2 * this._getDateTableBorder();\n    }\n  }, {\n    key: \"_getGroupHeaderCellsContent\",\n    value: function _getGroupHeaderCellsContent() {\n      return this.$element().find(\".\" + GROUP_HEADER_CONTENT_CLASS);\n    }\n  }, {\n    key: \"_getGroupHeaderCells\",\n    value: function _getGroupHeaderCells() {\n      return this.$element().find(\".\" + GROUP_HEADER_CLASS);\n    }\n  }, {\n    key: \"_getScrollCoordinates\",\n    value: function _getScrollCoordinates(hours, minutes, date, groupIndex, allDay) {\n      var currentDate = date || new Date(this.option(\"currentDate\"));\n      var startDayHour = this.option(\"startDayHour\");\n      var endDayHour = this.option(\"endDayHour\");\n\n      if (hours < startDayHour) {\n        hours = startDayHour;\n      }\n\n      if (hours >= endDayHour) {\n        hours = endDayHour - 1;\n      }\n\n      currentDate.setHours(hours, minutes, 0, 0);\n\n      if (!this.isVirtualScrolling()) {\n        return this.getCoordinatesByDate(currentDate, groupIndex, allDay);\n      }\n\n      var cell = this.viewDataProvider.findGlobalCellPosition(currentDate, groupIndex, allDay);\n      var position = cell.position,\n          cellData = cell.cellData;\n      return this.virtualScrollingDispatcher.calculateCoordinatesByDataAndPosition(cellData, position, currentDate, this.isDateAndTimeView, \"vertical\" === this.viewDirection);\n    }\n  }, {\n    key: \"_isOutsideScrollable\",\n    value: function _isOutsideScrollable(target, event) {\n      var $dateTableScrollableElement = this._dateTableScrollable.$element();\n\n      var scrollableSize = getBoundingRect($dateTableScrollableElement.get(0));\n      var window = getWindow();\n      var isTargetInAllDayPanel = !$(target).closest($dateTableScrollableElement).length;\n      var isOutsideHorizontalScrollable = event.pageX < scrollableSize.left || event.pageX > scrollableSize.left + scrollableSize.width + (window.scrollX || 0);\n      var isOutsideVerticalScrollable = event.pageY < scrollableSize.top || event.pageY > scrollableSize.top + scrollableSize.height + (window.scrollY || 0);\n\n      if (isTargetInAllDayPanel && !isOutsideHorizontalScrollable) {\n        return false;\n      }\n\n      return isOutsideVerticalScrollable || isOutsideHorizontalScrollable;\n    }\n  }, {\n    key: \"setCellDataCache\",\n    value: function setCellDataCache(cellCoordinates, groupIndex, $cell) {\n      var key = JSON.stringify({\n        rowIndex: cellCoordinates.rowIndex,\n        cellIndex: cellCoordinates.cellIndex,\n        groupIndex: groupIndex\n      });\n      this.cache.set(key, this.getCellData($cell));\n    }\n  }, {\n    key: \"setCellDataCacheAlias\",\n    value: function setCellDataCacheAlias(appointment, geometry) {\n      var key = JSON.stringify({\n        rowIndex: appointment.rowIndex,\n        cellIndex: appointment.cellIndex,\n        groupIndex: appointment.groupIndex\n      });\n      var aliasKey = JSON.stringify({\n        top: geometry.top,\n        left: geometry.left\n      });\n      this.cache.set(aliasKey, this.cache.get(key));\n    }\n  }, {\n    key: \"_cleanAllowedPositions\",\n    value: function _cleanAllowedPositions() {\n      this._maxAllowedVerticalPosition = [];\n      this._maxAllowedPosition = [];\n    }\n  }, {\n    key: \"supportAllDayRow\",\n    value: function supportAllDayRow() {\n      return true;\n    }\n  }, {\n    key: \"keepOriginalHours\",\n    value: function keepOriginalHours() {\n      return false;\n    }\n  }, {\n    key: \"getSelectedCellData\",\n    value: function getSelectedCellData() {\n      if (this.isVirtualScrolling()) {\n        return this.virtualSelectionState.getSelectedCells();\n      }\n\n      var $focusedCells = this._getAllFocusedCells();\n\n      var result = [];\n\n      if ($focusedCells.length > 1) {\n        result = this._getMultipleCellsData($focusedCells);\n      } else {\n        var data = this.getCellData($($focusedCells[0]));\n        data && result.push(data);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getMultipleCellsData\",\n    value: function _getMultipleCellsData($cells) {\n      var data = [];\n\n      for (var i = 0; i < $cells.length; i++) {\n        data.push(this.getCellData($($cells[i])));\n      }\n\n      return data;\n    }\n  }, {\n    key: \"getCellData\",\n    value: function getCellData($cell) {\n      var data;\n      var currentCell = $cell[0];\n\n      if (currentCell) {\n        if (this.isRenovatedRender()) {\n          data = this._getCellDataInRenovatedView($cell);\n        } else {\n          data = elementData(currentCell, CELL_DATA);\n        }\n      }\n\n      return extend(true, {}, data);\n    }\n  }, {\n    key: \"_getVirtualRowOffset\",\n    value: function _getVirtualRowOffset() {\n      var _this$virtualScrollin4;\n\n      return (null === (_this$virtualScrollin4 = this.virtualScrollingDispatcher) || void 0 === _this$virtualScrollin4 ? void 0 : _this$virtualScrollin4.virtualRowOffset) || 0;\n    }\n  }, {\n    key: \"_getVirtualCellOffset\",\n    value: function _getVirtualCellOffset() {\n      var _this$virtualScrollin5;\n\n      return (null === (_this$virtualScrollin5 = this.virtualScrollingDispatcher) || void 0 === _this$virtualScrollin5 ? void 0 : _this$virtualScrollin5.virtualCellOffset) || 0;\n    }\n  }, {\n    key: \"_getCellDataInRenovatedView\",\n    value: function _getCellDataInRenovatedView($cell) {\n      var rowIndex = $cell.parent().index();\n\n      if (this.isVirtualScrolling()) {\n        rowIndex -= this.virtualScrollingDispatcher.topVirtualRowsCount;\n      }\n\n      var columnIndex = $cell.index();\n\n      if (this.isVirtualScrolling()) {\n        columnIndex -= this.virtualScrollingDispatcher.leftVirtualCellsCount;\n      }\n\n      var viewDataProvider = this.viewDataProvider;\n\n      var isAllDayCell = this._hasAllDayClass($cell);\n\n      var cellData = viewDataProvider.getCellData(rowIndex, columnIndex, isAllDayCell);\n      return cellData ? {\n        startDate: cellData.startDate,\n        endDate: cellData.endDate,\n        groups: cellData.groups,\n        groupIndex: cellData.groupIndex,\n        allDay: cellData.allDay\n      } : void 0;\n    }\n  }, {\n    key: \"_getHorizontalMax\",\n    value: function _getHorizontalMax(groupIndex) {\n      groupIndex = this.isGroupedByDate() ? this._getGroupCount() - 1 : groupIndex;\n      return this._groupedStrategy.getHorizontalMax(groupIndex);\n    }\n  }, {\n    key: \"getCoordinatesByDate\",\n    value: function getCoordinatesByDate(date, groupIndex, inAllDayRow) {\n      groupIndex = groupIndex || 0;\n      var position;\n\n      if (this.isVirtualScrolling()) {\n        var cellInfo = {\n          groupIndex: groupIndex,\n          startDate: date,\n          isAllDay: inAllDayRow\n        };\n        var positionByMap = this.viewDataProvider.findCellPositionInMap(cellInfo);\n\n        if (!positionByMap) {\n          return;\n        }\n\n        var $cell = this._dom_getDateCell(positionByMap);\n\n        position = this._getCellPositionWithCache($cell, positionByMap, groupIndex);\n      } else {\n        position = this.calculateCellPositionByView(date, groupIndex, inAllDayRow);\n      }\n\n      var shift = this.getPositionShift(inAllDayRow ? 0 : this.getTimeShift(date), inAllDayRow);\n\n      var horizontalHMax = this._getHorizontalMax(groupIndex, date);\n\n      if (!position) {\n        throw errors.Error(\"E1039\");\n      }\n\n      return {\n        cellPosition: position.left + shift.cellPosition,\n        top: position.top + shift.top,\n        left: position.left + shift.left,\n        rowIndex: position.rowIndex,\n        cellIndex: position.cellIndex,\n        hMax: horizontalHMax,\n        vMax: this.getVerticalMax(groupIndex),\n        groupIndex: groupIndex\n      };\n    }\n  }, {\n    key: \"calculateCellPositionByView\",\n    value: function calculateCellPositionByView(date, groupIndex, inAllDayRow) {\n      var index = this.getCellIndexByDate(date, inAllDayRow);\n      return this._getCellPositionByIndex(index, groupIndex, inAllDayRow);\n    }\n  }, {\n    key: \"getVerticalMax\",\n    value: function getVerticalMax(groupIndex) {\n      return this._groupedStrategy.getVerticalMax(groupIndex);\n    }\n  }, {\n    key: \"_getOffsetByAllDayPanel\",\n    value: function _getOffsetByAllDayPanel(groupIndex) {\n      return this._groupedStrategy._getOffsetByAllDayPanel(groupIndex);\n    }\n  }, {\n    key: \"_getGroupTop\",\n    value: function _getGroupTop(groupIndex) {\n      return this._groupedStrategy._getGroupTop(groupIndex);\n    }\n  }, {\n    key: \"isGroupedByDate\",\n    value: function isGroupedByDate() {\n      return this.option(\"groupByDate\") && this._isHorizontalGroupedWorkSpace() && this._getGroupCount() > 0;\n    }\n  }, {\n    key: \"getCellIndexByDate\",\n    value: function getCellIndexByDate(date, inAllDayRow) {\n      var timeInterval = inAllDayRow ? 864e5 : this._getInterval();\n\n      var dateTimeStamp = this._getIntervalBetween(date, inAllDayRow) + this._getTimeOffsetForStartViewDate();\n\n      var index = Math.floor(dateTimeStamp / timeInterval);\n\n      if (inAllDayRow) {\n        index = this._updateIndex(index);\n      }\n\n      if (index < 0) {\n        index = 0;\n      }\n\n      return index;\n    }\n  }, {\n    key: \"getPositionShift\",\n    value: function getPositionShift(timeShift, isAllDay) {\n      return {\n        top: timeShift * this.getCellHeight(),\n        left: 0,\n        cellPosition: 0\n      };\n    }\n  }, {\n    key: \"getTimeShift\",\n    value: function getTimeShift(date) {\n      var currentDayStart = new Date(date);\n      var cellDuration = this.getCellDuration();\n      var currentDayEndHour = new Date(new Date(date).setHours(this.option(\"endDayHour\"), 0, 0));\n\n      if (date.getTime() <= currentDayEndHour.getTime()) {\n        currentDayStart.setHours(this.option(\"startDayHour\"), 0, 0, 0);\n      }\n\n      var timeZoneDifference = dateUtils.getTimezonesDifference(date, currentDayStart);\n      var currentDateTime = date.getTime();\n      var currentDayStartTime = currentDayStart.getTime();\n\n      var minTime = this._firstViewDate.getTime();\n\n      return currentDateTime > minTime ? (currentDateTime - currentDayStartTime + timeZoneDifference) % cellDuration / cellDuration : 0;\n    }\n  }, {\n    key: \"_isSkippedData\",\n    value: function _isSkippedData() {\n      return false;\n    }\n  }, {\n    key: \"getCoordinatesByDateInGroup\",\n    value: function getCoordinatesByDateInGroup(startDate, appointmentResources, inAllDayRow, groupIndex) {\n      var _this12 = this;\n\n      var result = [];\n\n      if (this._isSkippedData(startDate)) {\n        return result;\n      }\n\n      var groupIndices = [groupIndex];\n\n      if (!isDefined(groupIndex)) {\n        groupIndices = this._getGroupCount() ? this._getGroupIndexes(appointmentResources) : [0];\n      }\n\n      groupIndices.forEach(function (groupIndex) {\n        var coordinates = _this12.getCoordinatesByDate(startDate, groupIndex, inAllDayRow);\n\n        coordinates && result.push(coordinates);\n      });\n      return result;\n    }\n  }, {\n    key: \"getDroppableCellIndex\",\n    value: function getDroppableCellIndex() {\n      var $droppableCell = this._getDroppableCell();\n\n      var $row = $droppableCell.parent();\n      var rowIndex = $row.index();\n      return rowIndex * $row.find(\"td\").length + $droppableCell.index();\n    }\n  }, {\n    key: \"getDataByDroppableCell\",\n    value: function getDataByDroppableCell() {\n      var cellData = this.getCellData($(this._getDroppableCell()));\n      var allDay = cellData.allDay;\n      var startDate = cellData.startDate;\n      var endDate = startDate && this.invoke(\"calculateAppointmentEndDate\", allDay, startDate);\n      return {\n        startDate: startDate,\n        endDate: endDate,\n        allDay: allDay,\n        groups: cellData.groups\n      };\n    }\n  }, {\n    key: \"getDateRange\",\n    value: function getDateRange() {\n      return [this.getStartViewDate(), this.getEndViewDateByEndDayHour()];\n    }\n  }, {\n    key: \"getCellWidth\",\n    value: function getCellWidth() {\n      var _this13 = this;\n\n      return this.cache.get(\"cellWidth\", function () {\n        var cell = _this13._getCells().first().get(0);\n\n        return cell && getBoundingRect(cell).width;\n      });\n    }\n  }, {\n    key: \"getCellMinWidth\",\n    value: function getCellMinWidth() {\n      return DATE_TABLE_MIN_CELL_WIDTH;\n    }\n  }, {\n    key: \"getRoundedCellWidth\",\n    value: function getRoundedCellWidth(groupIndex, startIndex, cellCount) {\n      if (groupIndex < 0) {\n        return 0;\n      }\n\n      var $row = this.$element().find(\".\" + this._getDateTableRowClass()).eq(0);\n      var width = 0;\n      var $cells = $row.find(\".\" + DATE_TABLE_CELL_CLASS);\n      var totalCellCount = this._getCellCount() * groupIndex;\n      cellCount = cellCount || this._getCellCount();\n\n      if (!isDefined(startIndex)) {\n        startIndex = totalCellCount;\n      }\n\n      for (var i = startIndex; i < totalCellCount + cellCount; i++) {\n        width += getBoundingRect($($cells).eq(i).get(0)).width;\n      }\n\n      return width / (totalCellCount + cellCount - startIndex);\n    }\n  }, {\n    key: \"getCellHeight\",\n    value: function getCellHeight() {\n      var _this14 = this;\n\n      var useCache = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;\n\n      var callbackResult = function callbackResult() {\n        var cell = _this14._getCells().first().get(0);\n\n        return cell && getBoundingRect(cell).height;\n      };\n\n      return useCache ? this.cache.get(\"cellHeight\", callbackResult) : callbackResult();\n    }\n  }, {\n    key: \"getAllDayHeight\",\n    value: function getAllDayHeight() {\n      var cell = this._getCells(true).first().get(0);\n\n      return this._isShowAllDayPanel() ? cell && getBoundingRect(cell).height || 0 : 0;\n    }\n  }, {\n    key: \"getAllDayOffset\",\n    value: function getAllDayOffset() {\n      return this._groupedStrategy.getAllDayOffset();\n    }\n  }, {\n    key: \"getMaxAllowedPosition\",\n    value: function getMaxAllowedPosition(groupIndex) {\n      var validGroupIndex = groupIndex || 0;\n\n      if (this.isRenovatedRender()) {\n        return this.getRMaxAllowedHorizontalPosition(validGroupIndex);\n      }\n\n      return this.getMaxAllowedHorizontalPosition(validGroupIndex);\n    }\n  }, {\n    key: \"getMaxAllowedHorizontalPosition\",\n    value: function getMaxAllowedHorizontalPosition(groupIndex) {\n      if (0 === this._maxAllowedPosition.length) {\n        var isRtl = this.option(\"rtlEnabled\");\n        this._maxAllowedPosition = [];\n\n        this._$dateTable.find(\"tr\").first().find(\"td:nth-child(\".concat(this._getCellCount(), \"n)\")).each(function (_, cell) {\n          var maxPosition = $(cell).position().left;\n\n          if (!isRtl) {\n            maxPosition += getBoundingRect(cell).width;\n          }\n\n          this._maxAllowedPosition.push(Math.round(maxPosition));\n        }.bind(this));\n      }\n\n      return this._maxAllowedPosition[groupIndex];\n    }\n  }, {\n    key: \"getRMaxAllowedHorizontalPosition\",\n    value: function getRMaxAllowedHorizontalPosition(groupIndex) {\n      var _this15 = this;\n\n      if (!this._maxAllowedPosition[groupIndex]) {\n        var _this$viewDataProvide = this.viewDataProvider.getLasGroupCellPosition(groupIndex),\n            cellIndex = _this$viewDataProvide.cellIndex;\n\n        (function (cellIndex) {\n          var cell = _this15._$dateTable.find(\"tr:not(.\".concat(VIRTUAL_ROW_CLASS, \")\")).first().find(\"td:not(.\".concat(VIRTUAL_CELL_CLASS, \")\")).get(cellIndex);\n\n          var maxPosition = $(cell).position().left;\n\n          if (!_this15.option(\"rtlEnabled\")) {\n            maxPosition += getBoundingRect(cell).width;\n          }\n\n          _this15._maxAllowedPosition[groupIndex] = Math.round(maxPosition);\n        })(cellIndex);\n      }\n\n      return this._maxAllowedPosition[groupIndex];\n    }\n  }, {\n    key: \"getMaxAllowedVerticalPosition\",\n    value: function getMaxAllowedVerticalPosition(groupIndex) {\n      if (this.isRenovatedRender()) {\n        return this.getRMaxAllowedVerticalPosition(groupIndex);\n      }\n\n      return this.getMaxAllowedVerticalPositionStandard(groupIndex);\n    }\n  }, {\n    key: \"getMaxAllowedVerticalPositionStandard\",\n    value: function getMaxAllowedVerticalPositionStandard(groupIndex) {\n      var _this16 = this;\n\n      if (0 === this._maxAllowedVerticalPosition.length) {\n        var rowCount = this._getRowCount();\n\n        this._$dateTable.find(\"tr:not(.\".concat(VIRTUAL_ROW_CLASS, \"):nth-child(\").concat(rowCount, \"n)\")).each(function (_, row) {\n          var maxPosition = $(row).position().top + getBoundingRect(row).height;\n\n          _this16._maxAllowedVerticalPosition.push(Math.round(maxPosition));\n        });\n      }\n\n      return this._maxAllowedVerticalPosition[groupIndex];\n    }\n  }, {\n    key: \"getRMaxAllowedVerticalPosition\",\n    value: function getRMaxAllowedVerticalPosition(groupIndex) {\n      var _this17 = this;\n\n      if (!this._maxAllowedVerticalPosition[groupIndex]) {\n        var _this$viewDataProvide2 = this.viewDataProvider.getLasGroupCellPosition(groupIndex),\n            rowIndex = _this$viewDataProvide2.rowIndex;\n\n        (function (rowIndex) {\n          var row = _this17._$dateTable.find(\"tr:not(.\".concat(VIRTUAL_ROW_CLASS, \")\")).get(rowIndex);\n\n          var maxPosition = $(row).position().top + getBoundingRect(row).height;\n\n          if (_this17.isGroupedAllDayPanel()) {\n            maxPosition -= (groupIndex + 1) * _this17.getAllDayHeight();\n          }\n\n          _this17._maxAllowedVerticalPosition[groupIndex] = Math.round(maxPosition);\n        })(rowIndex);\n      }\n\n      return this._maxAllowedVerticalPosition[groupIndex];\n    }\n  }, {\n    key: \"getFixedContainer\",\n    value: function getFixedContainer() {\n      return this._$fixedContainer;\n    }\n  }, {\n    key: \"getAllDayContainer\",\n    value: function getAllDayContainer() {\n      return this._$allDayContainer;\n    }\n  }, {\n    key: \"getCellIndexByCoordinates\",\n    value: function getCellIndexByCoordinates(coordinates, allDay) {\n      var cellCount = this._getTotalCellCount(this._getGroupCount());\n\n      var cellWidth = Math.floor(this._getWorkSpaceWidth() / cellCount);\n      var cellHeight = allDay ? this.getAllDayHeight() : this.getCellHeight();\n      var leftOffset = this._isRTL() || this.option(\"crossScrollingEnabled\") ? 0 : this.getWorkSpaceLeftOffset();\n      var topIndex = Math.floor(Math.floor(coordinates.top) / Math.floor(cellHeight));\n      var leftIndex = Math.floor((coordinates.left + 5 - leftOffset) / cellWidth);\n\n      if (this._isRTL()) {\n        leftIndex = cellCount - leftIndex - 1;\n      }\n\n      return cellCount * topIndex + leftIndex;\n    }\n  }, {\n    key: \"getStartViewDate\",\n    value: function getStartViewDate() {\n      return this._firstViewDate;\n    }\n  }, {\n    key: \"getEndViewDate\",\n    value: function getEndViewDate() {\n      var dateOfLastViewCell = this.getDateOfLastViewCell();\n      var endDateOfLastViewCell = this.calculateEndViewDate(dateOfLastViewCell);\n      return this._adjustEndViewDateByDaylightDiff(dateOfLastViewCell, endDateOfLastViewCell);\n    }\n  }, {\n    key: \"getEndViewDateByEndDayHour\",\n    value: function getEndViewDateByEndDayHour() {\n      var dateOfLastViewCell = this.getDateOfLastViewCell();\n      var endTime = dateUtils.dateTimeFromDecimal(this.option(\"endDayHour\"));\n      var endDateOfLastViewCell = new Date(dateOfLastViewCell.setHours(endTime.hours, endTime.minutes));\n      return this._adjustEndViewDateByDaylightDiff(dateOfLastViewCell, endDateOfLastViewCell);\n    }\n  }, {\n    key: \"calculateEndViewDate\",\n    value: function calculateEndViewDate(dateOfLastViewCell) {\n      return new Date(dateOfLastViewCell.getTime() + this.getCellDuration());\n    }\n  }, {\n    key: \"_adjustEndViewDateByDaylightDiff\",\n    value: function _adjustEndViewDateByDaylightDiff(startDate, endDate) {\n      var daylightDiff = timeZoneUtils.getDaylightOffsetInMs(startDate, endDate);\n      var endDateOfLastViewCell = new Date(endDate.getTime() - daylightDiff);\n      return new Date(endDateOfLastViewCell.getTime() - this._getEndViewDateTimeDiff());\n    }\n  }, {\n    key: \"_getEndViewDateTimeDiff\",\n    value: function _getEndViewDateTimeDiff() {\n      return toMs(\"minute\");\n    }\n  }, {\n    key: \"getDateOfLastViewCell\",\n    value: function getDateOfLastViewCell() {\n      var rowIndex = this._getRowCount() - 1;\n\n      var cellIndex = this._getCellCount();\n\n      if (this.isGroupedByDate()) {\n        cellIndex = cellIndex * this._getGroupCount() - 1;\n      } else {\n        cellIndex -= 1;\n      }\n\n      return this._getDateByCellIndexes(rowIndex, cellIndex, true);\n    }\n  }, {\n    key: \"getCellDuration\",\n    value: function getCellDuration() {\n      return 36e5 * this.option(\"hoursInterval\");\n    }\n  }, {\n    key: \"getIntervalDuration\",\n    value: function getIntervalDuration(allDay) {\n      return allDay ? toMs(\"day\") : this.getCellDuration();\n    }\n  }, {\n    key: \"getVisibleDayDuration\",\n    value: function getVisibleDayDuration() {\n      return this.option(\"hoursInterval\") * this._getCellCountInDay() * HOUR_MS;\n    }\n  }, {\n    key: \"getGroupBounds\",\n    value: function getGroupBounds(coordinates) {\n      var cellCount = this._getCellCount();\n\n      var $cells = this._getCells();\n\n      var cellWidth = this.getCellWidth();\n      var result;\n\n      if (this.isVirtualScrolling()) {\n        var groupedDataMap = this.viewDataProvider.groupedDataMap;\n        result = this._groupedStrategy.getVirtualScrollingGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap);\n      } else {\n        result = this._groupedStrategy.getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates);\n      }\n\n      if (this._isRTL()) {\n        var startOffset = result.left;\n        result.left = result.right - 2 * cellWidth;\n        result.right = startOffset + 2 * cellWidth;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"needRecalculateResizableArea\",\n    value: function needRecalculateResizableArea() {\n      return this._isVerticalGroupedWorkSpace() && 0 !== this.getScrollable().scrollTop();\n    }\n  }, {\n    key: \"getCellDataByCoordinates\",\n    value: function getCellDataByCoordinates(coordinates, allDay) {\n      var _this18 = this;\n\n      var key = JSON.stringify({\n        top: coordinates.top,\n        left: coordinates.left\n      });\n      return this.cache.get(key, function () {\n        var $cells = _this18._getCells(allDay);\n\n        var cellIndex = _this18.getCellIndexByCoordinates(coordinates, allDay);\n\n        var $cell = $cells.eq(cellIndex);\n        return _this18.getCellData($cell);\n      });\n    }\n  }, {\n    key: \"getVisibleBounds\",\n    value: function getVisibleBounds() {\n      var result = {};\n      var $scrollable = this.getScrollable().$element();\n      var cellHeight = this.getCellHeight();\n      var scrolledCellCount = this.getScrollableScrollTop() / cellHeight;\n      var totalCellCount = scrolledCellCount + $scrollable.height() / cellHeight;\n      result.top = {\n        hours: Math.floor(scrolledCellCount * this.option(\"hoursInterval\")) + this.option(\"startDayHour\"),\n        minutes: scrolledCellCount % 2 ? 30 : 0\n      };\n      result.bottom = {\n        hours: Math.floor(totalCellCount * this.option(\"hoursInterval\")) + this.option(\"startDayHour\"),\n        minutes: Math.floor(totalCellCount) % 2 ? 30 : 0\n      };\n      return result;\n    }\n  }, {\n    key: \"updateScrollPosition\",\n    value: function updateScrollPosition(date, groups) {\n      var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n      var scheduler = this.option(\"observer\");\n      var newDate = scheduler.timeZoneCalculator.createDate(date, {\n        path: \"toGrid\"\n      });\n      var inAllDayRow = allDay && this.isAllDayPanelVisible;\n\n      if (this.needUpdateScrollPosition(newDate, groups, inAllDayRow)) {\n        this.scrollTo(newDate, groups, inAllDayRow, false);\n      }\n    }\n  }, {\n    key: \"needUpdateScrollPosition\",\n    value: function needUpdateScrollPosition(date, groups, inAllDayRow) {\n      var _this19 = this;\n\n      var cells = this._getCellsInViewport(inAllDayRow);\n\n      var groupIndex = this._isGroupsSpecified(groups) ? this._getGroupIndexByResourceId(groups) : 0;\n      var time = date.getTime();\n      var trimmedTime = dateUtils.trimTime(date).getTime();\n      return cells.reduce(function (currentResult, cell) {\n        var _this19$getCellData = _this19.getCellData(cell),\n            cellStartDate = _this19$getCellData.startDate,\n            cellEndDate = _this19$getCellData.endDate,\n            cellGroupIndex = _this19$getCellData.groupIndex;\n\n        var cellStartTime = cellStartDate.getTime();\n        var cellEndTime = cellEndDate.getTime();\n\n        if ((!inAllDayRow && cellStartTime <= time && time < cellEndTime || inAllDayRow && trimmedTime === cellStartTime) && groupIndex === cellGroupIndex) {\n          return false;\n        }\n\n        return currentResult;\n      }, true);\n    }\n  }, {\n    key: \"_getCellsInViewport\",\n    value: function _getCellsInViewport(inAllDayRow) {\n      var $scrollable = this.getScrollable().$element();\n      var cellHeight = this.getCellHeight();\n      var cellWidth = this.getCellWidth();\n\n      var totalColumnCount = this._getTotalCellCount(this._getGroupCount());\n\n      var scrollableScrollTop = this.getScrollableScrollTop();\n      var scrollableScrollLeft = this.getScrollableScrollLeft();\n      var fullScrolledRowCount = scrollableScrollTop / cellHeight;\n\n      if (this.isVirtualScrolling()) {\n        fullScrolledRowCount -= this.virtualScrollingDispatcher.topVirtualRowsCount;\n      }\n\n      var scrolledRowCount = Math.floor(fullScrolledRowCount);\n\n      if (scrollableScrollTop % cellHeight !== 0) {\n        scrolledRowCount += 1;\n      }\n\n      var fullScrolledColumnCount = scrollableScrollLeft / cellWidth;\n      var scrolledColumnCount = Math.floor(fullScrolledColumnCount);\n\n      if (scrollableScrollLeft % cellWidth !== 0) {\n        scrolledColumnCount += 1;\n      }\n\n      var rowCount = Math.floor(fullScrolledRowCount + $scrollable.height() / cellHeight);\n      var columnCount = Math.floor(fullScrolledColumnCount + $scrollable.width() / cellWidth);\n\n      var $cells = this._getAllCells(inAllDayRow);\n\n      var result = [];\n      $cells.each(function (index) {\n        var $cell = $(this);\n        var columnIndex = index % totalColumnCount;\n        var rowIndex = index / totalColumnCount;\n\n        if (scrolledColumnCount <= columnIndex && columnIndex < columnCount && scrolledRowCount <= rowIndex && rowIndex < rowCount) {\n          result.push($cell);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"getGroupWidth\",\n    value: function getGroupWidth(groupIndex) {\n      var result = this._getCellCount() * this.getCellWidth();\n\n      if (this.isVirtualScrolling()) {\n        var groupedData = this.viewDataProvider.groupedDataMap.dateTableGroupedMap;\n        var groupLength = groupedData[groupIndex][0].length;\n        result = groupLength * this.getCellWidth();\n      }\n\n      var position = this.getMaxAllowedPosition(groupIndex);\n      var currentPosition = position[groupIndex];\n\n      if (currentPosition) {\n        if (this._isRTL()) {\n          result = currentPosition - position[groupIndex + 1];\n        } else if (0 === groupIndex) {\n          result = currentPosition;\n        } else {\n          result = currentPosition - position[groupIndex - 1];\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"scrollToTime\",\n    value: function scrollToTime(hours, minutes, date) {\n      if (!this._isValidScrollDate(date)) {\n        return;\n      }\n\n      var coordinates = this._getScrollCoordinates(hours, minutes, date);\n\n      var scrollable = this.getScrollable();\n      scrollable.scrollBy({\n        top: coordinates.top - scrollable.scrollTop(),\n        left: 0\n      });\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(date, groups) {\n      var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n      var throwWarning = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : true;\n\n      if (!this._isValidScrollDate(date, throwWarning)) {\n        return;\n      }\n\n      var groupIndex = this._getGroupCount() && groups ? this._getGroupIndexByResourceId(groups) : 0;\n      var isScrollToAllDay = allDay && this.isAllDayPanelVisible;\n\n      var coordinates = this._getScrollCoordinates(date.getHours(), date.getMinutes(), date, groupIndex, isScrollToAllDay);\n\n      var scrollable = this.getScrollable();\n      var $scrollable = scrollable.$element();\n      var offset = this.option(\"rtlEnabled\") ? this.getCellWidth() : 0;\n      var scrollableHeight = $scrollable.height();\n      var scrollableWidth = $scrollable.width();\n      var cellWidth = this.getCellWidth();\n      var cellHeight = this.getCellHeight();\n      var xShift = (scrollableWidth - cellWidth) / 2;\n      var yShift = (scrollableHeight - cellHeight) / 2;\n      var left = coordinates.left - scrollable.scrollLeft() - xShift - offset;\n      var top = coordinates.top - scrollable.scrollTop() - yShift;\n\n      if (isScrollToAllDay && !this._isVerticalGroupedWorkSpace()) {\n        top = 0;\n      }\n\n      if (this.option(\"templatesRenderAsynchronously\")) {\n        setTimeout(function () {\n          scrollable.scrollBy({\n            left: left,\n            top: top\n          });\n        });\n      } else {\n        scrollable.scrollBy({\n          left: left,\n          top: top\n        });\n      }\n    }\n  }, {\n    key: \"_isValidScrollDate\",\n    value: function _isValidScrollDate(date) {\n      var throwWarning = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;\n      var min = this.getStartViewDate();\n      var max = this.getEndViewDate();\n\n      if (date < min || date > max) {\n        throwWarning && errors.log(\"W1008\", date);\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"getDistanceBetweenCells\",\n    value: function getDistanceBetweenCells(startIndex, endIndex) {\n      var result = 0;\n      this.$element().find(\".\" + this._getDateTableRowClass()).first().find(\".\" + DATE_TABLE_CELL_CLASS).each(function (index) {\n        if (index < startIndex || index > endIndex) {\n          return true;\n        }\n\n        result += getBoundingRect(this).width;\n      });\n      return result;\n    }\n  }, {\n    key: \"needApplyCollectorOffset\",\n    value: function needApplyCollectorOffset() {\n      return false;\n    }\n  }, {\n    key: \"initDragBehavior\",\n    value: function initDragBehavior(scheduler) {\n      if (!this.dragBehavior && scheduler) {\n        this.dragBehavior = new AppointmentDragBehavior(scheduler);\n\n        this._createDragBehavior(this.getWorkArea());\n\n        this._createDragBehavior(this.getAllDayContainer());\n\n        this._createDragBehavior(this._$allDayPanel);\n      }\n    }\n  }, {\n    key: \"_createDragBehavior\",\n    value: function _createDragBehavior($element) {\n      this._createDragBehaviorBase($element, function (itemElement, appointments) {\n        return appointments._getItemData(itemElement);\n      }, function ($itemElement) {\n        return $itemElement.data(APPOINTMENT_SETTINGS_KEY);\n      });\n    }\n  }, {\n    key: \"_createDragBehaviorBase\",\n    value: function _createDragBehaviorBase($element, getItemData, getItemSettings) {\n      var _this20 = this;\n\n      var options = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};\n      var container = this.$element().find(\".\".concat(FIXED_CONTAINER_CLASS));\n      var element = this.$element();\n      var isDefaultDraggingMode = \"default\" === this.option(\"draggingMode\");\n      this.dragBehavior.addTo($element, createDragBehaviorConfig(container, isDefaultDraggingMode, this.dragBehavior, function () {\n        return _this20._attachDragEvents(element);\n      }, function () {\n        return _this20._detachDragEvents(element);\n      }, function () {\n        return _this20._getDroppableCell();\n      }, function () {\n        return _this20.removeDroppableCellClass();\n      }, function () {\n        return _this20.getCellWidth();\n      }, getItemData, getItemSettings, options));\n    }\n  }, {\n    key: \"_createDragAppointment\",\n    value: function _createDragAppointment(itemData, settings, appointments) {\n      var appointmentIndex = appointments.option(\"items\").length;\n      settings.isCompact = false;\n      settings.virtual = false;\n\n      var items = appointments._renderItem(appointmentIndex, {\n        itemData: itemData,\n        settings: [settings]\n      });\n\n      return items[0];\n    }\n  }, {\n    key: \"_isApplyCompactAppointmentOffset\",\n    value: function _isApplyCompactAppointmentOffset() {\n      return this._supportCompactDropDownAppointments();\n    }\n  }, {\n    key: \"_supportCompactDropDownAppointments\",\n    value: function _supportCompactDropDownAppointments() {\n      return true;\n    }\n  }, {\n    key: \"_formatWeekday\",\n    value: function _formatWeekday(date) {\n      return formatWeekday(date);\n    }\n  }, {\n    key: \"_formatWeekdayAndDay\",\n    value: function _formatWeekdayAndDay(date) {\n      return formatWeekday(date) + \" \" + dateLocalization.format(date, \"day\");\n    }\n  }, {\n    key: \"removeDroppableCellClass\",\n    value: function removeDroppableCellClass($cellElement) {\n      ($cellElement || this._getDroppableCell()).removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n    }\n  }, {\n    key: \"_getCoordinatesByCell\",\n    value: function _getCoordinatesByCell($cell) {\n      var columnIndex = $cell.index();\n      var rowIndex = $cell.parent().index();\n\n      var isAllDayCell = this._hasAllDayClass($cell);\n\n      var isVerticalGrouping = this._isVerticalGroupedWorkSpace();\n\n      if (this.isVirtualScrolling() && !(isAllDayCell && !isVerticalGrouping)) {\n        rowIndex -= this.virtualScrollingDispatcher.topVirtualRowsCount;\n      }\n\n      if (this.isVirtualScrolling()) {\n        columnIndex -= this.virtualScrollingDispatcher.leftVirtualCellsCount;\n      }\n\n      return {\n        rowIndex: rowIndex,\n        columnIndex: columnIndex\n      };\n    }\n  }, {\n    key: \"_isShowAllDayPanel\",\n    value: function _isShowAllDayPanel() {\n      return this.option(\"showAllDayPanel\");\n    }\n  }, {\n    key: \"updateAppointments\",\n    value: function updateAppointments() {\n      var _this$dragBehavior;\n\n      this.invoke(\"renderAppointments\");\n      null === (_this$dragBehavior = this.dragBehavior) || void 0 === _this$dragBehavior ? void 0 : _this$dragBehavior.updateDragSource();\n    }\n  }, {\n    key: \"_getTimePanelCells\",\n    value: function _getTimePanelCells() {\n      return this.$element().find(\".\".concat(TIME_PANEL_CELL_CLASS));\n    }\n  }, {\n    key: \"_getRDateTableProps\",\n    value: function _getRDateTableProps() {\n      return {\n        viewData: this.viewDataProvider.viewData,\n        dataCellTemplate: this.option(\"dataCellTemplate\"),\n        addDateTableClass: !this.option(\"crossScrollingEnabled\") || this.isVirtualScrolling(),\n        groupOrientation: this.option(\"groupOrientation\")\n      };\n    }\n  }, {\n    key: \"_getTimeOffsetForStartViewDate\",\n    value: function _getTimeOffsetForStartViewDate() {\n      var startViewDate = this.getStartViewDate();\n      var startDayHour = Math.floor(this.option(\"startDayHour\"));\n      var isDSTChange = timeZoneUtils.isTimezoneChangeInDate(startViewDate);\n\n      if (isDSTChange && startDayHour !== startViewDate.getHours()) {\n        return toMs(\"hour\");\n      }\n\n      return 0;\n    }\n  }]);\n\n  return SchedulerWorkSpace;\n}(WidgetObserver);\n\nvar createDragBehaviorConfig = function createDragBehaviorConfig(container, isDefaultDraggingMode, dragBehavior, attachGeneralEvents, detachGeneralEvents, getDroppableCell, removeDroppableCellClass, getCellWidth, getItemData, getItemSettings, options) {\n  var state = {\n    dragElement: void 0,\n    itemData: void 0\n  };\n  var cursorOffset = options.isSetCursorOffset ? function () {\n    var $dragElement = $(state.dragElement);\n    return {\n      x: $dragElement.width() / 2,\n      y: $dragElement.height() / 2\n    };\n  } : void 0;\n  return {\n    container: container,\n    dragTemplate: function dragTemplate() {\n      return state.dragElement;\n    },\n    onDragStart: function onDragStart(e) {\n      if (!isDefaultDraggingMode) {\n        detachGeneralEvents();\n      }\n\n      var canceled = e.cancel;\n      var event = e.event;\n      var $itemElement = $(e.itemElement);\n      var appointments = e.component._appointments;\n      state.itemData = getItemData(e.itemElement, appointments);\n      var settings = getItemSettings($itemElement, e);\n\n      if (state.itemData && !state.itemData.disabled) {\n        event.data = event.data || {};\n\n        if (!canceled) {\n          if (!settings.isCompact) {\n            dragBehavior.updateDragSource(state.itemData, settings);\n          }\n\n          state.dragElement = function (itemData, settings, appointments) {\n            var appointmentIndex = appointments.option(\"items\").length;\n            settings.isCompact = false;\n            settings.virtual = false;\n\n            var items = appointments._renderItem(appointmentIndex, {\n              itemData: itemData,\n              settings: [settings]\n            });\n\n            return items[0];\n          }(state.itemData, settings, appointments);\n\n          event.data.itemElement = state.dragElement;\n          event.data.initialPosition = locate($(state.dragElement));\n          event.data.itemData = state.itemData;\n          event.data.itemSettings = settings;\n          dragBehavior.onDragStart(event.data);\n          resetPosition($(state.dragElement));\n        }\n      }\n    },\n    onDragMove: function onDragMove() {\n      if (isDefaultDraggingMode) {\n        return;\n      }\n\n      var appointmentWidth = $(state.dragElement).width();\n      var isWideAppointment = appointmentWidth > getCellWidth();\n      var draggableElement = locate($(state.dragElement).parent());\n      var newX = draggableElement.left + 10;\n      var newY = draggableElement.top + 10;\n      var elements = isWideAppointment ? getElementsFromPoint(newX, newY) : getElementsFromPoint(newX + appointmentWidth / 2, newY);\n      var droppableCell = elements.filter(function (el) {\n        return el.className.indexOf(DATE_TABLE_CELL_CLASS) > -1 || el.className.indexOf(ALL_DAY_TABLE_CELL_CLASS) > -1;\n      })[0];\n\n      if (droppableCell) {\n        var oldDroppableCell = getDroppableCell();\n\n        if (!oldDroppableCell.is(droppableCell)) {\n          removeDroppableCellClass();\n        }\n\n        $(droppableCell).addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n      }\n    },\n    onDragEnd: function onDragEnd(e) {\n      var _state$dragElement;\n\n      if (!isDefaultDraggingMode) {\n        attachGeneralEvents();\n      }\n\n      if (state.itemData && !state.itemData.disabled) {\n        dragBehavior.onDragEnd(e);\n      }\n\n      null === (_state$dragElement = state.dragElement) || void 0 === _state$dragElement ? void 0 : _state$dragElement.remove();\n      removeDroppableCellClass();\n    },\n    cursorOffset: cursorOffset,\n    filter: options.filter\n  };\n};\n\nexport default SchedulerWorkSpace;","map":null,"metadata":{},"sourceType":"module"}