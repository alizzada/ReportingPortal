{"ast":null,"code":"import _classCallCheck from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/rendering_strategies/ui.scheduler.appointments.strategy.vertical.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport BaseAppointmentsStrategy from \"./ui.scheduler.appointments.strategy.base\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { isNumeric } from \"../../../core/utils/type\";\nimport dateUtils from \"../../../core/utils/date\";\nimport timeZoneUtils from \"./../utils.timeZone\";\nvar ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET = 5;\nvar ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET = 20;\nvar toMs = dateUtils.dateToMilliseconds;\n\nvar VerticalRenderingStrategy = /*#__PURE__*/function (_BaseAppointmentsStra) {\n  _inherits(VerticalRenderingStrategy, _BaseAppointmentsStra);\n\n  var _super = _createSuper(VerticalRenderingStrategy);\n\n  function VerticalRenderingStrategy() {\n    _classCallCheck(this, VerticalRenderingStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(VerticalRenderingStrategy, [{\n    key: \"getDeltaTime\",\n    value: function getDeltaTime(args, initialSize, appointment) {\n      var deltaTime = 0;\n\n      if (this.isAllDay(appointment)) {\n        deltaTime = this._getDeltaWidth(args, initialSize) * toMs(\"day\");\n      } else {\n        var deltaHeight = args.height - initialSize.height;\n        deltaTime = toMs(\"minute\") * Math.round(deltaHeight / this.getDefaultCellHeight() * this.instance.getAppointmentDurationInMinutes());\n      }\n\n      return deltaTime;\n    }\n  }, {\n    key: \"_correctCollectorCoordinatesInAdaptive\",\n    value: function _correctCollectorCoordinatesInAdaptive(coordinates, isAllDay) {\n      if (isAllDay) {\n        _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_correctCollectorCoordinatesInAdaptive\", this).call(this, coordinates, isAllDay);\n      } else if (0 === this._getMaxAppointmentCountPerCellByType()) {\n        var cellHeight = this.getDefaultCellHeight();\n        var cellWidth = this.getDefaultCellWidth();\n        coordinates.top += (cellHeight - this.getDropDownButtonAdaptiveSize()) / 2;\n        coordinates.left += (cellWidth - this.getDropDownButtonAdaptiveSize()) / 2;\n      }\n    }\n  }, {\n    key: \"getAppointmentGeometry\",\n    value: function getAppointmentGeometry(coordinates) {\n      var geometry = null;\n\n      if (coordinates.allDay) {\n        geometry = this._getAllDayAppointmentGeometry(coordinates);\n      } else {\n        geometry = this._isAdaptive() && coordinates.isCompact ? this._getAdaptiveGeometry(coordinates) : this._getVerticalAppointmentGeometry(coordinates);\n      }\n\n      return _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"getAppointmentGeometry\", this).call(this, geometry);\n    }\n  }, {\n    key: \"_getAdaptiveGeometry\",\n    value: function _getAdaptiveGeometry(coordinates) {\n      var config = this._calculateGeometryConfig(coordinates);\n\n      return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset);\n    }\n  }, {\n    key: \"_getItemPosition\",\n    value: function _getItemPosition(appointment) {\n      var adapter = this.instance.createAppointmentAdapter(appointment);\n      var allDay = this.isAllDay(appointment);\n      var isRecurring = !!adapter.recurrenceRule;\n      var appointmentStartDate = adapter.calculateStartDate(\"toGrid\");\n      var appointmentEndDate = adapter.calculateEndDate(\"toGrid\");\n      var isAppointmentTakesSeveralDays = !timeZoneUtils.isSameAppointmentDates(appointmentStartDate, appointmentEndDate);\n\n      if (allDay) {\n        return _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_getItemPosition\", this).call(this, appointment);\n      }\n\n      var settings = this._getAppointmentCoordinates(appointment);\n\n      var result = [];\n\n      for (var j = 0; j < settings.length; j++) {\n        var currentSetting = settings[j];\n        var height = this.calculateAppointmentHeight(appointment, currentSetting);\n        var width = this.calculateAppointmentWidth(appointment, currentSetting);\n        var resultHeight = height;\n        var appointmentReduced = null;\n        var multiDaysAppointmentParts = [];\n        var currentMaxAllowedPosition = currentSetting.vMax;\n\n        if (this._isMultiViewAppointment(currentSetting, height) || isAppointmentTakesSeveralDays && !isRecurring) {\n          var reduceHead = dateUtils.sameDate(appointmentStartDate, currentSetting.info.appointment.startDate) || isRecurring;\n\n          if (reduceHead) {\n            resultHeight = this._reduceMultiDayAppointment(height, {\n              top: currentSetting.top,\n              bottom: currentMaxAllowedPosition\n            });\n            multiDaysAppointmentParts = this._getAppointmentParts({\n              sourceAppointmentHeight: height,\n              reducedHeight: resultHeight,\n              width: width\n            }, currentSetting);\n          }\n\n          var isMultiDay = this._isMultiDayAppointment(currentSetting, height);\n\n          if (isMultiDay) {\n            appointmentReduced = reduceHead ? \"head\" : \"tail\";\n          }\n        }\n\n        extend(currentSetting, {\n          height: resultHeight,\n          width: width,\n          allDay: allDay,\n          appointmentReduced: appointmentReduced\n        });\n        result = this._getAppointmentPartsPosition(multiDaysAppointmentParts, currentSetting, result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_isMultiDayAppointment\",\n    value: function _isMultiDayAppointment(position, height) {\n      if (this.isVirtualScrolling) {\n        var maxTop = this._getGroupHeight() - this._getGroupTopOffset(position);\n\n        return height > maxTop;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_isMultiViewAppointment\",\n    value: function _isMultiViewAppointment(position, height) {\n      return height > position.vMax - position.top;\n    }\n  }, {\n    key: \"_reduceMultiDayAppointment\",\n    value: function _reduceMultiDayAppointment(sourceAppointmentHeight, bound) {\n      sourceAppointmentHeight = bound.bottom - Math.floor(bound.top);\n      return sourceAppointmentHeight;\n    }\n  }, {\n    key: \"_getGroupHeight\",\n    value: function _getGroupHeight() {\n      var workspace = this.instance.getWorkSpace();\n      return workspace.getCellHeight() * workspace._getRowCount();\n    }\n  }, {\n    key: \"_getGroupTopOffset\",\n    value: function _getGroupTopOffset(appointmentSettings) {\n      var groupTop = Math.max(0, this.instance.fire(\"getGroupTop\", appointmentSettings.groupIndex));\n      var allDayPanelOffset = this.instance.fire(\"getOffsetByAllDayPanel\", appointmentSettings.groupIndex);\n      var appointmentGroupTopOffset = appointmentSettings.top - groupTop - allDayPanelOffset;\n      return appointmentGroupTopOffset;\n    }\n  }, {\n    key: \"_getTailHeight\",\n    value: function _getTailHeight(appointmentGeometry, appointmentSettings) {\n      if (!this.isVirtualScrolling) {\n        return appointmentGeometry.sourceAppointmentHeight - appointmentGeometry.reducedHeight;\n      }\n\n      var appointmentGroupTopOffset = this._getGroupTopOffset(appointmentSettings);\n\n      var sourceAppointmentHeight = appointmentGeometry.sourceAppointmentHeight;\n\n      var groupHeight = this._getGroupHeight();\n\n      var tailHeight = appointmentGroupTopOffset + sourceAppointmentHeight - groupHeight;\n      return tailHeight;\n    }\n  }, {\n    key: \"_getAppointmentParts\",\n    value: function _getAppointmentParts(appointmentGeometry, appointmentSettings) {\n      var tailHeight = this._getTailHeight(appointmentGeometry, appointmentSettings);\n\n      var width = appointmentGeometry.width;\n      var result = [];\n      var currentPartTop = Math.max(0, this.instance.fire(\"getGroupTop\", appointmentSettings.groupIndex));\n      var cellsDiff = this.instance.fire(\"isGroupedByDate\") ? this.instance.fire(\"getGroupCount\") : 1;\n      var offset = this.getDefaultCellWidth() * cellsDiff;\n      var left = appointmentSettings.left + offset;\n\n      if (tailHeight > 0) {\n        var minHeight = this.getAppointmentMinSize();\n\n        if (tailHeight < minHeight) {\n          tailHeight = minHeight;\n        }\n\n        currentPartTop += this.instance.fire(\"getOffsetByAllDayPanel\", appointmentSettings.groupIndex);\n        result.push(extend(true, {}, appointmentSettings, {\n          top: currentPartTop,\n          left: left,\n          height: tailHeight,\n          width: width,\n          appointmentReduced: \"tail\",\n          rowIndex: 0,\n          cellIndex: appointmentSettings.cellIndex + cellsDiff\n        }));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getMinuteHeight\",\n    value: function _getMinuteHeight() {\n      return this.getDefaultCellHeight() / this.instance.getAppointmentDurationInMinutes();\n    }\n  }, {\n    key: \"_getCompactLeftCoordinate\",\n    value: function _getCompactLeftCoordinate(itemLeft, index) {\n      var cellWidth = this.getDefaultCellWidth() || this.getAppointmentMinSize();\n      return itemLeft + (1 + cellWidth) * index;\n    }\n  }, {\n    key: \"_getVerticalAppointmentGeometry\",\n    value: function _getVerticalAppointmentGeometry(coordinates) {\n      var config = this._calculateVerticalGeometryConfig(coordinates);\n\n      return this._customizeVerticalCoordinates(coordinates, config.width, config.appointmentCountPerCell, config.offset);\n    }\n  }, {\n    key: \"_customizeVerticalCoordinates\",\n    value: function _customizeVerticalCoordinates(coordinates, width, appointmentCountPerCell, topOffset, isAllDay) {\n      var appointmentWidth = Math.max(width / appointmentCountPerCell, width / coordinates.count);\n      var height = coordinates.height;\n      var appointmentLeft = coordinates.left + coordinates.index * appointmentWidth;\n      var top = coordinates.top;\n\n      if (coordinates.isCompact) {\n        this._markAppointmentAsVirtual(coordinates, isAllDay);\n      }\n\n      return {\n        height: height,\n        width: appointmentWidth,\n        top: top,\n        left: appointmentLeft,\n        empty: this._isAppointmentEmpty(height, width)\n      };\n    }\n  }, {\n    key: \"_calculateVerticalGeometryConfig\",\n    value: function _calculateVerticalGeometryConfig(coordinates) {\n      var overlappingMode = this.instance.fire(\"getMaxAppointmentsPerCell\");\n\n      var offsets = this._getOffsets();\n\n      var appointmentDefaultOffset = this._getAppointmentDefaultOffset();\n\n      var appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);\n\n      var ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);\n\n      var maxWidth = this._getMaxWidth();\n\n      if (!appointmentCountPerCell) {\n        appointmentCountPerCell = coordinates.count;\n        ratio = (maxWidth - offsets.unlimited) / maxWidth;\n      }\n\n      var topOffset = (1 - ratio) * maxWidth;\n\n      if (\"auto\" === overlappingMode || isNumeric(overlappingMode)) {\n        ratio = 1;\n        maxWidth -= appointmentDefaultOffset;\n        topOffset = 0;\n      }\n\n      return {\n        width: ratio * maxWidth,\n        appointmentCountPerCell: appointmentCountPerCell,\n        offset: topOffset\n      };\n    }\n  }, {\n    key: \"_getMaxWidth\",\n    value: function _getMaxWidth() {\n      return this.getDefaultCellWidth() || this.invoke(\"getCellWidth\");\n    }\n  }, {\n    key: \"isAllDay\",\n    value: function isAllDay(appointmentData) {\n      var allDay = this.instance.fire(\"getField\", \"allDay\", appointmentData);\n\n      if (allDay) {\n        return true;\n      }\n\n      return this.instance.appointmentTakesAllDay(appointmentData);\n    }\n  }, {\n    key: \"_getAppointmentMaxWidth\",\n    value: function _getAppointmentMaxWidth() {\n      return this.getDefaultCellWidth() - this._getAppointmentDefaultOffset();\n    }\n  }, {\n    key: \"calculateAppointmentWidth\",\n    value: function calculateAppointmentWidth(appointment, position) {\n      if (!this.isAllDay(appointment)) {\n        return 0;\n      }\n\n      var startDate = dateUtils.trimTime(position.info.appointment.startDate);\n      var endDate = this.normalizeEndDateByViewEnd(appointment, position.info.appointment.endDate);\n      var cellWidth = this.getDefaultCellWidth() || this.getAppointmentMinSize();\n      var durationInHours = (endDate.getTime() - startDate.getTime()) / toMs(\"hour\");\n      var width = Math.ceil(durationInHours / 24) * cellWidth;\n      width = this.cropAppointmentWidth(width, cellWidth);\n      return width;\n    }\n  }, {\n    key: \"calculateAppointmentHeight\",\n    value: function calculateAppointmentHeight(appointment, position) {\n      if (this.isAllDay(appointment)) {\n        return 0;\n      }\n\n      var startDate = position.info.appointment.startDate;\n      var endDate = this.normalizeEndDateByViewEnd(appointment, position.info.appointment.endDate);\n      var allDay = this.instance.fire(\"getField\", \"allDay\", appointment);\n\n      var fullDuration = this._getAppointmentDurationInMs(startDate, endDate, allDay);\n\n      var durationInMinutes = this._adjustDurationByDaylightDiff(fullDuration, startDate, endDate) / toMs(\"minute\");\n\n      var height = durationInMinutes * this._getMinuteHeight();\n\n      return height;\n    }\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      return \"vertical\";\n    }\n  }, {\n    key: \"_sortCondition\",\n    value: function _sortCondition(a, b) {\n      var allDayCondition = a.allDay - b.allDay;\n      var isAllDay = a.allDay && b.allDay;\n      var condition = \"vertical\" === this.instance._groupOrientation && isAllDay ? this._columnCondition(a, b) : this._rowCondition(a, b);\n      return allDayCondition ? allDayCondition : condition;\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function hasAllDayAppointments() {\n      return true;\n    }\n  }, {\n    key: \"_getAllDayAppointmentGeometry\",\n    value: function _getAllDayAppointmentGeometry(coordinates) {\n      var config = this._calculateGeometryConfig(coordinates);\n\n      return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset, true);\n    }\n  }, {\n    key: \"_calculateGeometryConfig\",\n    value: function _calculateGeometryConfig(coordinates) {\n      if (!this.instance._allowResizing() || !this.instance._allowAllDayResizing()) {\n        coordinates.skipResizing = true;\n      }\n\n      var config = _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_calculateGeometryConfig\", this).call(this, coordinates);\n\n      if (coordinates.count <= this._getDynamicAppointmentCountPerCell().allDay) {\n        config.offset = 0;\n      }\n\n      return config;\n    }\n  }, {\n    key: \"_getAppointmentCount\",\n    value: function _getAppointmentCount(overlappingMode, coordinates) {\n      return \"auto\" !== overlappingMode && 1 === coordinates.count && !isNumeric(overlappingMode) ? coordinates.count : this._getMaxAppointmentCountPerCellByType(coordinates.allDay);\n    }\n  }, {\n    key: \"_getDefaultRatio\",\n    value: function _getDefaultRatio(coordinates, appointmentCountPerCell) {\n      return coordinates.count > this.instance.option(\"_appointmentCountPerCell\") ? .65 : 1;\n    }\n  }, {\n    key: \"_getOffsets\",\n    value: function _getOffsets() {\n      return {\n        unlimited: ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET,\n        auto: ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET\n      };\n    }\n  }, {\n    key: \"_getMaxHeight\",\n    value: function _getMaxHeight() {\n      return this.getDefaultAllDayCellHeight() || this.getAppointmentMinSize();\n    }\n  }, {\n    key: \"_needVerticalGroupBounds\",\n    value: function _needVerticalGroupBounds(allDay) {\n      return !allDay;\n    }\n  }, {\n    key: \"_needHorizontalGroupBounds\",\n    value: function _needHorizontalGroupBounds() {\n      return false;\n    }\n  }]);\n\n  return VerticalRenderingStrategy;\n}(BaseAppointmentsStrategy);\n\nexport default VerticalRenderingStrategy;","map":null,"metadata":{},"sourceType":"module"}