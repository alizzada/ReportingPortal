{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/grid_core/ui.grid_core.virtual_scrolling_core.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport { getWindow } from \"../../core/utils/window\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport browser from \"../../core/utils/browser\";\nimport positionUtils from \"../../animation/position\";\nimport { each } from \"../../core/utils/iterator\";\nimport Class from \"../../core/class\";\nimport { Deferred } from \"../../core/utils/deferred\";\nimport Callbacks from \"../../core/utils/callbacks\";\nimport { VirtualDataLoader } from \"./ui.grid.core.virtual_data_loader\";\nvar SCROLLING_MODE_INFINITE = \"infinite\";\nvar SCROLLING_MODE_VIRTUAL = \"virtual\";\nvar NEW_SCROLLING_MODE = \"scrolling.newMode\";\n\nvar _isVirtualMode = function _isVirtualMode(that) {\n  return that.option(\"scrolling.mode\") === SCROLLING_MODE_VIRTUAL || that._isVirtual;\n};\n\nvar _isAppendMode = function _isAppendMode(that) {\n  return that.option(\"scrolling.mode\") === SCROLLING_MODE_INFINITE && !that._isVirtual;\n};\n\nexport var getPixelRatio = function getPixelRatio(window) {\n  return window.devicePixelRatio || 1;\n};\nexport function getContentHeightLimit(browser) {\n  if (browser.msie) {\n    return 4e6;\n  } else if (browser.mozilla) {\n    return 8e6;\n  }\n\n  return 15e6 / getPixelRatio(getWindow());\n}\nexport function subscribeToExternalScrollers($element, scrollChangedHandler, $targetElement) {\n  var $scrollElement;\n  var scrollableArray = [];\n  var scrollToArray = [];\n  var disposeArray = [];\n  $targetElement = $targetElement || $element;\n\n  function getElementOffset(scrollable) {\n    var $scrollableElement = scrollable.element ? scrollable.$element() : scrollable;\n    var scrollableOffset = positionUtils.offset($scrollableElement);\n\n    if (!scrollableOffset) {\n      return $element.offset().top;\n    }\n\n    return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top);\n  }\n\n  var widgetScrollStrategy = {\n    on: function on(scrollable, eventName, handler) {\n      scrollable.on(\"scroll\", handler);\n    },\n    off: function off(scrollable, eventName, handler) {\n      scrollable.off(\"scroll\", handler);\n    }\n  };\n\n  function subscribeToScrollEvents($scrollElement) {\n    var isDocument = \"#document\" === $scrollElement.get(0).nodeName;\n    var scrollable = $scrollElement.data(\"dxScrollable\");\n    var eventsStrategy = widgetScrollStrategy;\n\n    if (!scrollable) {\n      scrollable = isDocument && $(getWindow()) || \"auto\" === $scrollElement.css(\"overflowY\") && $scrollElement;\n      eventsStrategy = eventsEngine;\n\n      if (!scrollable) {\n        return;\n      }\n    }\n\n    var handler = function (scrollable) {\n      return function () {\n        var scrollTop = scrollable.scrollTop() - getElementOffset(scrollable);\n        scrollTop = scrollTop > 0 ? scrollTop : 0;\n        scrollChangedHandler(scrollTop);\n      };\n    }(scrollable);\n\n    eventsStrategy.on(scrollable, \"scroll\", handler);\n    scrollToArray.push(function (pos) {\n      var topOffset = getElementOffset(scrollable);\n      var scrollMethod = scrollable.scrollTo ? \"scrollTo\" : \"scrollTop\";\n\n      if (pos - topOffset >= 0) {\n        scrollable[scrollMethod](pos + topOffset);\n      }\n    });\n    scrollableArray.push(scrollable);\n    disposeArray.push(function () {\n      eventsStrategy.off(scrollable, \"scroll\", handler);\n    });\n  }\n\n  for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = $scrollElement.parent()) {\n    subscribeToScrollEvents($scrollElement);\n  }\n\n  return {\n    scrollTo: function scrollTo(pos) {\n      each(scrollToArray, function (_, scrollTo) {\n        scrollTo(pos);\n      });\n    },\n    dispose: function dispose() {\n      each(disposeArray, function (_, dispose) {\n        dispose();\n      });\n    }\n  };\n}\nexport var VirtualScrollController = Class.inherit(function () {\n  var members = {\n    ctor: function ctor(component, dataOptions, isVirtual) {\n      this._dataOptions = dataOptions;\n      this.component = component;\n      this._viewportSize = 0;\n      this._viewportItemSize = 20;\n      this._viewportItemIndex = 0;\n      this._contentSize = 0;\n      this._itemSizes = {};\n      this._sizeRatio = 1;\n      this._isVirtual = isVirtual;\n      this.positionChanged = Callbacks();\n      this._dataLoader = new VirtualDataLoader(this, this._dataOptions);\n    },\n    getItemSizes: function getItemSizes() {\n      return this._itemSizes;\n    },\n    option: function option() {\n      return this.component.option.apply(this.component, arguments);\n    },\n    isVirtual: function isVirtual() {\n      return this._isVirtual;\n    },\n    virtualItemsCount: function virtualItemsCount() {\n      if (_isVirtualMode(this)) {\n        var totalItemsCount = this._dataOptions.totalItemsCount();\n\n        if (this.option(NEW_SCROLLING_MODE) && -1 !== totalItemsCount) {\n          var viewportParams = this.getViewportParams();\n          var endItemsCount = totalItemsCount - (viewportParams.skip + viewportParams.take);\n          return {\n            begin: viewportParams.skip,\n            end: endItemsCount\n          };\n        }\n\n        return this._dataLoader.virtualItemsCount.apply(this._dataLoader, arguments);\n      }\n    },\n    setViewportPosition: function setViewportPosition(position) {\n      var _this = this;\n\n      var result = new Deferred();\n      var scrollingTimeout = Math.min(this.option(\"scrolling.timeout\") || 0, this._dataOptions.changingDuration());\n\n      if (scrollingTimeout < this.option(\"scrolling.renderingThreshold\")) {\n        scrollingTimeout = this.option(\"scrolling.minTimeout\") || 0;\n      }\n\n      clearTimeout(this._scrollTimeoutID);\n\n      if (scrollingTimeout > 0) {\n        this._scrollTimeoutID = setTimeout(function () {\n          _this._setViewportPositionCore(position);\n\n          result.resolve();\n        }, scrollingTimeout);\n      } else {\n        this._setViewportPositionCore(position);\n\n        result.resolve();\n      }\n\n      return result.promise();\n    },\n    getViewportPosition: function getViewportPosition() {\n      return this._position || 0;\n    },\n    getItemIndexByPosition: function getItemIndexByPosition() {\n      var position = this._position;\n      var defaultItemSize = this.getItemSize();\n      var offset = 0;\n      var itemOffset = 0;\n      var itemOffsetsWithSize = Object.keys(this._itemSizes).concat(-1);\n\n      for (var i = 0; i < itemOffsetsWithSize.length && offset < position; i++) {\n        var itemOffsetWithSize = parseInt(itemOffsetsWithSize[i]);\n        var itemOffsetDiff = (position - offset) / defaultItemSize;\n\n        if (itemOffsetWithSize < 0 || itemOffset + itemOffsetDiff < itemOffsetWithSize) {\n          itemOffset += itemOffsetDiff;\n          break;\n        } else {\n          itemOffsetDiff = itemOffsetWithSize - itemOffset;\n          offset += itemOffsetDiff * defaultItemSize;\n          itemOffset += itemOffsetDiff;\n        }\n\n        var itemSize = this._itemSizes[itemOffsetWithSize];\n        offset += itemSize;\n        itemOffset += offset < position ? 1 : (position - offset + itemSize) / itemSize;\n      }\n\n      return Math.round(50 * itemOffset) / 50;\n    },\n    _setViewportPositionCore: function _setViewportPositionCore(position) {\n      this._position = position;\n      var itemIndex = this.getItemIndexByPosition();\n      var result = this.setViewportItemIndex(itemIndex);\n      this.positionChanged.fire();\n      return result;\n    },\n    setContentItemSizes: function setContentItemSizes(sizes) {\n      var _this2 = this;\n\n      var virtualItemsCount = this.virtualItemsCount();\n      this._contentSize = sizes.reduce(function (a, b) {\n        return a + b;\n      }, 0);\n\n      if (virtualItemsCount) {\n        sizes.forEach(function (size, index) {\n          _this2._itemSizes[virtualItemsCount.begin + index] = size;\n        });\n\n        var virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + this.itemsCount()) * this._viewportItemSize;\n\n        var contentHeightLimit = getContentHeightLimit(browser);\n\n        if (virtualContentSize > contentHeightLimit) {\n          this._sizeRatio = contentHeightLimit / virtualContentSize;\n        } else {\n          this._sizeRatio = 1;\n        }\n      }\n    },\n    getItemSize: function getItemSize() {\n      return this._viewportItemSize * this._sizeRatio;\n    },\n    getItemOffset: function getItemOffset(itemIndex, isEnd) {\n      var _this3 = this;\n\n      var virtualItemsCount = this.virtualItemsCount();\n      var itemCount = itemIndex;\n\n      if (!virtualItemsCount) {\n        return 0;\n      }\n\n      var offset = 0;\n\n      var totalItemsCount = this._dataOptions.totalItemsCount();\n\n      Object.keys(this._itemSizes).forEach(function (currentItemIndex) {\n        if (!itemCount) {\n          return;\n        }\n\n        if (isEnd ? currentItemIndex >= totalItemsCount - itemIndex : currentItemIndex < itemIndex) {\n          offset += _this3._itemSizes[currentItemIndex];\n          itemCount--;\n        }\n      });\n      return Math.floor(offset + itemCount * this._viewportItemSize * this._sizeRatio);\n    },\n    getContentOffset: function getContentOffset(type) {\n      var isEnd = \"end\" === type;\n      var virtualItemsCount = this.virtualItemsCount();\n\n      if (!virtualItemsCount) {\n        return 0;\n      }\n\n      return this.getItemOffset(isEnd ? virtualItemsCount.end : virtualItemsCount.begin, isEnd);\n    },\n    getVirtualContentSize: function getVirtualContentSize() {\n      var virtualItemsCount = this.virtualItemsCount();\n      return virtualItemsCount ? this.getContentOffset(\"begin\") + this.getContentOffset(\"end\") + this._contentSize : 0;\n    },\n    getViewportItemIndex: function getViewportItemIndex() {\n      return this._viewportItemIndex;\n    },\n    setViewportItemIndex: function setViewportItemIndex(itemIndex) {\n      this._viewportItemIndex = itemIndex;\n\n      if (this.option(NEW_SCROLLING_MODE)) {\n        return;\n      }\n\n      return this._dataLoader.viewportItemIndexChanged.apply(this._dataLoader, arguments);\n    },\n    viewportItemSize: function viewportItemSize(size) {\n      if (void 0 !== size) {\n        this._viewportItemSize = size;\n      }\n\n      return this._viewportItemSize;\n    },\n    viewportSize: function viewportSize(size) {\n      if (void 0 !== size) {\n        this._viewportSize = size;\n      }\n\n      return this._viewportSize;\n    },\n    reset: function reset(isRefresh) {\n      this._dataLoader.reset();\n\n      if (!isRefresh) {\n        this._itemSizes = {};\n      }\n    },\n    subscribeToWindowScrollEvents: function subscribeToWindowScrollEvents($element) {\n      var _this4 = this;\n\n      this._windowScroll = this._windowScroll || subscribeToExternalScrollers($element, function (scrollTop) {\n        if (_this4.viewportItemSize()) {\n          _this4.setViewportPosition(scrollTop);\n        }\n      });\n    },\n    dispose: function dispose() {\n      clearTimeout(this._scrollTimeoutID);\n      this._windowScroll && this._windowScroll.dispose();\n      this._windowScroll = null;\n    },\n    scrollTo: function scrollTo(pos) {\n      this._windowScroll && this._windowScroll.scrollTo(pos);\n    },\n    isVirtualMode: function isVirtualMode() {\n      return _isVirtualMode(this);\n    },\n    isAppendMode: function isAppendMode() {\n      return _isAppendMode(this);\n    },\n    getViewportParams: function getViewportParams() {\n      var topIndex = this._viewportItemIndex;\n      var bottomIndex = this._viewportSize + topIndex;\n      var maxGap = this.pageSize();\n      var minGap = this.option(\"scrolling.minGap\");\n      var skip = Math.floor(Math.max(0, topIndex - minGap) / maxGap) * maxGap;\n      var take = Math.ceil((bottomIndex + minGap) / maxGap) * maxGap - skip;\n\n      if (_isVirtualMode(this)) {\n        var remainedItems = this._dataOptions.totalItemsCount() - skip;\n        take = Math.min(take, remainedItems);\n      }\n\n      return {\n        skip: skip,\n        take: take\n      };\n    }\n  };\n  [\"pageIndex\", \"beginPageIndex\", \"endPageIndex\", \"pageSize\", \"load\", \"loadIfNeed\", \"handleDataChanged\", \"itemsCount\", \"getDelayDeferred\"].forEach(function (name) {\n    members[name] = function () {\n      return this._dataLoader[name].apply(this._dataLoader, arguments);\n    };\n  });\n  return members;\n}());","map":null,"metadata":{},"sourceType":"module"}