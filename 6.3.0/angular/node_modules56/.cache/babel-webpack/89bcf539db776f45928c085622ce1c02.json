{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/sankey/layout.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nvar _SPLINE_TENSION = .3;\nvar _ALIGNMENT_CENTER = \"center\";\nvar _ALIGNMENT_BOTTOM = \"bottom\";\nvar _ALIGNMENT_DEFAULT = _ALIGNMENT_CENTER;\nimport graphModule from \"./graph\";\nimport validatorModule from \"./data_validator\";\nexport var layout = {\n  _weightPerPixel: null,\n  _getCascadeIdx: function _getCascadeIdx(nodeTitle, cascadesConfig) {\n    var nodeInfo = cascadesConfig.filter(function (c) {\n      return c.name === nodeTitle;\n    })[0];\n\n    if (nodeInfo.outgoing.length > 0) {\n      return nodeInfo.lp;\n    } else {\n      return graphModule.routines.maxOfArray(cascadesConfig.map(function (c) {\n        return c.lp;\n      }));\n    }\n  },\n  _getInWeightForNode: function _getInWeightForNode(nodeTitle, links) {\n    var w = 0;\n    links.forEach(function (link) {\n      if (link[1] === nodeTitle) {\n        w += link[2];\n      }\n    });\n    return w;\n  },\n  _getOutWeightForNode: function _getOutWeightForNode(nodeTitle, links) {\n    var w = 0;\n    links.forEach(function (link) {\n      if (link[0] === nodeTitle) {\n        w += link[2];\n      }\n    });\n    return w;\n  },\n  _computeCascades: function _computeCascades(links) {\n    var _this = this;\n\n    var cascadesConfig = graphModule.struct.computeLongestPaths(links);\n    var maxCascade = graphModule.routines.maxOfArray(cascadesConfig.map(function (c) {\n      return c.lp;\n    }));\n    var cascades = [];\n\n    for (var i = 0; i < maxCascade + 1; i++) {\n      cascades.push({});\n    }\n\n    links.forEach(function (link) {\n      var cascade = cascades[_this._getCascadeIdx(link[0], cascadesConfig)];\n\n      if (!cascade[link[0]]) {\n        cascade[link[0]] = {\n          nodeTitle: link[0]\n        };\n      }\n\n      cascade = cascades[_this._getCascadeIdx(link[1], cascadesConfig)];\n\n      if (!cascade[link[1]]) {\n        cascade[link[1]] = {\n          nodeTitle: link[1]\n        };\n      }\n    });\n    cascades.forEach(function (cascade) {\n      Object.keys(cascade).forEach(function (nodeTitle) {\n        var node = cascade[nodeTitle];\n        node.inWeight = _this._getInWeightForNode(node.nodeTitle, links);\n        node.outWeight = _this._getOutWeightForNode(node.nodeTitle, links);\n        node.maxWeight = Math.max(node.inWeight, node.outWeight);\n      });\n    });\n    return cascades;\n  },\n  _getWeightForCascade: function _getWeightForCascade(cascades, cascadeIdx) {\n    var wMax = 0;\n    var cascade = cascades[cascadeIdx];\n    Object.keys(cascade).forEach(function (nodeTitle) {\n      wMax += Math.max(cascade[nodeTitle].inWeight, cascade[nodeTitle].outWeight);\n    });\n    return wMax;\n  },\n  _getMaxWeightThroughCascades: function _getMaxWeightThroughCascades(cascades) {\n    var max = [];\n    cascades.forEach(function (cascade) {\n      var mW = 0;\n      Object.keys(cascade).forEach(function (nodeTitle) {\n        var node = cascade[nodeTitle];\n        mW += Math.max(node.inWeight, node.outWeight);\n      });\n      max.push(mW);\n    });\n    return graphModule.routines.maxOfArray(max);\n  },\n  _computeNodes: function _computeNodes(cascades, options) {\n    var _this2 = this;\n\n    var rects = [];\n\n    var maxWeight = this._getMaxWeightThroughCascades(cascades);\n\n    var maxNodeNum = graphModule.routines.maxOfArray(cascades.map(function (nodesInCascade) {\n      return Object.keys(nodesInCascade).length;\n    }));\n    var nodePadding = options.nodePadding;\n    var heightAvailable = options.height - nodePadding * (maxNodeNum - 1);\n\n    if (heightAvailable < 0) {\n      nodePadding = 0;\n      heightAvailable = options.height - nodePadding * (maxNodeNum - 1);\n    }\n\n    this._weightPerPixel = maxWeight / heightAvailable;\n    var cascadeIdx = 0;\n    cascades.forEach(function (cascade) {\n      var cascadeRects = [];\n      var y = 0;\n      var nodesInCascade = Object.keys(cascade).length;\n      var cascadeHeight = _this2._getWeightForCascade(cascades, cascadeIdx) / _this2._weightPerPixel + nodePadding * (nodesInCascade - 1);\n      var cascadeAlign = _ALIGNMENT_DEFAULT;\n\n      if (Array.isArray(options.nodeAlign)) {\n        cascadeAlign = cascadeIdx < options.nodeAlign.length ? options.nodeAlign[cascadeIdx] : _ALIGNMENT_DEFAULT;\n      } else {\n        cascadeAlign = options.nodeAlign;\n      }\n\n      if (cascadeAlign === _ALIGNMENT_BOTTOM) {\n        y = options.height - cascadeHeight;\n      } else if (cascadeAlign === _ALIGNMENT_CENTER) {\n        y = .5 * (options.height - cascadeHeight);\n      }\n\n      y = Math.round(y);\n      Object.keys(cascade).forEach(function (nodeTitle) {\n        cascade[nodeTitle].sort = _this2._sort && Object.prototype.hasOwnProperty.call(_this2._sort, nodeTitle) ? _this2._sort[nodeTitle] : 1;\n      });\n      Object.keys(cascade).sort(function (a, b) {\n        return cascade[a].sort - cascade[b].sort;\n      }).forEach(function (nodeTitle) {\n        var node = cascade[nodeTitle];\n        var height = Math.floor(heightAvailable * node.maxWeight / maxWeight);\n        var x = Math.round(cascadeIdx * options.width / (cascades.length - 1)) - (0 === cascadeIdx ? 0 : options.nodeWidth);\n        var rect = {};\n        rect._name = nodeTitle;\n        rect.width = options.nodeWidth;\n        rect.height = height;\n        rect.x = x + options.x;\n        rect.y = y + options.y;\n        y += height + nodePadding;\n        cascadeRects.push(rect);\n      });\n      cascadeIdx++;\n      rects.push(cascadeRects);\n    });\n    return rects;\n  },\n  _findRectByName: function _findRectByName(rects, name) {\n    for (var c = 0; c < rects.length; c++) {\n      for (var r = 0; r < rects[c].length; r++) {\n        if (name === rects[c][r]._name) {\n          return rects[c][r];\n        }\n      }\n    }\n\n    return null;\n  },\n  _findIndexByName: function _findIndexByName(rects, nodeTitle) {\n    var index = 0;\n\n    for (var c = 0; c < rects.length; c++) {\n      for (var r = 0; r < rects[c].length; r++) {\n        if (nodeTitle === rects[c][r]._name) {\n          return index;\n        }\n\n        index++;\n      }\n    }\n\n    return null;\n  },\n  _computeLinks: function _computeLinks(links, rects, cascades) {\n    var _this3 = this;\n\n    var yOffsets = {};\n    var paths = [];\n    var result = [];\n    cascades.forEach(function (cascade) {\n      Object.keys(cascade).forEach(function (nodeTitle) {\n        yOffsets[nodeTitle] = {\n          in: 0,\n          out: 0\n        };\n      });\n    });\n    rects.forEach(function (rectsOfCascade) {\n      rectsOfCascade.forEach(function (nodeRect) {\n        var nodeTitle = nodeRect._name;\n\n        var rectFrom = _this3._findRectByName(rects, nodeTitle);\n\n        var linksFromNode = links.filter(function (link) {\n          return link[0] === nodeTitle;\n        });\n        linksFromNode.forEach(function (link) {\n          link.sort = _this3._findIndexByName(rects, link[1]);\n        });\n        linksFromNode.sort(function (a, b) {\n          return a.sort - b.sort;\n        }).forEach(function (link) {\n          var rectTo = _this3._findRectByName(rects, link[1]);\n\n          var height = Math.round(link[2] / _this3._weightPerPixel);\n          var yOffsetFrom = yOffsets[link[0]].out;\n          var yOffsetTo = yOffsets[link[1]].in;\n          var heightFrom = yOffsets[link[0]].out + height > rectFrom.height ? rectFrom.height - yOffsets[link[0]].out : height;\n          var heightTo = yOffsets[link[1]].in + height > rectTo.height ? rectTo.height - yOffsets[link[1]].in : height;\n          paths.push({\n            from: {\n              x: rectFrom.x,\n              y: rectFrom.y + yOffsetFrom,\n              width: rectFrom.width,\n              height: heightFrom,\n              node: rectFrom,\n              weight: link[2]\n            },\n            to: {\n              x: rectTo.x,\n              y: rectTo.y + yOffsetTo,\n              width: rectTo.width,\n              height: heightTo,\n              node: rectTo\n            }\n          });\n          yOffsets[link[0]].out += height;\n          yOffsets[link[1]].in += height;\n        });\n      });\n    });\n    paths.forEach(function (link) {\n      var path = {\n        d: _this3._spline(link.from, link.to),\n        _boundingRect: {\n          x: link.from.x + link.from.width,\n          y: Math.min(link.from.y, link.to.y),\n          width: link.to.x - (link.from.x + link.from.width),\n          height: Math.max(link.from.x + link.from.height, link.to.y + link.to.height) - Math.min(link.from.y, link.to.y)\n        },\n        _weight: link.from.weight,\n        _from: link.from.node,\n        _to: link.to.node\n      };\n      result.push(path);\n    });\n\n    this._fitAllNodesHeight(rects, paths);\n\n    return result;\n  },\n  _fitNodeHeight: function _fitNodeHeight(nodeName, nodeRects, paths) {\n    var targetRect = this._findRectByName(nodeRects, nodeName);\n\n    var heightOfLinksSummaryIn = 0;\n    var heightOfLinksSummaryOut = 0;\n    paths.forEach(function (path) {\n      if (path.from.node._name === nodeName) {\n        heightOfLinksSummaryOut += path.from.height;\n      }\n\n      if (path.to.node._name === nodeName) {\n        heightOfLinksSummaryIn += path.to.height;\n      }\n    });\n    targetRect.height = Math.max(heightOfLinksSummaryIn, heightOfLinksSummaryOut);\n  },\n  _fitAllNodesHeight: function _fitAllNodesHeight(nodeRects, paths) {\n    for (var c = 0; c < nodeRects.length; c++) {\n      for (var r = 0; r < nodeRects[c].length; r++) {\n        this._fitNodeHeight(nodeRects[c][r]._name, nodeRects, paths);\n      }\n    }\n  },\n  _spline: function _spline(rectLeft, rectRight) {\n    var p_UpLeft = {\n      x: rectLeft.x + rectLeft.width,\n      y: rectLeft.y\n    };\n    var p_DownLeft = {\n      x: rectLeft.x + rectLeft.width,\n      y: rectLeft.y + rectLeft.height\n    };\n    var p_UpRight = {\n      x: rectRight.x,\n      y: rectRight.y\n    };\n    var p_DownRight = {\n      x: rectRight.x,\n      y: rectRight.y + rectRight.height\n    };\n    var curve_width = _SPLINE_TENSION * (p_UpRight.x - p_UpLeft.x);\n    var result = \"M \".concat(p_UpLeft.x, \" \").concat(p_UpLeft.y, \" C \").concat(p_UpLeft.x + curve_width, \" \").concat(p_UpLeft.y, \" \").concat(p_UpRight.x - curve_width, \" \").concat(p_UpRight.y, \" \").concat(p_UpRight.x, \" \").concat(p_UpRight.y, \" L \").concat(p_DownRight.x, \" \").concat(p_DownRight.y, \" C \").concat(p_DownRight.x - curve_width, \" \").concat(p_DownRight.y, \" \").concat(p_DownLeft.x + curve_width, \" \").concat(p_DownLeft.y, \" \").concat(p_DownLeft.x, \" \").concat(p_DownLeft.y, \" Z\");\n    return result;\n  },\n  computeLayout: function computeLayout(linksData, sortData, options, incidentOccurred) {\n    this._sort = sortData;\n    var result = {};\n    var validateResult = validatorModule.validate(linksData, incidentOccurred);\n\n    if (!validateResult) {\n      result.cascades = this._computeCascades(linksData);\n      result.nodes = this._computeNodes(result.cascades, {\n        width: options.availableRect.width,\n        height: options.availableRect.height,\n        x: options.availableRect.x,\n        y: options.availableRect.y,\n        nodePadding: options.nodePadding,\n        nodeWidth: options.nodeWidth,\n        nodeAlign: options.nodeAlign\n      });\n      result.links = this._computeLinks(linksData, result.nodes, result.cascades);\n    } else {\n      result.error = validateResult;\n    }\n\n    return result;\n  },\n  overlap: function overlap(box1, box2) {\n    return !(box2.x > box1.x + box1.width || box2.x + box2.width < box1.x || box2.y >= box1.y + box1.height || box2.y + box2.height <= box1.y);\n  }\n};","map":{"version":3,"sources":["C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/devextreme/esm/viz/sankey/layout.js"],"names":["_SPLINE_TENSION","_ALIGNMENT_CENTER","_ALIGNMENT_BOTTOM","_ALIGNMENT_DEFAULT","graphModule","validatorModule","layout","_weightPerPixel","_getCascadeIdx","nodeTitle","cascadesConfig","nodeInfo","filter","c","name","outgoing","length","lp","routines","maxOfArray","map","_getInWeightForNode","links","w","forEach","link","_getOutWeightForNode","_computeCascades","struct","computeLongestPaths","maxCascade","cascades","i","push","cascade","Object","keys","node","inWeight","outWeight","maxWeight","Math","max","_getWeightForCascade","cascadeIdx","wMax","_getMaxWeightThroughCascades","mW","_computeNodes","options","rects","maxNodeNum","nodesInCascade","nodePadding","heightAvailable","height","cascadeRects","y","cascadeHeight","cascadeAlign","Array","isArray","nodeAlign","round","sort","_sort","prototype","hasOwnProperty","call","a","b","floor","x","width","nodeWidth","rect","_name","_findRectByName","r","_findIndexByName","index","_computeLinks","yOffsets","paths","result","in","out","rectsOfCascade","nodeRect","rectFrom","linksFromNode","rectTo","yOffsetFrom","yOffsetTo","heightFrom","heightTo","from","weight","to","path","d","_spline","_boundingRect","min","_weight","_from","_to","_fitAllNodesHeight","_fitNodeHeight","nodeName","nodeRects","targetRect","heightOfLinksSummaryIn","heightOfLinksSummaryOut","rectLeft","rectRight","p_UpLeft","p_DownLeft","p_UpRight","p_DownRight","curve_width","concat","computeLayout","linksData","sortData","incidentOccurred","validateResult","validate","nodes","availableRect","error","overlap","box1","box2"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/viz/sankey/layout.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nvar _SPLINE_TENSION = .3;\r\nvar _ALIGNMENT_CENTER = \"center\";\r\nvar _ALIGNMENT_BOTTOM = \"bottom\";\r\nvar _ALIGNMENT_DEFAULT = _ALIGNMENT_CENTER;\r\nimport graphModule from \"./graph\";\r\nimport validatorModule from \"./data_validator\";\r\nexport var layout = {\r\n    _weightPerPixel: null,\r\n    _getCascadeIdx: function(nodeTitle, cascadesConfig) {\r\n        var nodeInfo = cascadesConfig.filter(c => c.name === nodeTitle)[0];\r\n        if (nodeInfo.outgoing.length > 0) {\r\n            return nodeInfo.lp\r\n        } else {\r\n            return graphModule.routines.maxOfArray(cascadesConfig.map(c => c.lp))\r\n        }\r\n    },\r\n    _getInWeightForNode: function(nodeTitle, links) {\r\n        var w = 0;\r\n        links.forEach(link => {\r\n            if (link[1] === nodeTitle) {\r\n                w += link[2]\r\n            }\r\n        });\r\n        return w\r\n    },\r\n    _getOutWeightForNode: function(nodeTitle, links) {\r\n        var w = 0;\r\n        links.forEach(link => {\r\n            if (link[0] === nodeTitle) {\r\n                w += link[2]\r\n            }\r\n        });\r\n        return w\r\n    },\r\n    _computeCascades: function(links) {\r\n        var cascadesConfig = graphModule.struct.computeLongestPaths(links);\r\n        var maxCascade = graphModule.routines.maxOfArray(cascadesConfig.map(c => c.lp));\r\n        var cascades = [];\r\n        for (var i = 0; i < maxCascade + 1; i++) {\r\n            cascades.push({})\r\n        }\r\n        links.forEach(link => {\r\n            var cascade = cascades[this._getCascadeIdx(link[0], cascadesConfig)];\r\n            if (!cascade[link[0]]) {\r\n                cascade[link[0]] = {\r\n                    nodeTitle: link[0]\r\n                }\r\n            }\r\n            cascade = cascades[this._getCascadeIdx(link[1], cascadesConfig)];\r\n            if (!cascade[link[1]]) {\r\n                cascade[link[1]] = {\r\n                    nodeTitle: link[1]\r\n                }\r\n            }\r\n        });\r\n        cascades.forEach(cascade => {\r\n            Object.keys(cascade).forEach(nodeTitle => {\r\n                var node = cascade[nodeTitle];\r\n                node.inWeight = this._getInWeightForNode(node.nodeTitle, links);\r\n                node.outWeight = this._getOutWeightForNode(node.nodeTitle, links);\r\n                node.maxWeight = Math.max(node.inWeight, node.outWeight)\r\n            })\r\n        });\r\n        return cascades\r\n    },\r\n    _getWeightForCascade: function(cascades, cascadeIdx) {\r\n        var wMax = 0;\r\n        var cascade = cascades[cascadeIdx];\r\n        Object.keys(cascade).forEach(nodeTitle => {\r\n            wMax += Math.max(cascade[nodeTitle].inWeight, cascade[nodeTitle].outWeight)\r\n        });\r\n        return wMax\r\n    },\r\n    _getMaxWeightThroughCascades: function(cascades) {\r\n        var max = [];\r\n        cascades.forEach(cascade => {\r\n            var mW = 0;\r\n            Object.keys(cascade).forEach(nodeTitle => {\r\n                var node = cascade[nodeTitle];\r\n                mW += Math.max(node.inWeight, node.outWeight)\r\n            });\r\n            max.push(mW)\r\n        });\r\n        return graphModule.routines.maxOfArray(max)\r\n    },\r\n    _computeNodes: function(cascades, options) {\r\n        var rects = [];\r\n        var maxWeight = this._getMaxWeightThroughCascades(cascades);\r\n        var maxNodeNum = graphModule.routines.maxOfArray(cascades.map(nodesInCascade => Object.keys(nodesInCascade).length));\r\n        var nodePadding = options.nodePadding;\r\n        var heightAvailable = options.height - nodePadding * (maxNodeNum - 1);\r\n        if (heightAvailable < 0) {\r\n            nodePadding = 0;\r\n            heightAvailable = options.height - nodePadding * (maxNodeNum - 1)\r\n        }\r\n        this._weightPerPixel = maxWeight / heightAvailable;\r\n        var cascadeIdx = 0;\r\n        cascades.forEach(cascade => {\r\n            var cascadeRects = [];\r\n            var y = 0;\r\n            var nodesInCascade = Object.keys(cascade).length;\r\n            var cascadeHeight = this._getWeightForCascade(cascades, cascadeIdx) / this._weightPerPixel + nodePadding * (nodesInCascade - 1);\r\n            var cascadeAlign = _ALIGNMENT_DEFAULT;\r\n            if (Array.isArray(options.nodeAlign)) {\r\n                cascadeAlign = cascadeIdx < options.nodeAlign.length ? options.nodeAlign[cascadeIdx] : _ALIGNMENT_DEFAULT\r\n            } else {\r\n                cascadeAlign = options.nodeAlign\r\n            }\r\n            if (cascadeAlign === _ALIGNMENT_BOTTOM) {\r\n                y = options.height - cascadeHeight\r\n            } else if (cascadeAlign === _ALIGNMENT_CENTER) {\r\n                y = .5 * (options.height - cascadeHeight)\r\n            }\r\n            y = Math.round(y);\r\n            Object.keys(cascade).forEach(nodeTitle => {\r\n                cascade[nodeTitle].sort = this._sort && Object.prototype.hasOwnProperty.call(this._sort, nodeTitle) ? this._sort[nodeTitle] : 1\r\n            });\r\n            Object.keys(cascade).sort((a, b) => cascade[a].sort - cascade[b].sort).forEach(nodeTitle => {\r\n                var node = cascade[nodeTitle];\r\n                var height = Math.floor(heightAvailable * node.maxWeight / maxWeight);\r\n                var x = Math.round(cascadeIdx * options.width / (cascades.length - 1)) - (0 === cascadeIdx ? 0 : options.nodeWidth);\r\n                var rect = {};\r\n                rect._name = nodeTitle;\r\n                rect.width = options.nodeWidth;\r\n                rect.height = height;\r\n                rect.x = x + options.x;\r\n                rect.y = y + options.y;\r\n                y += height + nodePadding;\r\n                cascadeRects.push(rect)\r\n            });\r\n            cascadeIdx++;\r\n            rects.push(cascadeRects)\r\n        });\r\n        return rects\r\n    },\r\n    _findRectByName: function(rects, name) {\r\n        for (var c = 0; c < rects.length; c++) {\r\n            for (var r = 0; r < rects[c].length; r++) {\r\n                if (name === rects[c][r]._name) {\r\n                    return rects[c][r]\r\n                }\r\n            }\r\n        }\r\n        return null\r\n    },\r\n    _findIndexByName: function(rects, nodeTitle) {\r\n        var index = 0;\r\n        for (var c = 0; c < rects.length; c++) {\r\n            for (var r = 0; r < rects[c].length; r++) {\r\n                if (nodeTitle === rects[c][r]._name) {\r\n                    return index\r\n                }\r\n                index++\r\n            }\r\n        }\r\n        return null\r\n    },\r\n    _computeLinks: function(links, rects, cascades) {\r\n        var yOffsets = {};\r\n        var paths = [];\r\n        var result = [];\r\n        cascades.forEach(cascade => {\r\n            Object.keys(cascade).forEach(nodeTitle => {\r\n                yOffsets[nodeTitle] = {\r\n                    in: 0,\r\n                    out: 0\r\n                }\r\n            })\r\n        });\r\n        rects.forEach(rectsOfCascade => {\r\n            rectsOfCascade.forEach(nodeRect => {\r\n                var nodeTitle = nodeRect._name;\r\n                var rectFrom = this._findRectByName(rects, nodeTitle);\r\n                var linksFromNode = links.filter(link => link[0] === nodeTitle);\r\n                linksFromNode.forEach(link => {\r\n                    link.sort = this._findIndexByName(rects, link[1])\r\n                });\r\n                linksFromNode.sort((a, b) => a.sort - b.sort).forEach(link => {\r\n                    var rectTo = this._findRectByName(rects, link[1]);\r\n                    var height = Math.round(link[2] / this._weightPerPixel);\r\n                    var yOffsetFrom = yOffsets[link[0]].out;\r\n                    var yOffsetTo = yOffsets[link[1]].in;\r\n                    var heightFrom = yOffsets[link[0]].out + height > rectFrom.height ? rectFrom.height - yOffsets[link[0]].out : height;\r\n                    var heightTo = yOffsets[link[1]].in + height > rectTo.height ? rectTo.height - yOffsets[link[1]].in : height;\r\n                    paths.push({\r\n                        from: {\r\n                            x: rectFrom.x,\r\n                            y: rectFrom.y + yOffsetFrom,\r\n                            width: rectFrom.width,\r\n                            height: heightFrom,\r\n                            node: rectFrom,\r\n                            weight: link[2]\r\n                        },\r\n                        to: {\r\n                            x: rectTo.x,\r\n                            y: rectTo.y + yOffsetTo,\r\n                            width: rectTo.width,\r\n                            height: heightTo,\r\n                            node: rectTo\r\n                        }\r\n                    });\r\n                    yOffsets[link[0]].out += height;\r\n                    yOffsets[link[1]].in += height\r\n                })\r\n            })\r\n        });\r\n        paths.forEach(link => {\r\n            var path = {\r\n                d: this._spline(link.from, link.to),\r\n                _boundingRect: {\r\n                    x: link.from.x + link.from.width,\r\n                    y: Math.min(link.from.y, link.to.y),\r\n                    width: link.to.x - (link.from.x + link.from.width),\r\n                    height: Math.max(link.from.x + link.from.height, link.to.y + link.to.height) - Math.min(link.from.y, link.to.y)\r\n                },\r\n                _weight: link.from.weight,\r\n                _from: link.from.node,\r\n                _to: link.to.node\r\n            };\r\n            result.push(path)\r\n        });\r\n        this._fitAllNodesHeight(rects, paths);\r\n        return result\r\n    },\r\n    _fitNodeHeight: function(nodeName, nodeRects, paths) {\r\n        var targetRect = this._findRectByName(nodeRects, nodeName);\r\n        var heightOfLinksSummaryIn = 0;\r\n        var heightOfLinksSummaryOut = 0;\r\n        paths.forEach((function(path) {\r\n            if (path.from.node._name === nodeName) {\r\n                heightOfLinksSummaryOut += path.from.height\r\n            }\r\n            if (path.to.node._name === nodeName) {\r\n                heightOfLinksSummaryIn += path.to.height\r\n            }\r\n        }));\r\n        targetRect.height = Math.max(heightOfLinksSummaryIn, heightOfLinksSummaryOut)\r\n    },\r\n    _fitAllNodesHeight: function(nodeRects, paths) {\r\n        for (var c = 0; c < nodeRects.length; c++) {\r\n            for (var r = 0; r < nodeRects[c].length; r++) {\r\n                this._fitNodeHeight(nodeRects[c][r]._name, nodeRects, paths)\r\n            }\r\n        }\r\n    },\r\n    _spline: function(rectLeft, rectRight) {\r\n        var p_UpLeft = {\r\n            x: rectLeft.x + rectLeft.width,\r\n            y: rectLeft.y\r\n        };\r\n        var p_DownLeft = {\r\n            x: rectLeft.x + rectLeft.width,\r\n            y: rectLeft.y + rectLeft.height\r\n        };\r\n        var p_UpRight = {\r\n            x: rectRight.x,\r\n            y: rectRight.y\r\n        };\r\n        var p_DownRight = {\r\n            x: rectRight.x,\r\n            y: rectRight.y + rectRight.height\r\n        };\r\n        var curve_width = _SPLINE_TENSION * (p_UpRight.x - p_UpLeft.x);\r\n        var result = \"M \".concat(p_UpLeft.x, \" \").concat(p_UpLeft.y, \" C \").concat(p_UpLeft.x + curve_width, \" \").concat(p_UpLeft.y, \" \").concat(p_UpRight.x - curve_width, \" \").concat(p_UpRight.y, \" \").concat(p_UpRight.x, \" \").concat(p_UpRight.y, \" L \").concat(p_DownRight.x, \" \").concat(p_DownRight.y, \" C \").concat(p_DownRight.x - curve_width, \" \").concat(p_DownRight.y, \" \").concat(p_DownLeft.x + curve_width, \" \").concat(p_DownLeft.y, \" \").concat(p_DownLeft.x, \" \").concat(p_DownLeft.y, \" Z\");\r\n        return result\r\n    },\r\n    computeLayout: function(linksData, sortData, options, incidentOccurred) {\r\n        this._sort = sortData;\r\n        var result = {};\r\n        var validateResult = validatorModule.validate(linksData, incidentOccurred);\r\n        if (!validateResult) {\r\n            result.cascades = this._computeCascades(linksData);\r\n            result.nodes = this._computeNodes(result.cascades, {\r\n                width: options.availableRect.width,\r\n                height: options.availableRect.height,\r\n                x: options.availableRect.x,\r\n                y: options.availableRect.y,\r\n                nodePadding: options.nodePadding,\r\n                nodeWidth: options.nodeWidth,\r\n                nodeAlign: options.nodeAlign\r\n            });\r\n            result.links = this._computeLinks(linksData, result.nodes, result.cascades)\r\n        } else {\r\n            result.error = validateResult\r\n        }\r\n        return result\r\n    },\r\n    overlap: function(box1, box2) {\r\n        return !(box2.x > box1.x + box1.width || box2.x + box2.width < box1.x || box2.y >= box1.y + box1.height || box2.y + box2.height <= box1.y)\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}