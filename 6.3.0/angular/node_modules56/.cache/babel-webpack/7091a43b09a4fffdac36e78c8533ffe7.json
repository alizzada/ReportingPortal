{"ast":null,"code":"import _get from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.virtual_scrolling.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport domAdapter from \"../../../core/dom_adapter\";\nimport eventsEngine from \"../../../events/core/events_engine\";\nimport { getWindow } from \"../../../core/utils/window\";\nimport { addNamespace } from \"../../../events/utils/index\";\nimport { isDefined } from \"../../../core/utils/type\";\nvar DEFAULT_CELL_HEIGHT = 50;\nvar MIN_CELL_WIDTH = 1;\nvar MIN_SCROLL_OFFSET = 10;\nvar VIRTUAL_APPOINTMENTS_RENDER_TIMEOUT = 15;\nvar DOCUMENT_SCROLL_EVENT_NAMESPACE = addNamespace(\"scroll\", \"dxSchedulerVirtualScrolling\");\nvar scrollingOrientations = {\n  vertical: \"vertical\",\n  horizontal: \"horizontal\",\n  both: \"both\"\n};\nvar DefaultScrollingOrientation = scrollingOrientations.both;\n\nvar VirtualScrollingDispatcher = /*#__PURE__*/function () {\n  function VirtualScrollingDispatcher(workspace) {\n    _classCallCheck(this, VirtualScrollingDispatcher);\n\n    this._workspace = workspace;\n    this._rowHeight = this.getCellHeight();\n    this._cellWidth = this.getCellWidth();\n    this._renderer = new Renderer(this.workspace);\n\n    this._createVirtualScrolling();\n\n    this._attachScrollableEvents();\n  }\n\n  _createClass(VirtualScrollingDispatcher, [{\n    key: \"workspace\",\n    get: function get() {\n      return this._workspace;\n    }\n  }, {\n    key: \"isRTL\",\n    get: function get() {\n      return this.workspace._isRTL();\n    }\n  }, {\n    key: \"renderer\",\n    get: function get() {\n      return this._renderer;\n    }\n  }, {\n    key: \"isVirtualScrolling\",\n    get: function get() {\n      return this.workspace.isVirtualScrolling();\n    }\n  }, {\n    key: \"verticalVirtualScrolling\",\n    get: function get() {\n      return this._verticalVirtualScrolling;\n    },\n    set: function set(value) {\n      this._verticalVirtualScrolling = value;\n    }\n  }, {\n    key: \"horizontalVirtualScrolling\",\n    get: function get() {\n      return this._horizontalVirtualScrolling;\n    },\n    set: function set(value) {\n      this._horizontalVirtualScrolling = value;\n    }\n  }, {\n    key: \"document\",\n    get: function get() {\n      return domAdapter.getDocument();\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.workspace.invoke(\"getOption\", \"height\");\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.workspace.invoke(\"getOption\", \"width\");\n    }\n  }, {\n    key: \"rowHeight\",\n    get: function get() {\n      return this._rowHeight;\n    },\n    set: function set(value) {\n      this._rowHeight = value;\n    }\n  }, {\n    key: \"viewportHeight\",\n    get: function get() {\n      return this.height ? this.workspace.$element().height() : getWindow().innerHeight;\n    }\n  }, {\n    key: \"cellWidth\",\n    get: function get() {\n      return this._cellWidth;\n    },\n    set: function set(value) {\n      this._cellWidth = value;\n    }\n  }, {\n    key: \"viewportWidth\",\n    get: function get() {\n      return this.width ? this.workspace.$element().width() : getWindow().innerWidth;\n    }\n  }, {\n    key: \"topVirtualRowsCount\",\n    get: function get() {\n      var _this$verticalScrolli;\n\n      return (null === (_this$verticalScrolli = this.verticalScrollingState) || void 0 === _this$verticalScrolli ? void 0 : _this$verticalScrolli.virtualItemCountBefore) > 0 ? 1 : 0;\n    }\n  }, {\n    key: \"leftVirtualCellsCount\",\n    get: function get() {\n      var _this$horizontalScrol, _this$horizontalScrol2;\n\n      var virtualItemsCount = !this.isRTL ? null === (_this$horizontalScrol = this.horizontalScrollingState) || void 0 === _this$horizontalScrol ? void 0 : _this$horizontalScrol.virtualItemCountBefore : null === (_this$horizontalScrol2 = this.horizontalScrollingState) || void 0 === _this$horizontalScrol2 ? void 0 : _this$horizontalScrol2.virtualItemCountAfter;\n      return virtualItemsCount > 0 ? 1 : 0;\n    }\n  }, {\n    key: \"virtualRowOffset\",\n    get: function get() {\n      var _this$verticalScrolli2;\n\n      return (null === (_this$verticalScrolli2 = this.verticalScrollingState) || void 0 === _this$verticalScrolli2 ? void 0 : _this$verticalScrolli2.virtualItemSizeBefore) || 0;\n    }\n  }, {\n    key: \"virtualCellOffset\",\n    get: function get() {\n      var _this$horizontalScrol3;\n\n      return (null === (_this$horizontalScrol3 = this.horizontalScrollingState) || void 0 === _this$horizontalScrol3 ? void 0 : _this$horizontalScrol3.virtualItemSizeBefore) || 0;\n    }\n  }, {\n    key: \"scrollingState\",\n    get: function get() {\n      var _this$verticalVirtual, _this$horizontalVirtu;\n\n      return {\n        vertical: null === (_this$verticalVirtual = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual ? void 0 : _this$verticalVirtual.state,\n        horizontal: null === (_this$horizontalVirtu = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu ? void 0 : _this$horizontalVirtu.state\n      };\n    }\n  }, {\n    key: \"verticalScrollingState\",\n    get: function get() {\n      return this.scrollingState.vertical;\n    }\n  }, {\n    key: \"horizontalScrollingState\",\n    get: function get() {\n      return this.scrollingState.horizontal;\n    }\n  }, {\n    key: \"scrollingOrientation\",\n    get: function get() {\n      return this.workspace.option(\"scrolling.orientation\") || DefaultScrollingOrientation;\n    }\n  }, {\n    key: \"verticalScrollingAllowed\",\n    get: function get() {\n      return this.scrollingOrientation === scrollingOrientations.vertical || this.scrollingOrientation === scrollingOrientations.both;\n    }\n  }, {\n    key: \"horizontalScrollingAllowed\",\n    get: function get() {\n      return this.scrollingOrientation === scrollingOrientations.horizontal || this.scrollingOrientation === scrollingOrientations.both;\n    }\n  }, {\n    key: \"getRenderState\",\n    value: function getRenderState() {\n      var _this$verticalVirtual2, _this$horizontalVirtu2;\n\n      var verticalRenderState = (null === (_this$verticalVirtual2 = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual2 ? void 0 : _this$verticalVirtual2.getRenderState()) || {};\n      var horizontalRenderState = (null === (_this$horizontalVirtu2 = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu2 ? void 0 : _this$horizontalVirtu2.getRenderState()) || {};\n      return _extends({}, verticalRenderState, horizontalRenderState);\n    }\n  }, {\n    key: \"getCellHeight\",\n    value: function getCellHeight() {\n      var cellHeight = this.workspace.getCellHeight(false);\n      var result = cellHeight > 0 ? cellHeight : DEFAULT_CELL_HEIGHT;\n      return Math.floor(result);\n    }\n  }, {\n    key: \"getCellWidth\",\n    value: function getCellWidth() {\n      var cellWidth = this.workspace.getCellWidth();\n      var minCellWidth = this.workspace.getCellMinWidth();\n\n      if (!cellWidth || cellWidth < minCellWidth) {\n        cellWidth = minCellWidth;\n      }\n\n      var result = cellWidth > 0 ? cellWidth : MIN_CELL_WIDTH;\n      return Math.floor(result);\n    }\n  }, {\n    key: \"calculateCoordinatesByDataAndPosition\",\n    value: function calculateCoordinatesByDataAndPosition(cellData, position, date, isCalculateTime, isVerticalDirectionView) {\n      var workSpace = this._workspace;\n      var rowIndex = position.rowIndex,\n          columnIndex = position.columnIndex;\n      var startDate = cellData.startDate,\n          endDate = cellData.endDate,\n          allDay = cellData.allDay;\n      var timeToScroll = date.getTime();\n      var cellStartTime = startDate.getTime();\n      var cellEndTime = endDate.getTime();\n      var scrollInCell = allDay || !isCalculateTime ? 0 : (timeToScroll - cellStartTime) / (cellEndTime - cellStartTime);\n      var cellWidth = this.getCellWidth();\n      var rowHeight = this.getCellHeight();\n      var top = isVerticalDirectionView ? (rowIndex + scrollInCell) * rowHeight : rowIndex * rowHeight;\n      var left = isVerticalDirectionView ? columnIndex * cellWidth : (columnIndex + scrollInCell) * cellWidth;\n\n      if (workSpace.option(\"rtlEnabled\")) {\n        left = workSpace.getScrollableOuterWidth() - left;\n      }\n\n      return {\n        top: top,\n        left: left\n      };\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this._onScrollHandler) {\n        eventsEngine.off(this.document, DOCUMENT_SCROLL_EVENT_NAMESPACE, this._onScrollHandler);\n      }\n    }\n  }, {\n    key: \"_createVirtualScrolling\",\n    value: function _createVirtualScrolling() {\n      if (this.verticalScrollingAllowed) {\n        this.verticalVirtualScrolling = new VerticalVirtualScrolling({\n          workspace: this.workspace,\n          viewportHeight: this.viewportHeight,\n          rowHeight: this.rowHeight\n        });\n      }\n\n      if (this.horizontalScrollingAllowed) {\n        this.horizontalVirtualScrolling = new HorizontalVirtualScrolling({\n          workspace: this.workspace,\n          viewportWidth: this.viewportWidth,\n          cellWidth: this.cellWidth\n        });\n      }\n    }\n  }, {\n    key: \"_attachScrollableEvents\",\n    value: function _attachScrollableEvents() {\n      if (this.horizontalScrollingAllowed || this.verticalScrollingAllowed) {\n        if (this.height || this.horizontalScrollingAllowed) {\n          this._attachScrollableScroll();\n        }\n\n        if (!this.height) {\n          this._attachWindowScroll();\n        }\n      }\n    }\n  }, {\n    key: \"_attachScrollableScroll\",\n    value: function _attachScrollableScroll() {\n      var _this = this;\n\n      var scrollable = this.workspace.getScrollable();\n      var currentOnScroll = scrollable.option(\"onScroll\");\n      scrollable.option(\"onScroll\", function (e) {\n        null === currentOnScroll || void 0 === currentOnScroll ? void 0 : currentOnScroll.apply(scrollable, [e]);\n\n        _this._process(null === e || void 0 === e ? void 0 : e.scrollOffset);\n      });\n    }\n  }, {\n    key: \"_attachWindowScroll\",\n    value: function _attachWindowScroll() {\n      var _this2 = this;\n\n      var window = getWindow();\n      this._onScrollHandler = this.workspace._createAction(function () {\n        var scrollX = window.scrollX,\n            scrollY = window.scrollY;\n\n        if (scrollX >= MIN_SCROLL_OFFSET || scrollY >= MIN_SCROLL_OFFSET) {\n          _this2._process({\n            left: scrollX,\n            top: scrollY\n          });\n        }\n      });\n      eventsEngine.on(this.document, DOCUMENT_SCROLL_EVENT_NAMESPACE, this._onScrollHandler);\n    }\n  }, {\n    key: \"_process\",\n    value: function _process(scrollPosition) {\n      if (scrollPosition) {\n        var _this$verticalVirtual3, _this$horizontalVirtu3;\n\n        var left = scrollPosition.left,\n            top = scrollPosition.top;\n        var verticalStateChanged = isDefined(top) && (null === (_this$verticalVirtual3 = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual3 ? void 0 : _this$verticalVirtual3.updateState(top));\n        var horizontalStateChanged = isDefined(left) && (null === (_this$horizontalVirtu3 = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu3 ? void 0 : _this$horizontalVirtu3.updateState(left));\n\n        if (verticalStateChanged || horizontalStateChanged) {\n          this.renderer.updateRender();\n        }\n      }\n    }\n  }, {\n    key: \"updateDimensions\",\n    value: function updateDimensions(isForce) {\n      var cellHeight = this.getCellHeight(false);\n      var needUpdateVertical = this.verticalScrollingAllowed && cellHeight !== this.rowHeight;\n\n      if (needUpdateVertical || isForce) {\n        var _this$verticalVirtual4;\n\n        this.rowHeight = cellHeight;\n        null === (_this$verticalVirtual4 = this.verticalVirtualScrolling) || void 0 === _this$verticalVirtual4 ? void 0 : _this$verticalVirtual4.reinitState(cellHeight, isForce);\n      }\n\n      var cellWidth = this.getCellWidth();\n      var needUpdateHorizontal = this.horizontalScrollingAllowed && cellWidth !== this.cellWidth;\n\n      if (needUpdateHorizontal || isForce) {\n        var _this$horizontalVirtu4;\n\n        this.cellWidth = cellWidth;\n        null === (_this$horizontalVirtu4 = this.horizontalVirtualScrolling) || void 0 === _this$horizontalVirtu4 ? void 0 : _this$horizontalVirtu4.reinitState(cellWidth, isForce);\n      }\n\n      if (needUpdateVertical || needUpdateHorizontal) {\n        this.renderer._renderGrid();\n      }\n    }\n  }]);\n\n  return VirtualScrollingDispatcher;\n}();\n\nexport { VirtualScrollingDispatcher as default };\n\nvar VirtualScrollingBase = /*#__PURE__*/function () {\n  function VirtualScrollingBase(options) {\n    _classCallCheck(this, VirtualScrollingBase);\n\n    this._workspace = options.workspace;\n    this._state = this.defaultState;\n    this._viewportSize = options.viewportSize;\n    this._itemSize = options.itemSize;\n    this._position = -1;\n    this._itemSizeChanged = false;\n    this.updateState(0);\n  }\n\n  _createClass(VirtualScrollingBase, [{\n    key: \"viewportSize\",\n    get: function get() {\n      return this._viewportSize;\n    }\n  }, {\n    key: \"itemSize\",\n    get: function get() {\n      return this._itemSize;\n    },\n    set: function set(value) {\n      this._itemSizeChanged = this._itemSize !== value;\n      this._itemSize = value;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    },\n    set: function set(value) {\n      this._state = value;\n    }\n  }, {\n    key: \"startIndex\",\n    get: function get() {\n      return this.state.startIndex;\n    }\n  }, {\n    key: \"pageSize\",\n    get: function get() {\n      return Math.ceil(this.viewportSize / this.itemSize);\n    }\n  }, {\n    key: \"outlineCount\",\n    get: function get() {\n      return Math.floor(this.pageSize / 2);\n    }\n  }, {\n    key: \"workspace\",\n    get: function get() {\n      return this._workspace;\n    }\n  }, {\n    key: \"groupCount\",\n    get: function get() {\n      return this.workspace._getGroupCount();\n    }\n  }, {\n    key: \"isVerticalGrouping\",\n    get: function get() {\n      return this.workspace._isVerticalGroupedWorkSpace();\n    }\n  }, {\n    key: \"defaultState\",\n    get: function get() {\n      return {\n        prevPosition: 0,\n        startIndex: -1,\n        itemCount: 0,\n        virtualItemCountBefore: 0,\n        virtualItemCountAfter: 0,\n        outlineCountBefore: 0,\n        outlineCountAfter: 0,\n        virtualItemSizeBefore: 0,\n        virtualItemSizeAfter: 0,\n        outlineSizeBefore: 0,\n        outlineSizeAfter: 0\n      };\n    }\n  }, {\n    key: \"maxScrollPosition\",\n    get: function get() {\n      return this.getTotalItemCount() * this.itemSize - this.viewportSize;\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this._position;\n    },\n    set: function set(value) {\n      this._position = value;\n    }\n  }, {\n    key: \"needUpdateState\",\n    value: function needUpdateState(position) {\n      var _this$state = this.state,\n          prevPosition = _this$state.prevPosition,\n          startIndex = _this$state.startIndex;\n      var isFirstInitialization = startIndex < 0;\n\n      if (isFirstInitialization) {\n        return true;\n      }\n\n      var isStartIndexChanged = false;\n\n      if (this._validateAndSavePosition(position)) {\n        if (0 === position || position === this.maxScrollPosition) {\n          return true;\n        }\n\n        var currentPosition = prevPosition;\n        var currentItemsCount = Math.floor(currentPosition / this.itemSize);\n        var itemsCount = Math.floor(position / this.itemSize);\n        isStartIndexChanged = Math.abs(currentItemsCount - itemsCount) >= this.outlineCount;\n      }\n\n      return isStartIndexChanged;\n    }\n  }, {\n    key: \"_validateAndSavePosition\",\n    value: function _validateAndSavePosition(position) {\n      if (!isDefined(position)) {\n        return false;\n      }\n\n      var result = this.position !== position;\n      this.position = position;\n      return result;\n    }\n  }, {\n    key: \"_correctPosition\",\n    value: function _correctPosition(position) {\n      return position >= 0 ? Math.min(position, this.maxScrollPosition) : -1;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(position, isForce) {\n      position = this._correctPosition(position);\n\n      if (!this.needUpdateState(position) && !isForce) {\n        return false;\n      }\n\n      var itemsInfoBefore = this._calcItemInfoBefore(position);\n\n      var itemsDeltaBefore = this._calcItemDeltaBefore(itemsInfoBefore);\n\n      var _this$_calcItemInfoAf = this._calcItemInfoAfter(itemsDeltaBefore),\n          outlineCountAfter = _this$_calcItemInfoAf.outlineCountAfter,\n          virtualItemCountAfter = _this$_calcItemInfoAf.virtualItemCountAfter,\n          itemCountWithAfter = _this$_calcItemInfoAf.itemCountWithAfter;\n\n      var virtualItemCountBefore = itemsInfoBefore.virtualItemCountBefore,\n          outlineCountBefore = itemsInfoBefore.outlineCountBefore;\n      var itemCount = outlineCountBefore + itemCountWithAfter + outlineCountAfter;\n      var itemCountBefore = Math.floor(position / this.itemSize);\n      this.state.prevPosition = itemCountBefore * this.itemSize;\n      this.state.startIndex = itemCountBefore - outlineCountBefore;\n      this.state.virtualItemCountBefore = virtualItemCountBefore;\n      this.state.outlineCountBefore = outlineCountBefore;\n      this.state.itemCount = itemCount;\n      this.state.outlineCountAfter = outlineCountAfter;\n      this.state.virtualItemCountAfter = virtualItemCountAfter;\n\n      this._updateStateCore();\n\n      return true;\n    }\n  }, {\n    key: \"reinitState\",\n    value: function reinitState(itemSize, isForceUpdate) {\n      var position = this.position;\n      this.itemSize = itemSize;\n      this.updateState(0, isForceUpdate);\n\n      if (position > 0) {\n        this.updateState(position, isForceUpdate);\n      }\n    }\n  }, {\n    key: \"_calcItemInfoBefore\",\n    value: function _calcItemInfoBefore(position) {\n      var virtualItemCountBefore = Math.floor(position / this.itemSize);\n      var outlineCountBefore = Math.min(virtualItemCountBefore, this.outlineCount);\n      virtualItemCountBefore -= outlineCountBefore;\n      return {\n        virtualItemCountBefore: virtualItemCountBefore,\n        outlineCountBefore: outlineCountBefore\n      };\n    }\n  }, {\n    key: \"_calcItemDeltaBefore\",\n    value: function _calcItemDeltaBefore(itemInfoBefore) {\n      var virtualItemCountBefore = itemInfoBefore.virtualItemCountBefore,\n          outlineCountBefore = itemInfoBefore.outlineCountBefore;\n      var totalItemCount = this.getTotalItemCount();\n      return totalItemCount - virtualItemCountBefore - outlineCountBefore;\n    }\n  }, {\n    key: \"getTotalItemCount\",\n    value: function getTotalItemCount() {\n      throw \"getTotalItemCount method should be implemented\";\n    }\n  }, {\n    key: \"getRenderState\",\n    value: function getRenderState() {\n      throw \"getRenderState method should be implemented\";\n    }\n  }, {\n    key: \"_calcItemInfoAfter\",\n    value: function _calcItemInfoAfter(itemsDeltaBefore) {\n      var itemCountWithAfter = itemsDeltaBefore >= this.pageSize ? this.pageSize : itemsDeltaBefore;\n      var virtualItemCountAfter = itemsDeltaBefore - itemCountWithAfter;\n      var outlineCountAfter = virtualItemCountAfter > 0 ? Math.min(virtualItemCountAfter, this.outlineCount) : 0;\n\n      if (virtualItemCountAfter > 0) {\n        virtualItemCountAfter -= outlineCountAfter;\n      }\n\n      return {\n        virtualItemCountAfter: virtualItemCountAfter,\n        outlineCountAfter: outlineCountAfter,\n        itemCountWithAfter: itemCountWithAfter\n      };\n    }\n  }, {\n    key: \"_updateStateCore\",\n    value: function _updateStateCore() {\n      var state = this.state;\n      var virtualItemCountBefore = state.virtualItemCountBefore;\n      var virtualItemCountAfter = state.virtualItemCountAfter;\n      var outlineCountBefore = state.outlineCountBefore;\n      var outlineCountAfter = state.outlineCountAfter;\n      var prevVirtualItemSizeBefore = state.virtualItemSizeBefore;\n      var prevVirtualItemSizeAfter = state.virtualItemSizeAfter;\n      var prevOutlineSizeBefore = state.outlineSizeBefore;\n      var prevOutlineSizeAfter = state.outlineSizeAfter;\n      var virtualItemSizeBefore = this.itemSize * virtualItemCountBefore;\n      var virtualItemSizeAfter = this.itemSize * virtualItemCountAfter;\n      var outlineSizeBefore = this.itemSize * outlineCountBefore;\n      var outlineSizeAfter = this.itemSize * outlineCountAfter;\n      var prevVirtualSizeBefore = prevVirtualItemSizeBefore + prevOutlineSizeBefore;\n      var virtualSizeBefore = virtualItemSizeBefore + outlineSizeBefore;\n      var prevVirtualSizeAfter = prevVirtualItemSizeAfter + prevOutlineSizeAfter;\n      var virtualSizeAfter = virtualItemSizeAfter + outlineSizeAfter;\n      var isAppend = prevVirtualSizeBefore < virtualSizeBefore;\n      var isPrepend = prevVirtualSizeAfter < virtualSizeAfter;\n      var needAddItems = this._itemSizeChanged || isAppend || isPrepend;\n\n      if (needAddItems) {\n        this._updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter);\n      }\n    }\n  }, {\n    key: \"_updateStateVirtualItems\",\n    value: function _updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter) {\n      var state = this.state;\n      state.virtualItemSizeBefore = virtualItemSizeBefore;\n      state.virtualItemSizeAfter = virtualItemSizeAfter;\n    }\n  }]);\n\n  return VirtualScrollingBase;\n}();\n\nvar VerticalVirtualScrolling = /*#__PURE__*/function (_VirtualScrollingBase) {\n  _inherits(VerticalVirtualScrolling, _VirtualScrollingBase);\n\n  var _super = _createSuper(VerticalVirtualScrolling);\n\n  function VerticalVirtualScrolling(options) {\n    _classCallCheck(this, VerticalVirtualScrolling);\n\n    return _super.call(this, {\n      workspace: options.workspace,\n      viewportSize: options.viewportHeight,\n      itemSize: options.rowHeight\n    });\n  }\n\n  _createClass(VerticalVirtualScrolling, [{\n    key: \"prevTopPosition\",\n    get: function get() {\n      return this.state.prevPosition;\n    }\n  }, {\n    key: \"rowCount\",\n    get: function get() {\n      return this.state.itemCount;\n    }\n  }, {\n    key: \"topVirtualRowCount\",\n    get: function get() {\n      return this.state.virtualItemCountBefore;\n    }\n  }, {\n    key: \"bottomVirtualRowCount\",\n    get: function get() {\n      return this.state.virtualItemCountAfter;\n    }\n  }, {\n    key: \"getTotalItemCount\",\n    value: function getTotalItemCount() {\n      return this.workspace._getTotalRowCount(this.groupCount, this.isVerticalGrouping);\n    }\n  }, {\n    key: \"getRenderState\",\n    value: function getRenderState() {\n      return {\n        topVirtualRowHeight: this.state.virtualItemSizeBefore,\n        bottomVirtualRowHeight: this.state.virtualItemSizeAfter,\n        startRowIndex: this.state.startIndex,\n        rowCount: this.state.itemCount,\n        startIndex: this.state.startIndex\n      };\n    }\n  }]);\n\n  return VerticalVirtualScrolling;\n}(VirtualScrollingBase);\n\nvar HorizontalVirtualScrolling = /*#__PURE__*/function (_VirtualScrollingBase2) {\n  _inherits(HorizontalVirtualScrolling, _VirtualScrollingBase2);\n\n  var _super2 = _createSuper(HorizontalVirtualScrolling);\n\n  function HorizontalVirtualScrolling(options) {\n    _classCallCheck(this, HorizontalVirtualScrolling);\n\n    return _super2.call(this, {\n      workspace: options.workspace,\n      viewportSize: options.viewportWidth,\n      itemSize: options.cellWidth\n    });\n  }\n\n  _createClass(HorizontalVirtualScrolling, [{\n    key: \"isRTL\",\n    get: function get() {\n      return this.workspace._isRTL();\n    }\n  }, {\n    key: \"getTotalItemCount\",\n    value: function getTotalItemCount() {\n      return this.workspace._getTotalCellCount(this.groupCount, this.isVerticalGrouping);\n    }\n  }, {\n    key: \"getRenderState\",\n    value: function getRenderState() {\n      return {\n        leftVirtualCellWidth: this.state.virtualItemSizeBefore,\n        rightVirtualCellWidth: this.state.virtualItemSizeAfter,\n        startCellIndex: this.state.startIndex,\n        cellCount: this.state.itemCount,\n        cellWidth: this.itemSize\n      };\n    }\n  }, {\n    key: \"_updateStateVirtualItems\",\n    value: function _updateStateVirtualItems(virtualItemSizeBefore, virtualItemSizeAfter) {\n      if (!this.isRTL) {\n        _get(_getPrototypeOf(HorizontalVirtualScrolling.prototype), \"_updateStateVirtualItems\", this).call(this, virtualItemSizeBefore, virtualItemSizeAfter);\n      } else {\n        var state = this.state;\n        state.virtualItemSizeAfter = virtualItemSizeBefore;\n        state.virtualItemSizeBefore = virtualItemSizeAfter;\n        state.startIndex = this.getTotalItemCount() - this.startIndex - this.state.itemCount;\n      }\n    }\n  }]);\n\n  return HorizontalVirtualScrolling;\n}(VirtualScrollingBase);\n\nvar Renderer = /*#__PURE__*/function () {\n  function Renderer(workspace) {\n    _classCallCheck(this, Renderer);\n\n    this._workspace = workspace;\n    this._renderAppointmentTimeout = null;\n  }\n\n  _createClass(Renderer, [{\n    key: \"getRenderTimeout\",\n    value: function getRenderTimeout() {\n      return VIRTUAL_APPOINTMENTS_RENDER_TIMEOUT;\n    }\n  }, {\n    key: \"workspace\",\n    get: function get() {\n      return this._workspace;\n    }\n  }, {\n    key: \"updateRender\",\n    value: function updateRender() {\n      this._renderGrid();\n\n      this._renderAppointments();\n    }\n  }, {\n    key: \"_renderGrid\",\n    value: function _renderGrid() {\n      this.workspace.renderRWorkspace(false);\n    }\n  }, {\n    key: \"_renderAppointments\",\n    value: function _renderAppointments() {\n      var _this3 = this;\n\n      var renderTimeout = this.getRenderTimeout();\n\n      if (renderTimeout >= 0) {\n        clearTimeout(this._renderAppointmentTimeout);\n        this._renderAppointmentTimeout = setTimeout(function () {\n          return _this3.workspace.updateAppointments();\n        }, renderTimeout);\n      } else {\n        this.workspace.updateAppointments();\n      }\n    }\n  }]);\n\n  return Renderer;\n}();","map":null,"metadata":{},"sourceType":"module"}