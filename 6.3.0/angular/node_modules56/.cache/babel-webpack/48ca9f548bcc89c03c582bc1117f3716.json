{"ast":null,"code":"import _toConsumableArray from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_data_provider.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { HORIZONTAL_GROUP_ORIENTATION } from \"../constants\";\n\nvar ViewDataGenerator = /*#__PURE__*/function () {\n  function ViewDataGenerator(workspace) {\n    _classCallCheck(this, ViewDataGenerator);\n\n    this.workspace = workspace;\n  }\n\n  _createClass(ViewDataGenerator, [{\n    key: \"workspace\",\n    get: function get() {\n      return this._workspace;\n    },\n    set: function set(value) {\n      this._workspace = value;\n    }\n  }, {\n    key: \"isVerticalGroupedWorkspace\",\n    get: function get() {\n      return this.workspace._isVerticalGroupedWorkSpace();\n    }\n  }, {\n    key: \"isStandaloneAllDayPanel\",\n    get: function get() {\n      return !this.isVerticalGroupedWorkspace && this.workspace.isAllDayPanelVisible;\n    }\n  }, {\n    key: \"_getCompleteViewDataMap\",\n    value: function _getCompleteViewDataMap(options) {\n      var _viewDataMap;\n\n      var rowCountInGroup = options.rowCountInGroup,\n          cellCountInGroupRow = options.cellCountInGroupRow,\n          groupsList = options.groupsList,\n          groupByDate = options.groupByDate,\n          isHorizontalGrouping = options.isHorizontalGrouping,\n          isVerticalGrouping = options.isVerticalGrouping,\n          totalCellCount = options.totalCellCount,\n          groupCount = options.groupCount;\n      var viewDataMap = [];\n      var step = groupByDate ? groupCount : 1;\n\n      var allDayPanelData = this._generateAllDayPanelData(options, cellCountInGroupRow, step);\n\n      var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, step);\n\n      allDayPanelData && viewDataMap.push(allDayPanelData);\n\n      (_viewDataMap = viewDataMap).push.apply(_viewDataMap, _toConsumableArray(viewCellsData));\n\n      if (isHorizontalGrouping && !groupByDate) {\n        viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList);\n      }\n\n      if (isVerticalGrouping) {\n        viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList);\n      }\n\n      if (groupByDate) {\n        viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList);\n      }\n\n      var completeViewDataMap = this._addKeysToCells(viewDataMap, totalCellCount);\n\n      return completeViewDataMap;\n    }\n  }, {\n    key: \"_transformViewDataMapForHorizontalGrouping\",\n    value: function _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\n      var result = viewDataMap.map(function (row) {\n        return row.slice();\n      });\n      groupsList.slice(1).forEach(function (groups, index) {\n        var groupIndex = index + 1;\n        viewDataMap.forEach(function (row, rowIndex) {\n          var _result$rowIndex;\n\n          var nextGroupRow = row.map(function (cellData) {\n            return _extends({}, cellData, {\n              groups: groups,\n              groupIndex: groupIndex\n            });\n          });\n\n          (_result$rowIndex = result[rowIndex]).push.apply(_result$rowIndex, _toConsumableArray(nextGroupRow));\n        });\n      });\n      return result;\n    }\n  }, {\n    key: \"_transformViewDataMapForVerticalGrouping\",\n    value: function _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\n      var result = viewDataMap.map(function (row) {\n        return row.slice();\n      });\n      groupsList.slice(1).forEach(function (groups, index) {\n        var groupIndex = index + 1;\n        var nextGroupMap = viewDataMap.map(function (cellsRow) {\n          var nextRow = cellsRow.map(function (cellData) {\n            return _extends({}, cellData, {\n              groupIndex: groupIndex,\n              groups: groups\n            });\n          });\n          return nextRow;\n        });\n        result.push.apply(result, _toConsumableArray(nextGroupMap));\n      });\n      return result;\n    }\n  }, {\n    key: \"_transformViewDataMapForGroupingByDate\",\n    value: function _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\n      var correctedGroupList = groupsList.slice(1);\n      var correctedGroupCount = correctedGroupList.length;\n      var result = viewDataMap.map(function (cellsRow) {\n        var groupedByDateCellsRow = cellsRow.reduce(function (currentRow, cell) {\n          var rowWithCurrentCell = [].concat(_toConsumableArray(currentRow), [_extends({}, cell, {\n            isFirstGroupCell: true,\n            isLastGroupCell: 0 === correctedGroupCount\n          })], _toConsumableArray(correctedGroupList.map(function (groups, index) {\n            return _extends({}, cell, {\n              groups: groups,\n              groupIndex: index + 1,\n              isFirstGroupCell: false,\n              isLastGroupCell: index === correctedGroupCount - 1\n            });\n          })));\n          return rowWithCurrentCell;\n        }, []);\n        return groupedByDateCellsRow;\n      });\n      return result;\n    }\n  }, {\n    key: \"_addKeysToCells\",\n    value: function _addKeysToCells(viewDataMap, totalColumnCount) {\n      var _viewDataMap$reduce = viewDataMap.reduce(function (_ref, row, rowIndex) {\n        var allDayPanelsCount = _ref.allDayPanelsCount,\n            currentViewDataMap = _ref.currentViewDataMap;\n        var isAllDay = row[0].allDay;\n        var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\n        var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\n        currentViewDataMap[rowIndex].forEach(function (cell, cellIndex) {\n          cell.key = keyBase + cellIndex;\n        });\n        return {\n          allDayPanelsCount: currentAllDayPanelsCount,\n          currentViewDataMap: currentViewDataMap\n        };\n      }, {\n        allDayPanelsCount: 0,\n        currentViewDataMap: viewDataMap\n      }),\n          result = _viewDataMap$reduce.currentViewDataMap;\n\n      return result;\n    }\n  }, {\n    key: \"_getCompleteDateHeaderMap\",\n    value: function _getCompleteDateHeaderMap(options, completeViewDataMap) {\n      var isGenerateWeekDaysHeaderData = options.isGenerateWeekDaysHeaderData;\n      var result = [];\n\n      if (isGenerateWeekDaysHeaderData) {\n        var weekDaysRow = this._generateWeekDaysHeaderRowMap(options, completeViewDataMap);\n\n        result.push(weekDaysRow);\n      }\n\n      var dateRow = this._generateHeaderDateRow(options, completeViewDataMap);\n\n      result.push(dateRow);\n      return result;\n    }\n  }, {\n    key: \"_generateWeekDaysHeaderRowMap\",\n    value: function _generateWeekDaysHeaderRowMap(options, completeViewDataMap) {\n      var groupByDate = options.groupByDate,\n          horizontalGroupCount = options.horizontalGroupCount,\n          cellCountInDay = options.cellCountInDay,\n          getWeekDaysHeaderText = options.getWeekDaysHeaderText,\n          daysInView = options.daysInView;\n      var index = completeViewDataMap[0][0].allDay ? 1 : 0;\n      var colSpan = groupByDate ? horizontalGroupCount * cellCountInDay : cellCountInDay;\n      var weekDaysRow = [];\n\n      for (var dayIndex = 0; dayIndex < daysInView; dayIndex += 1) {\n        var cell = completeViewDataMap[index][dayIndex * cellCountInDay];\n        weekDaysRow.push(_extends({}, cell, {\n          colSpan: colSpan,\n          text: getWeekDaysHeaderText(cell.startDate),\n          isFirstGroupCell: false,\n          isLastGroupCell: false\n        }));\n      }\n\n      return weekDaysRow;\n    }\n  }, {\n    key: \"_generateHeaderDateRow\",\n    value: function _generateHeaderDateRow(options, completeViewDataMap) {\n      var getDateHeaderText = options.getDateHeaderText,\n          today = options.today,\n          groupByDate = options.groupByDate,\n          horizontalGroupCount = options.horizontalGroupCount,\n          cellCountInGroupRow = options.cellCountInGroupRow,\n          groupOrientation = options.groupOrientation,\n          getDateHeaderDate = options.getDateHeaderDate;\n      var dates = [];\n\n      for (var dateIndex = 0; dateIndex < cellCountInGroupRow; dateIndex += 1) {\n        dates.push(getDateHeaderDate(dateIndex));\n      }\n\n      var index = completeViewDataMap[0][0].allDay ? 1 : 0;\n      var columnCount = completeViewDataMap[index].length;\n      var dateHeaderColumnCount = groupByDate ? columnCount / horizontalGroupCount : columnCount;\n      var colSpan = groupByDate ? horizontalGroupCount : 1;\n      var isVerticalGrouping = \"vertical\" === groupOrientation;\n      var slicedByColumnsData = completeViewDataMap[index].slice(0, dateHeaderColumnCount);\n      return slicedByColumnsData.map(function (_ref2, index) {\n        var startDate = _ref2.startDate,\n            isFirstGroupCell = _ref2.isFirstGroupCell,\n            isLastGroupCell = _ref2.isLastGroupCell,\n            restProps = _objectWithoutPropertiesLoose(_ref2, [\"startDate\", \"endDate\", \"isFirstGroupCell\", \"isLastGroupCell\"]);\n\n        return _extends({}, restProps, {\n          startDate: dates[index % cellCountInGroupRow],\n          text: getDateHeaderText(index % cellCountInGroupRow),\n          today: dateUtils.sameDate(startDate, today),\n          colSpan: colSpan,\n          isFirstGroupCell: groupByDate || isFirstGroupCell && !isVerticalGrouping,\n          isLastGroupCell: groupByDate || isLastGroupCell && !isVerticalGrouping\n        });\n      });\n    }\n  }, {\n    key: \"_getCompleteTimePanelMap\",\n    value: function _getCompleteTimePanelMap(options, completeViewDataMap) {\n      var rowCountInGroup = options.rowCountInGroup,\n          getTimeCellDate = options.getTimeCellDate;\n      var times = [];\n\n      for (var rowIndex = 0; rowIndex < rowCountInGroup; rowIndex += 1) {\n        times.push(getTimeCellDate(rowIndex));\n      }\n\n      var allDayRowsCount = 0;\n      return completeViewDataMap.map(function (row, index) {\n        var _row$ = row[0],\n            allDay = _row$.allDay,\n            startDate = _row$.startDate,\n            restCellProps = _objectWithoutPropertiesLoose(_row$, [\"allDay\", \"startDate\", \"endDate\"]);\n\n        if (allDay) {\n          allDayRowsCount += 1;\n        }\n\n        var timeIndex = (index - allDayRowsCount) % rowCountInGroup;\n        return _extends({}, restCellProps, {\n          allDay: allDay,\n          startDate: allDay ? startDate : times[timeIndex]\n        });\n      });\n    }\n  }, {\n    key: \"_generateViewDataMap\",\n    value: function _generateViewDataMap(completeViewDataMap, options) {\n      var rowCount = options.rowCount,\n          startCellIndex = options.startCellIndex,\n          cellCount = options.cellCount;\n      var startRowIndex = options.startRowIndex;\n\n      var sliceCells = function sliceCells(row, rowIndex, startIndex, count) {\n        return row.slice(startIndex, startIndex + count).map(function (cellData, cellIndex) {\n          return {\n            cellData: cellData,\n            position: {\n              rowIndex: rowIndex,\n              cellIndex: cellIndex\n            }\n          };\n        });\n      };\n\n      var correctedStartRowIndex = startRowIndex;\n      var allDayPanelMap = [];\n\n      if (this.isStandaloneAllDayPanel) {\n        correctedStartRowIndex++;\n        allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount);\n      }\n\n      var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount).map(function (row, rowIndex) {\n        return sliceCells(row, rowIndex, startCellIndex, cellCount);\n      });\n      return {\n        allDayPanelMap: allDayPanelMap,\n        dateTableMap: dateTableMap\n      };\n    }\n  }, {\n    key: \"_generateDateHeaderData\",\n    value: function _generateDateHeaderData(completeDateHeaderMap, options) {\n      var isGenerateWeekDaysHeaderData = options.isGenerateWeekDaysHeaderData,\n          cellCountInDay = options.cellCountInDay,\n          cellWidth = options.cellWidth,\n          isProvideVirtualCellsWidth = options.isProvideVirtualCellsWidth;\n      var dataMap = [];\n      var weekDayRowConfig = {};\n      var validCellWidth = cellWidth || 0;\n\n      if (isGenerateWeekDaysHeaderData) {\n        weekDayRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, cellCountInDay, 0, validCellWidth);\n        dataMap.push(weekDayRowConfig.dateRow);\n      }\n\n      var datesRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, 1, isGenerateWeekDaysHeaderData ? 1 : 0, validCellWidth);\n\n      dataMap.push(datesRowConfig.dateRow);\n      return {\n        dataMap: dataMap,\n        leftVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.leftVirtualCellWidth : void 0,\n        rightVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.rightVirtualCellWidth : void 0,\n        leftVirtualCellCount: datesRowConfig.leftVirtualCellCount,\n        rightVirtualCellCount: datesRowConfig.rightVirtualCellCount,\n        weekDayLeftVirtualCellWidth: weekDayRowConfig.leftVirtualCellWidth,\n        weekDayRightVirtualCellWidth: weekDayRowConfig.rightVirtualCellWidth,\n        weekDayLeftVirtualCellCount: weekDayRowConfig.leftVirtualCellCount,\n        weekDayRightVirtualCellCount: weekDayRowConfig.rightVirtualCellCount\n      };\n    }\n  }, {\n    key: \"_generateDateHeaderDataRow\",\n    value: function _generateDateHeaderDataRow(options, completeDateHeaderMap, baseColSpan, rowIndex, cellWidth) {\n      var groupByDate = options.groupByDate,\n          horizontalGroupCount = options.horizontalGroupCount,\n          startCellIndex = options.startCellIndex,\n          cellCount = options.cellCount,\n          totalCellCount = options.totalCellCount,\n          isProvideVirtualCellsWidth = options.isProvideVirtualCellsWidth;\n      var colSpan = groupByDate ? horizontalGroupCount * baseColSpan : baseColSpan;\n      var leftVirtualCellCount = Math.floor(startCellIndex / colSpan);\n      var actualCellCount = Math.ceil((startCellIndex + cellCount) / colSpan);\n      var dateRow = completeDateHeaderMap[rowIndex].slice(leftVirtualCellCount, actualCellCount);\n      var finalLeftVirtualCellCount = leftVirtualCellCount * colSpan;\n      var finalLeftVirtualCellWidth = finalLeftVirtualCellCount * cellWidth;\n      var finalRightVirtualCellCount = totalCellCount - actualCellCount * colSpan;\n      var finalRightVirtualCellWidth = finalRightVirtualCellCount * cellWidth;\n      return {\n        dateRow: dateRow,\n        leftVirtualCellCount: finalLeftVirtualCellCount,\n        leftVirtualCellWidth: isProvideVirtualCellsWidth ? finalLeftVirtualCellWidth : void 0,\n        rightVirtualCellCount: finalRightVirtualCellCount,\n        rightVirtualCellWidth: isProvideVirtualCellsWidth ? finalRightVirtualCellWidth : void 0\n      };\n    }\n  }, {\n    key: \"_generateTimePanelData\",\n    value: function _generateTimePanelData(completeTimePanelMap, options) {\n      var startRowIndex = options.startRowIndex,\n          rowCount = options.rowCount,\n          topVirtualRowHeight = options.topVirtualRowHeight,\n          bottomVirtualRowHeight = options.bottomVirtualRowHeight,\n          cellCountInGroupRow = options.cellCountInGroupRow;\n      var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();\n      var showAllDayPanel = this.workspace.isAllDayPanelVisible;\n      var indexDifference = this.isVerticalGroupedWorkspace || !showAllDayPanel ? 0 : 1;\n      var correctedStartRowIndex = startRowIndex + indexDifference;\n      var timePanelMap = completeTimePanelMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount);\n      var timePanelData = {\n        topVirtualRowHeight: topVirtualRowHeight,\n        bottomVirtualRowHeight: bottomVirtualRowHeight,\n        isGroupedAllDayPanel: isGroupedAllDayPanel,\n        cellCountInGroupRow: cellCountInGroupRow\n      };\n\n      var _this$_generateTimePa = this._generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel),\n          groupedData = _this$_generateTimePa.previousGroupedData;\n\n      timePanelData.groupedData = groupedData;\n      return timePanelData;\n    }\n  }, {\n    key: \"_generateTimePanelDataFromMap\",\n    value: function _generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel) {\n      return timePanelMap.reduce(function (_ref3, cellData) {\n        var previousGroupIndex = _ref3.previousGroupIndex,\n            previousGroupedData = _ref3.previousGroupedData;\n        var currentGroupIndex = cellData.groupIndex;\n\n        if (currentGroupIndex !== previousGroupIndex) {\n          previousGroupedData.push({\n            dateTable: [],\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\n            groupIndex: currentGroupIndex\n          });\n        }\n\n        if (cellData.allDay) {\n          previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellData;\n        } else {\n          previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellData);\n        }\n\n        return {\n          previousGroupIndex: currentGroupIndex,\n          previousGroupedData: previousGroupedData\n        };\n      }, {\n        previousGroupIndex: -1,\n        previousGroupedData: []\n      });\n    }\n  }, {\n    key: \"_getViewDataFromMap\",\n    value: function _getViewDataFromMap(viewDataMap, options) {\n      var topVirtualRowHeight = options.topVirtualRowHeight,\n          bottomVirtualRowHeight = options.bottomVirtualRowHeight,\n          leftVirtualCellWidth = options.leftVirtualCellWidth,\n          rightVirtualCellWidth = options.rightVirtualCellWidth,\n          cellCountInGroupRow = options.cellCountInGroupRow,\n          totalCellCount = options.totalCellCount,\n          totalRowCount = options.totalRowCount,\n          cellCount = options.cellCount,\n          rowCount = options.rowCount,\n          startRowIndex = options.startRowIndex,\n          startCellIndex = options.startCellIndex,\n          isProvideVirtualCellsWidth = options.isProvideVirtualCellsWidth;\n      var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();\n      var allDayPanelMap = viewDataMap.allDayPanelMap,\n          dateTableMap = viewDataMap.dateTableMap;\n\n      var _dateTableMap$reduce = dateTableMap.reduce(function (_ref4, cellsRow) {\n        var previousGroupIndex = _ref4.previousGroupIndex,\n            previousGroupedData = _ref4.previousGroupedData;\n        var cellDataRow = cellsRow.map(function (_ref5) {\n          var cellData = _ref5.cellData;\n          return cellData;\n        });\n        var firstCell = cellDataRow[0];\n        var isAllDayRow = firstCell.allDay;\n        var currentGroupIndex = firstCell.groupIndex;\n\n        if (currentGroupIndex !== previousGroupIndex) {\n          previousGroupedData.push({\n            dateTable: [],\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\n            groupIndex: currentGroupIndex\n          });\n        }\n\n        if (isAllDayRow) {\n          previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellDataRow;\n        } else {\n          previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellDataRow);\n        }\n\n        return {\n          previousGroupedData: previousGroupedData,\n          previousGroupIndex: currentGroupIndex\n        };\n      }, {\n        previousGroupIndex: -1,\n        previousGroupedData: []\n      }),\n          groupedData = _dateTableMap$reduce.previousGroupedData;\n\n      if (this.isStandaloneAllDayPanel) {\n        groupedData[0].allDayPanel = allDayPanelMap.map(function (_ref6) {\n          var cellData = _ref6.cellData;\n          return cellData;\n        });\n      }\n\n      return {\n        groupedData: groupedData,\n        topVirtualRowHeight: topVirtualRowHeight,\n        bottomVirtualRowHeight: bottomVirtualRowHeight,\n        leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\n        rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\n        cellCountInGroupRow: cellCountInGroupRow,\n        isGroupedAllDayPanel: isGroupedAllDayPanel,\n        leftVirtualCellCount: startCellIndex,\n        rightVirtualCellCount: totalCellCount - startCellIndex - cellCount,\n        topVirtualRowCount: startRowIndex,\n        bottomVirtualRowCount: totalRowCount - startRowIndex - rowCount\n      };\n    }\n  }, {\n    key: \"_generateViewCellsData\",\n    value: function _generateViewCellsData(options, rowsCount) {\n      var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n      var cellCountInGroupRow = options.cellCountInGroupRow,\n          cellDataGetters = options.cellDataGetters;\n      var viewCellsData = [];\n\n      for (var rowIndex = 0; rowIndex < rowsCount; rowIndex += 1) {\n        viewCellsData.push(this._generateCellsRow(options, cellDataGetters, rowIndex, cellCountInGroupRow, step));\n      }\n\n      return viewCellsData;\n    }\n  }, {\n    key: \"_generateAllDayPanelData\",\n    value: function _generateAllDayPanelData(options, cellCount) {\n      var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n      var workSpace = this.workspace;\n\n      if (!workSpace.isAllDayPanelVisible) {\n        return null;\n      }\n\n      return this._generateCellsRow(options, [workSpace._getAllDayCellData.bind(workSpace)], 0, cellCount, step);\n    }\n  }, {\n    key: \"_generateCellsRow\",\n    value: function _generateCellsRow(options, cellDataGetters, rowIndex, columnCount, step) {\n      var _this = this;\n\n      var cellsRow = [];\n\n      var _loop = function _loop(columnIndex) {\n        var correctedColumnIndex = step * columnIndex;\n        var cellDataValue = cellDataGetters.reduce(function (data, getter) {\n          return _extends({}, data, getter(void 0, rowIndex, correctedColumnIndex, 0, data.startDate).value);\n        }, {});\n        cellDataValue.index = rowIndex * columnCount + columnIndex;\n        cellDataValue.isFirstGroupCell = _this._isFirstGroupCell(rowIndex, columnIndex, options);\n        cellDataValue.isLastGroupCell = _this._isLastGroupCell(rowIndex, columnIndex, options);\n        cellsRow.push(cellDataValue);\n      };\n\n      for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\n        _loop(columnIndex);\n      }\n\n      return cellsRow;\n    }\n  }, {\n    key: \"_calculateCellIndex\",\n    value: function _calculateCellIndex(horizontalGroupCount, groupOrientation, isGroupedByDate, rowIndex, columnIndex, columnsNumber) {\n      var groupCount = horizontalGroupCount || 1;\n      var index = rowIndex * columnsNumber + columnIndex;\n      var columnsInGroup = columnsNumber / groupCount;\n\n      if (\"horizontal\" === groupOrientation) {\n        var columnIndexInCurrentGroup = columnIndex % columnsInGroup;\n\n        if (isGroupedByDate) {\n          columnIndexInCurrentGroup = Math.floor(columnIndex / groupCount);\n        }\n\n        index = rowIndex * columnsInGroup + columnIndexInCurrentGroup;\n      }\n\n      return index;\n    }\n  }, {\n    key: \"generateGroupedDataMap\",\n    value: function generateGroupedDataMap(viewDataMap) {\n      var allDayPanelMap = viewDataMap.allDayPanelMap,\n          dateTableMap = viewDataMap.dateTableMap;\n\n      var _dateTableMap$reduce2 = dateTableMap.reduce(function (previousOptions, cellsRow) {\n        var previousGroupedDataMap = previousOptions.previousGroupedDataMap,\n            previousRowIndex = previousOptions.previousRowIndex,\n            previousGroupIndex = previousOptions.previousGroupIndex;\n        var currentGroupIndex = cellsRow[0].cellData.groupIndex;\n        var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\n        cellsRow.forEach(function (cell) {\n          var groupIndex = cell.cellData.groupIndex;\n\n          if (!previousGroupedDataMap[groupIndex]) {\n            previousGroupedDataMap[groupIndex] = [];\n          }\n\n          if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\n            previousGroupedDataMap[groupIndex][currentRowIndex] = [];\n          }\n\n          previousGroupedDataMap[groupIndex][currentRowIndex].push(cell);\n        });\n        return {\n          previousGroupedDataMap: previousGroupedDataMap,\n          previousRowIndex: currentRowIndex,\n          previousGroupIndex: currentGroupIndex\n        };\n      }, {\n        previousGroupedDataMap: [],\n        previousRowIndex: -1,\n        previousGroupIndex: -1\n      }),\n          dateTableGroupedMap = _dateTableMap$reduce2.previousGroupedDataMap;\n\n      var allDayPanelGroupedMap = [];\n      null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(function (cell) {\n        var groupIndex = cell.cellData.groupIndex;\n\n        if (!allDayPanelGroupedMap[groupIndex]) {\n          allDayPanelGroupedMap[groupIndex] = [];\n        }\n\n        allDayPanelGroupedMap[groupIndex].push(cell);\n      });\n      return {\n        allDayPanelGroupedMap: allDayPanelGroupedMap,\n        dateTableGroupedMap: dateTableGroupedMap\n      };\n    }\n  }, {\n    key: \"_isFirstGroupCell\",\n    value: function _isFirstGroupCell(rowIndex, columnIndex, options) {\n      var groupOrientation = options.groupOrientation,\n          rowCountInGroup = options.rowCountInGroup,\n          cellCountInGroupRow = options.cellCountInGroupRow,\n          groupCount = options.groupCount;\n\n      if (this.workspace.isGroupedByDate()) {\n        return columnIndex % groupCount === 0;\n      }\n\n      if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n        return columnIndex % cellCountInGroupRow === 0;\n      }\n\n      return rowIndex % rowCountInGroup === 0;\n    }\n  }, {\n    key: \"_isLastGroupCell\",\n    value: function _isLastGroupCell(rowIndex, columnIndex, options) {\n      var groupOrientation = options.groupOrientation,\n          rowCountInGroup = options.rowCountInGroup,\n          cellCountInGroupRow = options.cellCountInGroupRow,\n          groupCount = options.groupCount;\n\n      if (this.workspace.isGroupedByDate()) {\n        return (columnIndex + 1) % groupCount === 0;\n      }\n\n      if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n        return (columnIndex + 1) % cellCountInGroupRow === 0;\n      }\n\n      return (rowIndex + 1) % rowCountInGroup === 0;\n    }\n  }]);\n\n  return ViewDataGenerator;\n}();\n\nvar GroupedDataMapProvider = /*#__PURE__*/function () {\n  function GroupedDataMapProvider(viewDataGenerator, viewDataMap, completeViewDataMap, workspace) {\n    _classCallCheck(this, GroupedDataMapProvider);\n\n    this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);\n    this.completeViewDataMap = completeViewDataMap;\n    this._workspace = workspace;\n  }\n\n  _createClass(GroupedDataMapProvider, [{\n    key: \"getGroupStartDate\",\n    value: function getGroupStartDate(groupIndex) {\n      var firstRow = this.getFirstGroupRow(groupIndex);\n\n      if (firstRow) {\n        var startDate = firstRow[0].cellData.startDate;\n        return startDate;\n      }\n    }\n  }, {\n    key: \"getGroupEndDate\",\n    value: function getGroupEndDate(groupIndex) {\n      var lastRow = this.getLastGroupRow(groupIndex);\n\n      if (lastRow) {\n        var lastCellIndex = lastRow.length - 1;\n        var cellData = lastRow[lastCellIndex].cellData;\n        var endDate = cellData.endDate;\n        return endDate;\n      }\n    }\n  }, {\n    key: \"findGroupCellStartDate\",\n    value: function findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {\n      if (isAllDay) {\n        return this.findAllDayGroupCellStartDate(groupIndex, startDate);\n      }\n\n      var groupData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n      var checkCellStartDate = function checkCellStartDate(rowIndex, cellIndex) {\n        var cellData = groupData[rowIndex][cellIndex].cellData;\n        var secondMin = cellData.startDate,\n            secondMax = cellData.endDate;\n\n        if (dateUtils.intervalsOverlap({\n          firstMin: startDate,\n          firstMax: endDate,\n          secondMin: secondMin,\n          secondMax: secondMax\n        })) {\n          return secondMin;\n        }\n      };\n\n      var startDateVerticalSearch = function () {\n        var cellCount = groupData[0].length;\n\n        for (var cellIndex = 0; cellIndex < cellCount; ++cellIndex) {\n          for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n            var result = checkCellStartDate(rowIndex, cellIndex);\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }();\n\n      var startDateHorizontalSearch = function () {\n        for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n          var row = groupData[rowIndex];\n\n          for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {\n            var result = checkCellStartDate(rowIndex, cellIndex);\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }();\n\n      return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch;\n    }\n  }, {\n    key: \"findAllDayGroupCellStartDate\",\n    value: function findAllDayGroupCellStartDate(groupIndex, startDate) {\n      var groupStartDate = this.getGroupStartDate(groupIndex);\n      return groupStartDate > startDate ? groupStartDate : startDate;\n    }\n  }, {\n    key: \"findCellPositionInMap\",\n    value: function findCellPositionInMap(cellInfo) {\n      var _this2 = this;\n\n      var groupIndex = cellInfo.groupIndex,\n          startDate = cellInfo.startDate,\n          isAllDay = cellInfo.isAllDay,\n          index = cellInfo.index;\n      var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();\n\n      var isStartDateInCell = function isStartDateInCell(cellData) {\n        if (!_this2._workspace.isDateAndTimeView) {\n          return dateUtils.sameDate(startDate, cellData.startDate);\n        }\n\n        var cellStartTime = cellData.startDate.getTime();\n        var cellEndTime = cellData.endDate.getTime();\n        return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime;\n      };\n\n      var _this$groupedDataMap = this.groupedDataMap,\n          allDayPanelGroupedMap = _this$groupedDataMap.allDayPanelGroupedMap,\n          dateTableGroupedMap = _this$groupedDataMap.dateTableGroupedMap;\n      var rows = isAllDay && !this._workspace._isVerticalGroupedWorkSpace() ? [allDayPanelGroupedMap[groupIndex]] || [] : dateTableGroupedMap[groupIndex] || [];\n\n      for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\n        var row = rows[rowIndex];\n\n        for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {\n          var cell = row[cellIndex];\n          var cellData = cell.cellData;\n\n          if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {\n            if (isStartDateInCell(cellData)) {\n              return cell.position;\n            }\n          }\n        }\n      }\n\n      return;\n    }\n  }, {\n    key: \"_isSameGroupIndexAndIndex\",\n    value: function _isSameGroupIndexAndIndex(cellData, groupIndex, index) {\n      return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index);\n    }\n  }, {\n    key: \"getCellsGroup\",\n    value: function getCellsGroup(groupIndex) {\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      var groupData = dateTableGroupedMap[groupIndex];\n\n      if (groupData) {\n        var cellData = groupData[0][0].cellData;\n        return cellData.groups;\n      }\n    }\n  }, {\n    key: \"getCompletedGroupsInfo\",\n    value: function getCompletedGroupsInfo() {\n      var _this3 = this;\n\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      return dateTableGroupedMap.map(function (groupData) {\n        var firstCell = groupData[0][0];\n        var _firstCell$cellData = firstCell.cellData,\n            allDay = _firstCell$cellData.allDay,\n            groupIndex = _firstCell$cellData.groupIndex;\n        return {\n          allDay: allDay,\n          groupIndex: groupIndex,\n          startDate: _this3.getGroupStartDate(groupIndex),\n          endDate: _this3.getGroupEndDate(groupIndex)\n        };\n      }).filter(function (_ref7) {\n        var startDate = _ref7.startDate;\n        return !!startDate;\n      });\n    }\n  }, {\n    key: \"getGroupIndices\",\n    value: function getGroupIndices() {\n      return this.getCompletedGroupsInfo().map(function (_ref8) {\n        var groupIndex = _ref8.groupIndex;\n        return groupIndex;\n      });\n    }\n  }, {\n    key: \"getGroupFromDateTableGroupMap\",\n    value: function getGroupFromDateTableGroupMap(groupIndex) {\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      return dateTableGroupedMap[groupIndex];\n    }\n  }, {\n    key: \"getFirstGroupRow\",\n    value: function getFirstGroupRow(groupIndex) {\n      var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n      if (groupedData) {\n        var cellData = groupedData[0][0].cellData;\n        return !cellData.allDay ? groupedData[0] : groupedData[1];\n      }\n    }\n  }, {\n    key: \"getLastGroupRow\",\n    value: function getLastGroupRow(groupIndex) {\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      var groupedData = dateTableGroupedMap[groupIndex];\n\n      if (groupedData) {\n        var lastRowIndex = groupedData.length - 1;\n        return groupedData[lastRowIndex];\n      }\n    }\n  }, {\n    key: \"getLasGroupCellPosition\",\n    value: function getLasGroupCellPosition(groupIndex) {\n      var groupRow = this.getLastGroupRow(groupIndex);\n      return groupRow[groupRow.length - 1].position;\n    }\n  }, {\n    key: \"getRowCountInGroup\",\n    value: function getRowCountInGroup(groupIndex) {\n      var groupRow = this.getLastGroupRow(groupIndex);\n      var cellAmount = groupRow.length;\n      var lastCellData = groupRow[cellAmount - 1].cellData;\n      var lastCellIndex = lastCellData.index;\n      return (lastCellIndex + 1) / groupRow.length;\n    }\n  }]);\n\n  return GroupedDataMapProvider;\n}();\n\nvar ViewDataProvider = /*#__PURE__*/function () {\n  function ViewDataProvider(workspace) {\n    _classCallCheck(this, ViewDataProvider);\n\n    this._viewDataGenerator = null;\n    this._viewData = [];\n    this._completeViewDataMap = [];\n    this._completeDateHeaderMap = [];\n    this._viewDataMap = [];\n    this._groupedDataMapProvider = null;\n    this._workspace = workspace;\n  }\n\n  _createClass(ViewDataProvider, [{\n    key: \"viewDataGenerator\",\n    get: function get() {\n      if (!this._viewDataGenerator) {\n        this._viewDataGenerator = new ViewDataGenerator(this._workspace);\n      }\n\n      return this._viewDataGenerator;\n    }\n  }, {\n    key: \"completeViewDataMap\",\n    get: function get() {\n      return this._completeViewDataMap;\n    },\n    set: function set(value) {\n      this._completeViewDataMap = value;\n    }\n  }, {\n    key: \"completeDateHeaderMap\",\n    get: function get() {\n      return this._completeDateHeaderMap;\n    },\n    set: function set(value) {\n      this._completeDateHeaderMap = value;\n    }\n  }, {\n    key: \"completeTimePanelMap\",\n    get: function get() {\n      return this._completeTimePanelMap;\n    },\n    set: function set(value) {\n      this._completeTimePanelMap = value;\n    }\n  }, {\n    key: \"viewData\",\n    get: function get() {\n      return this._viewData;\n    },\n    set: function set(value) {\n      this._viewData = value;\n    }\n  }, {\n    key: \"viewDataMap\",\n    get: function get() {\n      return this._viewDataMap;\n    },\n    set: function set(value) {\n      this._viewDataMap = value;\n    }\n  }, {\n    key: \"dateHeaderData\",\n    get: function get() {\n      return this._dateHeaderData;\n    },\n    set: function set(value) {\n      this._dateHeaderData = value;\n    }\n  }, {\n    key: \"timePanelData\",\n    get: function get() {\n      return this._timePanelData;\n    },\n    set: function set(value) {\n      this._timePanelData = value;\n    }\n  }, {\n    key: \"groupedDataMap\",\n    get: function get() {\n      return this._groupedDataMapProvider.groupedDataMap;\n    }\n  }, {\n    key: \"isVerticalGroupedWorkspace\",\n    get: function get() {\n      return this._workspace._isVerticalGroupedWorkSpace();\n    }\n  }, {\n    key: \"update\",\n    value: function update(isGenerateNewViewData) {\n      var viewDataGenerator = this.viewDataGenerator,\n          _workspace = this._workspace;\n\n      var renderOptions = _workspace.generateRenderOptions();\n\n      if (isGenerateNewViewData) {\n        this.completeViewDataMap = viewDataGenerator._getCompleteViewDataMap(renderOptions);\n        this.completeDateHeaderMap = viewDataGenerator._getCompleteDateHeaderMap(renderOptions, this.completeViewDataMap);\n        this.completeTimePanelMap = viewDataGenerator._getCompleteTimePanelMap(renderOptions, this.completeViewDataMap);\n      }\n\n      this.viewDataMap = viewDataGenerator._generateViewDataMap(this.completeViewDataMap, renderOptions);\n      this.viewData = viewDataGenerator._getViewDataFromMap(this.viewDataMap, renderOptions);\n      this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, this._workspace);\n      this.dateHeaderData = viewDataGenerator._generateDateHeaderData(this.completeDateHeaderMap, renderOptions);\n      this.timePanelData = viewDataGenerator._generateTimePanelData(this.completeTimePanelMap, renderOptions);\n    }\n  }, {\n    key: \"getStartDate\",\n    value: function getStartDate() {\n      var groupedData = this.viewData.groupedData;\n      var dateTable = groupedData[0].dateTable;\n      return dateTable[0][0].startDate;\n    }\n  }, {\n    key: \"getGroupStartDate\",\n    value: function getGroupStartDate(groupIndex) {\n      return this._groupedDataMapProvider.getGroupStartDate(groupIndex);\n    }\n  }, {\n    key: \"getGroupEndDate\",\n    value: function getGroupEndDate(groupIndex) {\n      return this._groupedDataMapProvider.getGroupEndDate(groupIndex);\n    }\n  }, {\n    key: \"findGroupCellStartDate\",\n    value: function findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {\n      return this._groupedDataMapProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay);\n    }\n  }, {\n    key: \"findAllDayGroupCellStartDate\",\n    value: function findAllDayGroupCellStartDate(groupIndex, startDate) {\n      return this._groupedDataMapProvider.findAllDayGroupCellStartDate(groupIndex, startDate);\n    }\n  }, {\n    key: \"findCellPositionInMap\",\n    value: function findCellPositionInMap(cellInfo) {\n      return this._groupedDataMapProvider.findCellPositionInMap(cellInfo);\n    }\n  }, {\n    key: \"getCellsGroup\",\n    value: function getCellsGroup(groupIndex) {\n      return this._groupedDataMapProvider.getCellsGroup(groupIndex);\n    }\n  }, {\n    key: \"getCompletedGroupsInfo\",\n    value: function getCompletedGroupsInfo() {\n      return this._groupedDataMapProvider.getCompletedGroupsInfo();\n    }\n  }, {\n    key: \"getGroupIndices\",\n    value: function getGroupIndices() {\n      return this._groupedDataMapProvider.getGroupIndices();\n    }\n  }, {\n    key: \"getLasGroupCellPosition\",\n    value: function getLasGroupCellPosition(groupIndex) {\n      return this._groupedDataMapProvider.getLasGroupCellPosition(groupIndex);\n    }\n  }, {\n    key: \"getRowCountInGroup\",\n    value: function getRowCountInGroup(groupIndex) {\n      return this._groupedDataMapProvider.getRowCountInGroup(groupIndex);\n    }\n  }, {\n    key: \"getCellData\",\n    value: function getCellData(rowIndex, cellIndex, isAllDay) {\n      if (isAllDay && !this.isVerticalGroupedWorkspace) {\n        return this._viewData.groupedData[0].allDayPanel[cellIndex];\n      }\n\n      var dateTableMap = this.viewDataMap.dateTableMap;\n      var cellData = dateTableMap[rowIndex][cellIndex].cellData;\n      return cellData;\n    }\n  }, {\n    key: \"getCellsByGroupIndexAndAllDay\",\n    value: function getCellsByGroupIndexAndAllDay(groupIndex, allDay) {\n      var workspace = this._workspace;\n\n      var rowsPerGroup = workspace._getRowCountWithAllDayRows();\n\n      var isShowAllDayPanel = workspace.isAllDayPanelVisible;\n      var firstRowInGroup = this.isVerticalGroupedWorkspace ? groupIndex * rowsPerGroup : 0;\n      var lastRowInGroup = this.isVerticalGroupedWorkspace ? (groupIndex + 1) * rowsPerGroup - 1 : rowsPerGroup;\n      var correctedFirstRow = isShowAllDayPanel && !allDay ? firstRowInGroup + 1 : firstRowInGroup;\n      var correctedLastRow = allDay ? correctedFirstRow : lastRowInGroup;\n      return this.completeViewDataMap.slice(correctedFirstRow, correctedLastRow + 1).map(function (row) {\n        return row.filter(function (_ref9) {\n          var currentGroupIndex = _ref9.groupIndex;\n          return groupIndex === currentGroupIndex;\n        });\n      });\n    }\n  }, {\n    key: \"getGroupData\",\n    value: function getGroupData(groupIndex) {\n      var groupedData = this.viewData.groupedData;\n\n      if (this.isVerticalGroupedWorkspace) {\n        return groupedData.filter(function (item) {\n          return item.groupIndex === groupIndex;\n        })[0];\n      }\n\n      var filterCells = function filterCells(row) {\n        return null === row || void 0 === row ? void 0 : row.filter(function (cell) {\n          return cell.groupIndex === groupIndex;\n        });\n      };\n\n      var _groupedData$ = groupedData[0],\n          allDayPanel = _groupedData$.allDayPanel,\n          dateTable = _groupedData$.dateTable;\n      var filteredDateTable = [];\n      dateTable.forEach(function (row) {\n        filteredDateTable.push(filterCells(row));\n      });\n      return {\n        allDayPanel: filterCells(allDayPanel),\n        dateTable: filteredDateTable\n      };\n    }\n  }, {\n    key: \"getCellCountWithGroup\",\n    value: function getCellCountWithGroup(groupIndex) {\n      var rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      return dateTableGroupedMap.filter(function (_, index) {\n        return index <= groupIndex;\n      }).reduce(function (previous, row) {\n        return previous + row[rowIndex].length;\n      }, 0);\n    }\n  }, {\n    key: \"getAllDayPanel\",\n    value: function getAllDayPanel(groupIndex) {\n      var groupData = this.getGroupData(groupIndex);\n      return null === groupData || void 0 === groupData ? void 0 : groupData.allDayPanel;\n    }\n  }, {\n    key: \"isGroupIntersectDateInterval\",\n    value: function isGroupIntersectDateInterval(groupIndex, startDate, endDate) {\n      var groupStartDate = this.getGroupStartDate(groupIndex);\n      var groupEndDate = this.getGroupEndDate(groupIndex);\n      return startDate < groupEndDate && endDate > groupStartDate;\n    }\n  }, {\n    key: \"findGlobalCellPosition\",\n    value: function findGlobalCellPosition(date) {\n      var groupIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n      var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n      var completeViewDataMap = this.completeViewDataMap,\n          workspace = this._workspace;\n      var showAllDayPanel = workspace.isAllDayPanelVisible;\n\n      for (var rowIndex = 0; rowIndex < completeViewDataMap.length; rowIndex += 1) {\n        var currentRow = completeViewDataMap[rowIndex];\n\n        for (var columnIndex = 0; columnIndex < currentRow.length; columnIndex += 1) {\n          var cellData = currentRow[columnIndex];\n          var currentStartDate = cellData.startDate,\n              currentEndDate = cellData.endDate,\n              currentGroupIndex = cellData.groupIndex,\n              currentAllDay = cellData.allDay;\n\n          if (groupIndex === currentGroupIndex && allDay === !!currentAllDay && this._compareDatesAndAllDay(date, currentStartDate, currentEndDate, allDay)) {\n            return {\n              position: {\n                columnIndex: columnIndex,\n                rowIndex: showAllDayPanel && !this.isVerticalGroupedWorkspace ? rowIndex - 1 : rowIndex\n              },\n              cellData: cellData\n            };\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_compareDatesAndAllDay\",\n    value: function _compareDatesAndAllDay(date, cellStartDate, cellEndDate, allDay) {\n      var time = date.getTime();\n      var trimmedTime = dateUtils.trimTime(date).getTime();\n      var cellStartTime = cellStartDate.getTime();\n      var cellEndTime = cellEndDate.getTime();\n      return !allDay && time >= cellStartTime && time < cellEndTime || allDay && trimmedTime === cellStartTime;\n    }\n  }, {\n    key: \"getSkippedDaysCount\",\n    value: function getSkippedDaysCount(groupIndex, startDate, endDate, daysCount) {\n      var dateTableGroupedMap = this._groupedDataMapProvider.groupedDataMap.dateTableGroupedMap;\n      var groupedData = dateTableGroupedMap[groupIndex];\n      var includedDays = 0;\n\n      for (var rowIndex = 0; rowIndex < groupedData.length; rowIndex += 1) {\n        for (var columnIndex = 0; columnIndex < groupedData[rowIndex].length; columnIndex += 1) {\n          var cell = groupedData[rowIndex][columnIndex].cellData;\n\n          if (startDate.getTime() < cell.endDate.getTime() && endDate.getTime() > cell.startDate.getTime()) {\n            includedDays += 1;\n          }\n        }\n      }\n\n      var lastCell = groupedData[groupedData.length - 1][groupedData[0].length - 1].cellData;\n      var lastCellStart = dateUtils.trimTime(lastCell.startDate);\n      var daysAfterView = Math.floor((endDate.getTime() - lastCellStart.getTime()) / dateUtils.dateToMilliseconds(\"day\"));\n      var deltaDays = daysAfterView > 0 ? daysAfterView : 0;\n      return daysCount - includedDays - deltaDays;\n    }\n  }]);\n\n  return ViewDataProvider;\n}();\n\nexport { ViewDataProvider as default };","map":{"version":3,"sources":["C:/Users/user/source/repos/ReportingPortal/6.3.0/angular/node_modules/devextreme/esm/ui/scheduler/workspaces/view_data_provider.js"],"names":["_objectWithoutPropertiesLoose","_extends","dateUtils","HORIZONTAL_GROUP_ORIENTATION","ViewDataGenerator","workspace","_workspace","value","_isVerticalGroupedWorkSpace","isVerticalGroupedWorkspace","isAllDayPanelVisible","options","rowCountInGroup","cellCountInGroupRow","groupsList","groupByDate","isHorizontalGrouping","isVerticalGrouping","totalCellCount","groupCount","viewDataMap","step","allDayPanelData","_generateAllDayPanelData","viewCellsData","_generateViewCellsData","push","_transformViewDataMapForHorizontalGrouping","_transformViewDataMapForVerticalGrouping","_transformViewDataMapForGroupingByDate","completeViewDataMap","_addKeysToCells","result","map","row","slice","forEach","groups","index","groupIndex","rowIndex","nextGroupRow","cellData","nextGroupMap","cellsRow","nextRow","correctedGroupList","correctedGroupCount","length","groupedByDateCellsRow","reduce","currentRow","cell","rowWithCurrentCell","isFirstGroupCell","isLastGroupCell","totalColumnCount","_ref","allDayPanelsCount","currentViewDataMap","isAllDay","allDay","keyBase","currentAllDayPanelsCount","cellIndex","key","isGenerateWeekDaysHeaderData","weekDaysRow","_generateWeekDaysHeaderRowMap","dateRow","_generateHeaderDateRow","horizontalGroupCount","cellCountInDay","getWeekDaysHeaderText","daysInView","colSpan","dayIndex","text","startDate","getDateHeaderText","today","groupOrientation","getDateHeaderDate","dates","dateIndex","columnCount","dateHeaderColumnCount","slicedByColumnsData","_ref2","restProps","sameDate","getTimeCellDate","times","allDayRowsCount","_row$","restCellProps","timeIndex","rowCount","startCellIndex","cellCount","startRowIndex","sliceCells","startIndex","count","position","correctedStartRowIndex","allDayPanelMap","isStandaloneAllDayPanel","dateTableMap","completeDateHeaderMap","cellWidth","isProvideVirtualCellsWidth","dataMap","weekDayRowConfig","validCellWidth","_generateDateHeaderDataRow","datesRowConfig","leftVirtualCellWidth","rightVirtualCellWidth","leftVirtualCellCount","rightVirtualCellCount","weekDayLeftVirtualCellWidth","weekDayRightVirtualCellWidth","weekDayLeftVirtualCellCount","weekDayRightVirtualCellCount","baseColSpan","Math","floor","actualCellCount","ceil","finalLeftVirtualCellCount","finalLeftVirtualCellWidth","finalRightVirtualCellCount","finalRightVirtualCellWidth","completeTimePanelMap","topVirtualRowHeight","bottomVirtualRowHeight","isGroupedAllDayPanel","showAllDayPanel","indexDifference","timePanelMap","timePanelData","_generateTimePanelDataFromMap","groupedData","previousGroupedData","_ref3","previousGroupIndex","currentGroupIndex","dateTable","allDayPanel","totalRowCount","_ref4","cellDataRow","_ref5","firstCell","isAllDayRow","_ref6","topVirtualRowCount","bottomVirtualRowCount","rowsCount","arguments","cellDataGetters","_generateCellsRow","workSpace","_getAllDayCellData","bind","_this","_loop","columnIndex","correctedColumnIndex","cellDataValue","data","getter","_isFirstGroupCell","_isLastGroupCell","isGroupedByDate","columnsNumber","columnsInGroup","columnIndexInCurrentGroup","previousOptions","previousGroupedDataMap","previousRowIndex","currentRowIndex","dateTableGroupedMap","allDayPanelGroupedMap","GroupedDataMapProvider","viewDataGenerator","groupedDataMap","generateGroupedDataMap","firstRow","getFirstGroupRow","lastRow","getLastGroupRow","lastCellIndex","endDate","findAllDayGroupCellStartDate","groupData","getGroupFromDateTableGroupMap","checkCellStartDate","secondMin","secondMax","intervalsOverlap","firstMin","firstMax","startDateVerticalSearch","startDateHorizontalSearch","groupStartDate","getGroupStartDate","cellInfo","startTime","trimTime","getTime","isStartDateInCell","isDateAndTimeView","cellStartTime","cellEndTime","rows","_isSameGroupIndexAndIndex","getGroupEndDate","filter","_ref7","getCompletedGroupsInfo","_ref8","lastRowIndex","groupRow","cellAmount","lastCellData","ViewDataProvider","_viewDataGenerator","_viewData","_completeViewDataMap","_completeDateHeaderMap","_viewDataMap","_groupedDataMapProvider","_completeTimePanelMap","_dateHeaderData","_timePanelData","isGenerateNewViewData","renderOptions","generateRenderOptions","_getCompleteViewDataMap","_getCompleteDateHeaderMap","_getCompleteTimePanelMap","_generateViewDataMap","viewData","_getViewDataFromMap","dateHeaderData","_generateDateHeaderData","_generateTimePanelData","findGroupCellStartDate","findCellPositionInMap","getCellsGroup","getGroupIndices","getLasGroupCellPosition","getRowCountInGroup","rowsPerGroup","_getRowCountWithAllDayRows","isShowAllDayPanel","firstRowInGroup","lastRowInGroup","correctedFirstRow","correctedLastRow","_ref9","item","filterCells","filteredDateTable","_","previous","getGroupData","groupEndDate","date","currentStartDate","currentEndDate","currentAllDay","_compareDatesAndAllDay","cellStartDate","cellEndDate","time","trimmedTime","daysCount","includedDays","lastCell","lastCellStart","daysAfterView","dateToMilliseconds","deltaDays"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_data_provider.js)\r\n * Version: 21.1.3\r\n * Build date: Tue May 18 2021\r\n *\r\n * Copyright (c) 2012 - 2021 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport dateUtils from \"../../../core/utils/date\";\r\nimport {\r\n    HORIZONTAL_GROUP_ORIENTATION\r\n} from \"../constants\";\r\nclass ViewDataGenerator {\r\n    constructor(workspace) {\r\n        this.workspace = workspace\r\n    }\r\n    get workspace() {\r\n        return this._workspace\r\n    }\r\n    set workspace(value) {\r\n        this._workspace = value\r\n    }\r\n    get isVerticalGroupedWorkspace() {\r\n        return this.workspace._isVerticalGroupedWorkSpace()\r\n    }\r\n    get isStandaloneAllDayPanel() {\r\n        return !this.isVerticalGroupedWorkspace && this.workspace.isAllDayPanelVisible\r\n    }\r\n    _getCompleteViewDataMap(options) {\r\n        var {\r\n            rowCountInGroup: rowCountInGroup,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            groupsList: groupsList,\r\n            groupByDate: groupByDate,\r\n            isHorizontalGrouping: isHorizontalGrouping,\r\n            isVerticalGrouping: isVerticalGrouping,\r\n            totalCellCount: totalCellCount,\r\n            groupCount: groupCount\r\n        } = options;\r\n        var viewDataMap = [];\r\n        var step = groupByDate ? groupCount : 1;\r\n        var allDayPanelData = this._generateAllDayPanelData(options, cellCountInGroupRow, step);\r\n        var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, step);\r\n        allDayPanelData && viewDataMap.push(allDayPanelData);\r\n        viewDataMap.push(...viewCellsData);\r\n        if (isHorizontalGrouping && !groupByDate) {\r\n            viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList)\r\n        }\r\n        if (isVerticalGrouping) {\r\n            viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList)\r\n        }\r\n        if (groupByDate) {\r\n            viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList)\r\n        }\r\n        var completeViewDataMap = this._addKeysToCells(viewDataMap, totalCellCount);\r\n        return completeViewDataMap\r\n    }\r\n    _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\r\n        var result = viewDataMap.map(row => row.slice());\r\n        groupsList.slice(1).forEach((groups, index) => {\r\n            var groupIndex = index + 1;\r\n            viewDataMap.forEach((row, rowIndex) => {\r\n                var nextGroupRow = row.map(cellData => _extends({}, cellData, {\r\n                    groups: groups,\r\n                    groupIndex: groupIndex\r\n                }));\r\n                result[rowIndex].push(...nextGroupRow)\r\n            })\r\n        });\r\n        return result\r\n    }\r\n    _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\r\n        var result = viewDataMap.map(row => row.slice());\r\n        groupsList.slice(1).forEach((groups, index) => {\r\n            var groupIndex = index + 1;\r\n            var nextGroupMap = viewDataMap.map(cellsRow => {\r\n                var nextRow = cellsRow.map(cellData => _extends({}, cellData, {\r\n                    groupIndex: groupIndex,\r\n                    groups: groups\r\n                }));\r\n                return nextRow\r\n            });\r\n            result.push(...nextGroupMap)\r\n        });\r\n        return result\r\n    }\r\n    _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\r\n        var correctedGroupList = groupsList.slice(1);\r\n        var correctedGroupCount = correctedGroupList.length;\r\n        var result = viewDataMap.map(cellsRow => {\r\n            var groupedByDateCellsRow = cellsRow.reduce((currentRow, cell) => {\r\n                var rowWithCurrentCell = [...currentRow, _extends({}, cell, {\r\n                    isFirstGroupCell: true,\r\n                    isLastGroupCell: 0 === correctedGroupCount\r\n                }), ...correctedGroupList.map((groups, index) => _extends({}, cell, {\r\n                    groups: groups,\r\n                    groupIndex: index + 1,\r\n                    isFirstGroupCell: false,\r\n                    isLastGroupCell: index === correctedGroupCount - 1\r\n                }))];\r\n                return rowWithCurrentCell\r\n            }, []);\r\n            return groupedByDateCellsRow\r\n        });\r\n        return result\r\n    }\r\n    _addKeysToCells(viewDataMap, totalColumnCount) {\r\n        var {\r\n            currentViewDataMap: result\r\n        } = viewDataMap.reduce((_ref, row, rowIndex) => {\r\n            var {\r\n                allDayPanelsCount: allDayPanelsCount,\r\n                currentViewDataMap: currentViewDataMap\r\n            } = _ref;\r\n            var isAllDay = row[0].allDay;\r\n            var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\r\n            var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\r\n            currentViewDataMap[rowIndex].forEach((cell, cellIndex) => {\r\n                cell.key = keyBase + cellIndex\r\n            });\r\n            return {\r\n                allDayPanelsCount: currentAllDayPanelsCount,\r\n                currentViewDataMap: currentViewDataMap\r\n            }\r\n        }, {\r\n            allDayPanelsCount: 0,\r\n            currentViewDataMap: viewDataMap\r\n        });\r\n        return result\r\n    }\r\n    _getCompleteDateHeaderMap(options, completeViewDataMap) {\r\n        var {\r\n            isGenerateWeekDaysHeaderData: isGenerateWeekDaysHeaderData\r\n        } = options;\r\n        var result = [];\r\n        if (isGenerateWeekDaysHeaderData) {\r\n            var weekDaysRow = this._generateWeekDaysHeaderRowMap(options, completeViewDataMap);\r\n            result.push(weekDaysRow)\r\n        }\r\n        var dateRow = this._generateHeaderDateRow(options, completeViewDataMap);\r\n        result.push(dateRow);\r\n        return result\r\n    }\r\n    _generateWeekDaysHeaderRowMap(options, completeViewDataMap) {\r\n        var {\r\n            groupByDate: groupByDate,\r\n            horizontalGroupCount: horizontalGroupCount,\r\n            cellCountInDay: cellCountInDay,\r\n            getWeekDaysHeaderText: getWeekDaysHeaderText,\r\n            daysInView: daysInView\r\n        } = options;\r\n        var index = completeViewDataMap[0][0].allDay ? 1 : 0;\r\n        var colSpan = groupByDate ? horizontalGroupCount * cellCountInDay : cellCountInDay;\r\n        var weekDaysRow = [];\r\n        for (var dayIndex = 0; dayIndex < daysInView; dayIndex += 1) {\r\n            var cell = completeViewDataMap[index][dayIndex * cellCountInDay];\r\n            weekDaysRow.push(_extends({}, cell, {\r\n                colSpan: colSpan,\r\n                text: getWeekDaysHeaderText(cell.startDate),\r\n                isFirstGroupCell: false,\r\n                isLastGroupCell: false\r\n            }))\r\n        }\r\n        return weekDaysRow\r\n    }\r\n    _generateHeaderDateRow(options, completeViewDataMap) {\r\n        var {\r\n            getDateHeaderText: getDateHeaderText,\r\n            today: today,\r\n            groupByDate: groupByDate,\r\n            horizontalGroupCount: horizontalGroupCount,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            groupOrientation: groupOrientation,\r\n            getDateHeaderDate: getDateHeaderDate\r\n        } = options;\r\n        var dates = [];\r\n        for (var dateIndex = 0; dateIndex < cellCountInGroupRow; dateIndex += 1) {\r\n            dates.push(getDateHeaderDate(dateIndex))\r\n        }\r\n        var index = completeViewDataMap[0][0].allDay ? 1 : 0;\r\n        var columnCount = completeViewDataMap[index].length;\r\n        var dateHeaderColumnCount = groupByDate ? columnCount / horizontalGroupCount : columnCount;\r\n        var colSpan = groupByDate ? horizontalGroupCount : 1;\r\n        var isVerticalGrouping = \"vertical\" === groupOrientation;\r\n        var slicedByColumnsData = completeViewDataMap[index].slice(0, dateHeaderColumnCount);\r\n        return slicedByColumnsData.map((_ref2, index) => {\r\n            var {\r\n                startDate: startDate,\r\n                isFirstGroupCell: isFirstGroupCell,\r\n                isLastGroupCell: isLastGroupCell\r\n            } = _ref2, restProps = _objectWithoutPropertiesLoose(_ref2, [\"startDate\", \"endDate\", \"isFirstGroupCell\", \"isLastGroupCell\"]);\r\n            return _extends({}, restProps, {\r\n                startDate: dates[index % cellCountInGroupRow],\r\n                text: getDateHeaderText(index % cellCountInGroupRow),\r\n                today: dateUtils.sameDate(startDate, today),\r\n                colSpan: colSpan,\r\n                isFirstGroupCell: groupByDate || isFirstGroupCell && !isVerticalGrouping,\r\n                isLastGroupCell: groupByDate || isLastGroupCell && !isVerticalGrouping\r\n            })\r\n        })\r\n    }\r\n    _getCompleteTimePanelMap(options, completeViewDataMap) {\r\n        var {\r\n            rowCountInGroup: rowCountInGroup,\r\n            getTimeCellDate: getTimeCellDate\r\n        } = options;\r\n        var times = [];\r\n        for (var rowIndex = 0; rowIndex < rowCountInGroup; rowIndex += 1) {\r\n            times.push(getTimeCellDate(rowIndex))\r\n        }\r\n        var allDayRowsCount = 0;\r\n        return completeViewDataMap.map((row, index) => {\r\n            var _row$ = row[0],\r\n                {\r\n                    allDay: allDay,\r\n                    startDate: startDate\r\n                } = _row$,\r\n                restCellProps = _objectWithoutPropertiesLoose(_row$, [\"allDay\", \"startDate\", \"endDate\"]);\r\n            if (allDay) {\r\n                allDayRowsCount += 1\r\n            }\r\n            var timeIndex = (index - allDayRowsCount) % rowCountInGroup;\r\n            return _extends({}, restCellProps, {\r\n                allDay: allDay,\r\n                startDate: allDay ? startDate : times[timeIndex]\r\n            })\r\n        })\r\n    }\r\n    _generateViewDataMap(completeViewDataMap, options) {\r\n        var {\r\n            rowCount: rowCount,\r\n            startCellIndex: startCellIndex,\r\n            cellCount: cellCount\r\n        } = options;\r\n        var {\r\n            startRowIndex: startRowIndex\r\n        } = options;\r\n        var sliceCells = (row, rowIndex, startIndex, count) => row.slice(startIndex, startIndex + count).map((cellData, cellIndex) => ({\r\n            cellData: cellData,\r\n            position: {\r\n                rowIndex: rowIndex,\r\n                cellIndex: cellIndex\r\n            }\r\n        }));\r\n        var correctedStartRowIndex = startRowIndex;\r\n        var allDayPanelMap = [];\r\n        if (this.isStandaloneAllDayPanel) {\r\n            correctedStartRowIndex++;\r\n            allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount)\r\n        }\r\n        var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount).map((row, rowIndex) => sliceCells(row, rowIndex, startCellIndex, cellCount));\r\n        return {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        }\r\n    }\r\n    _generateDateHeaderData(completeDateHeaderMap, options) {\r\n        var {\r\n            isGenerateWeekDaysHeaderData: isGenerateWeekDaysHeaderData,\r\n            cellCountInDay: cellCountInDay,\r\n            cellWidth: cellWidth,\r\n            isProvideVirtualCellsWidth: isProvideVirtualCellsWidth\r\n        } = options;\r\n        var dataMap = [];\r\n        var weekDayRowConfig = {};\r\n        var validCellWidth = cellWidth || 0;\r\n        if (isGenerateWeekDaysHeaderData) {\r\n            weekDayRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, cellCountInDay, 0, validCellWidth);\r\n            dataMap.push(weekDayRowConfig.dateRow)\r\n        }\r\n        var datesRowConfig = this._generateDateHeaderDataRow(options, completeDateHeaderMap, 1, isGenerateWeekDaysHeaderData ? 1 : 0, validCellWidth);\r\n        dataMap.push(datesRowConfig.dateRow);\r\n        return {\r\n            dataMap: dataMap,\r\n            leftVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.leftVirtualCellWidth : void 0,\r\n            rightVirtualCellWidth: isProvideVirtualCellsWidth ? datesRowConfig.rightVirtualCellWidth : void 0,\r\n            leftVirtualCellCount: datesRowConfig.leftVirtualCellCount,\r\n            rightVirtualCellCount: datesRowConfig.rightVirtualCellCount,\r\n            weekDayLeftVirtualCellWidth: weekDayRowConfig.leftVirtualCellWidth,\r\n            weekDayRightVirtualCellWidth: weekDayRowConfig.rightVirtualCellWidth,\r\n            weekDayLeftVirtualCellCount: weekDayRowConfig.leftVirtualCellCount,\r\n            weekDayRightVirtualCellCount: weekDayRowConfig.rightVirtualCellCount\r\n        }\r\n    }\r\n    _generateDateHeaderDataRow(options, completeDateHeaderMap, baseColSpan, rowIndex, cellWidth) {\r\n        var {\r\n            groupByDate: groupByDate,\r\n            horizontalGroupCount: horizontalGroupCount,\r\n            startCellIndex: startCellIndex,\r\n            cellCount: cellCount,\r\n            totalCellCount: totalCellCount,\r\n            isProvideVirtualCellsWidth: isProvideVirtualCellsWidth\r\n        } = options;\r\n        var colSpan = groupByDate ? horizontalGroupCount * baseColSpan : baseColSpan;\r\n        var leftVirtualCellCount = Math.floor(startCellIndex / colSpan);\r\n        var actualCellCount = Math.ceil((startCellIndex + cellCount) / colSpan);\r\n        var dateRow = completeDateHeaderMap[rowIndex].slice(leftVirtualCellCount, actualCellCount);\r\n        var finalLeftVirtualCellCount = leftVirtualCellCount * colSpan;\r\n        var finalLeftVirtualCellWidth = finalLeftVirtualCellCount * cellWidth;\r\n        var finalRightVirtualCellCount = totalCellCount - actualCellCount * colSpan;\r\n        var finalRightVirtualCellWidth = finalRightVirtualCellCount * cellWidth;\r\n        return {\r\n            dateRow: dateRow,\r\n            leftVirtualCellCount: finalLeftVirtualCellCount,\r\n            leftVirtualCellWidth: isProvideVirtualCellsWidth ? finalLeftVirtualCellWidth : void 0,\r\n            rightVirtualCellCount: finalRightVirtualCellCount,\r\n            rightVirtualCellWidth: isProvideVirtualCellsWidth ? finalRightVirtualCellWidth : void 0\r\n        }\r\n    }\r\n    _generateTimePanelData(completeTimePanelMap, options) {\r\n        var {\r\n            startRowIndex: startRowIndex,\r\n            rowCount: rowCount,\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            cellCountInGroupRow: cellCountInGroupRow\r\n        } = options;\r\n        var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();\r\n        var showAllDayPanel = this.workspace.isAllDayPanelVisible;\r\n        var indexDifference = this.isVerticalGroupedWorkspace || !showAllDayPanel ? 0 : 1;\r\n        var correctedStartRowIndex = startRowIndex + indexDifference;\r\n        var timePanelMap = completeTimePanelMap.slice(correctedStartRowIndex, correctedStartRowIndex + rowCount);\r\n        var timePanelData = {\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n            cellCountInGroupRow: cellCountInGroupRow\r\n        };\r\n        var {\r\n            previousGroupedData: groupedData\r\n        } = this._generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel);\r\n        timePanelData.groupedData = groupedData;\r\n        return timePanelData\r\n    }\r\n    _generateTimePanelDataFromMap(timePanelMap, isGroupedAllDayPanel) {\r\n        return timePanelMap.reduce((_ref3, cellData) => {\r\n            var {\r\n                previousGroupIndex: previousGroupIndex,\r\n                previousGroupedData: previousGroupedData\r\n            } = _ref3;\r\n            var currentGroupIndex = cellData.groupIndex;\r\n            if (currentGroupIndex !== previousGroupIndex) {\r\n                previousGroupedData.push({\r\n                    dateTable: [],\r\n                    isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n                    groupIndex: currentGroupIndex\r\n                })\r\n            }\r\n            if (cellData.allDay) {\r\n                previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellData\r\n            } else {\r\n                previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellData)\r\n            }\r\n            return {\r\n                previousGroupIndex: currentGroupIndex,\r\n                previousGroupedData: previousGroupedData\r\n            }\r\n        }, {\r\n            previousGroupIndex: -1,\r\n            previousGroupedData: []\r\n        })\r\n    }\r\n    _getViewDataFromMap(viewDataMap, options) {\r\n        var {\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            leftVirtualCellWidth: leftVirtualCellWidth,\r\n            rightVirtualCellWidth: rightVirtualCellWidth,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            totalCellCount: totalCellCount,\r\n            totalRowCount: totalRowCount,\r\n            cellCount: cellCount,\r\n            rowCount: rowCount,\r\n            startRowIndex: startRowIndex,\r\n            startCellIndex: startCellIndex,\r\n            isProvideVirtualCellsWidth: isProvideVirtualCellsWidth\r\n        } = options;\r\n        var isGroupedAllDayPanel = this.workspace.isGroupedAllDayPanel();\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var {\r\n            previousGroupedData: groupedData\r\n        } = dateTableMap.reduce((_ref4, cellsRow) => {\r\n            var {\r\n                previousGroupIndex: previousGroupIndex,\r\n                previousGroupedData: previousGroupedData\r\n            } = _ref4;\r\n            var cellDataRow = cellsRow.map(_ref5 => {\r\n                var {\r\n                    cellData: cellData\r\n                } = _ref5;\r\n                return cellData\r\n            });\r\n            var firstCell = cellDataRow[0];\r\n            var isAllDayRow = firstCell.allDay;\r\n            var currentGroupIndex = firstCell.groupIndex;\r\n            if (currentGroupIndex !== previousGroupIndex) {\r\n                previousGroupedData.push({\r\n                    dateTable: [],\r\n                    isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n                    groupIndex: currentGroupIndex\r\n                })\r\n            }\r\n            if (isAllDayRow) {\r\n                previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellDataRow\r\n            } else {\r\n                previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellDataRow)\r\n            }\r\n            return {\r\n                previousGroupedData: previousGroupedData,\r\n                previousGroupIndex: currentGroupIndex\r\n            }\r\n        }, {\r\n            previousGroupIndex: -1,\r\n            previousGroupedData: []\r\n        });\r\n        if (this.isStandaloneAllDayPanel) {\r\n            groupedData[0].allDayPanel = allDayPanelMap.map(_ref6 => {\r\n                var {\r\n                    cellData: cellData\r\n                } = _ref6;\r\n                return cellData\r\n            })\r\n        }\r\n        return {\r\n            groupedData: groupedData,\r\n            topVirtualRowHeight: topVirtualRowHeight,\r\n            bottomVirtualRowHeight: bottomVirtualRowHeight,\r\n            leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\r\n            rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\r\n            leftVirtualCellCount: startCellIndex,\r\n            rightVirtualCellCount: totalCellCount - startCellIndex - cellCount,\r\n            topVirtualRowCount: startRowIndex,\r\n            bottomVirtualRowCount: totalRowCount - startRowIndex - rowCount\r\n        }\r\n    }\r\n    _generateViewCellsData(options, rowsCount) {\r\n        var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\r\n        var {\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            cellDataGetters: cellDataGetters\r\n        } = options;\r\n        var viewCellsData = [];\r\n        for (var rowIndex = 0; rowIndex < rowsCount; rowIndex += 1) {\r\n            viewCellsData.push(this._generateCellsRow(options, cellDataGetters, rowIndex, cellCountInGroupRow, step))\r\n        }\r\n        return viewCellsData\r\n    }\r\n    _generateAllDayPanelData(options, cellCount) {\r\n        var step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\r\n        var workSpace = this.workspace;\r\n        if (!workSpace.isAllDayPanelVisible) {\r\n            return null\r\n        }\r\n        return this._generateCellsRow(options, [workSpace._getAllDayCellData.bind(workSpace)], 0, cellCount, step)\r\n    }\r\n    _generateCellsRow(options, cellDataGetters, rowIndex, columnCount, step) {\r\n        var _this = this;\r\n        var cellsRow = [];\r\n        var _loop = function(columnIndex) {\r\n            var correctedColumnIndex = step * columnIndex;\r\n            var cellDataValue = cellDataGetters.reduce((data, getter) => _extends({}, data, getter(void 0, rowIndex, correctedColumnIndex, 0, data.startDate).value), {});\r\n            cellDataValue.index = rowIndex * columnCount + columnIndex;\r\n            cellDataValue.isFirstGroupCell = _this._isFirstGroupCell(rowIndex, columnIndex, options);\r\n            cellDataValue.isLastGroupCell = _this._isLastGroupCell(rowIndex, columnIndex, options);\r\n            cellsRow.push(cellDataValue)\r\n        };\r\n        for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\r\n            _loop(columnIndex)\r\n        }\r\n        return cellsRow\r\n    }\r\n    _calculateCellIndex(horizontalGroupCount, groupOrientation, isGroupedByDate, rowIndex, columnIndex, columnsNumber) {\r\n        var groupCount = horizontalGroupCount || 1;\r\n        var index = rowIndex * columnsNumber + columnIndex;\r\n        var columnsInGroup = columnsNumber / groupCount;\r\n        if (\"horizontal\" === groupOrientation) {\r\n            var columnIndexInCurrentGroup = columnIndex % columnsInGroup;\r\n            if (isGroupedByDate) {\r\n                columnIndexInCurrentGroup = Math.floor(columnIndex / groupCount)\r\n            }\r\n            index = rowIndex * columnsInGroup + columnIndexInCurrentGroup\r\n        }\r\n        return index\r\n    }\r\n    generateGroupedDataMap(viewDataMap) {\r\n        var {\r\n            allDayPanelMap: allDayPanelMap,\r\n            dateTableMap: dateTableMap\r\n        } = viewDataMap;\r\n        var {\r\n            previousGroupedDataMap: dateTableGroupedMap\r\n        } = dateTableMap.reduce((previousOptions, cellsRow) => {\r\n            var {\r\n                previousGroupedDataMap: previousGroupedDataMap,\r\n                previousRowIndex: previousRowIndex,\r\n                previousGroupIndex: previousGroupIndex\r\n            } = previousOptions;\r\n            var {\r\n                groupIndex: currentGroupIndex\r\n            } = cellsRow[0].cellData;\r\n            var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\r\n            cellsRow.forEach(cell => {\r\n                var {\r\n                    groupIndex: groupIndex\r\n                } = cell.cellData;\r\n                if (!previousGroupedDataMap[groupIndex]) {\r\n                    previousGroupedDataMap[groupIndex] = []\r\n                }\r\n                if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\r\n                    previousGroupedDataMap[groupIndex][currentRowIndex] = []\r\n                }\r\n                previousGroupedDataMap[groupIndex][currentRowIndex].push(cell)\r\n            });\r\n            return {\r\n                previousGroupedDataMap: previousGroupedDataMap,\r\n                previousRowIndex: currentRowIndex,\r\n                previousGroupIndex: currentGroupIndex\r\n            }\r\n        }, {\r\n            previousGroupedDataMap: [],\r\n            previousRowIndex: -1,\r\n            previousGroupIndex: -1\r\n        });\r\n        var allDayPanelGroupedMap = [];\r\n        null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(cell => {\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = cell.cellData;\r\n            if (!allDayPanelGroupedMap[groupIndex]) {\r\n                allDayPanelGroupedMap[groupIndex] = []\r\n            }\r\n            allDayPanelGroupedMap[groupIndex].push(cell)\r\n        });\r\n        return {\r\n            allDayPanelGroupedMap: allDayPanelGroupedMap,\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        }\r\n    }\r\n    _isFirstGroupCell(rowIndex, columnIndex, options) {\r\n        var {\r\n            groupOrientation: groupOrientation,\r\n            rowCountInGroup: rowCountInGroup,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            groupCount: groupCount\r\n        } = options;\r\n        if (this.workspace.isGroupedByDate()) {\r\n            return columnIndex % groupCount === 0\r\n        }\r\n        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\r\n            return columnIndex % cellCountInGroupRow === 0\r\n        }\r\n        return rowIndex % rowCountInGroup === 0\r\n    }\r\n    _isLastGroupCell(rowIndex, columnIndex, options) {\r\n        var {\r\n            groupOrientation: groupOrientation,\r\n            rowCountInGroup: rowCountInGroup,\r\n            cellCountInGroupRow: cellCountInGroupRow,\r\n            groupCount: groupCount\r\n        } = options;\r\n        if (this.workspace.isGroupedByDate()) {\r\n            return (columnIndex + 1) % groupCount === 0\r\n        }\r\n        if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\r\n            return (columnIndex + 1) % cellCountInGroupRow === 0\r\n        }\r\n        return (rowIndex + 1) % rowCountInGroup === 0\r\n    }\r\n}\r\nclass GroupedDataMapProvider {\r\n    constructor(viewDataGenerator, viewDataMap, completeViewDataMap, workspace) {\r\n        this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);\r\n        this.completeViewDataMap = completeViewDataMap;\r\n        this._workspace = workspace\r\n    }\r\n    getGroupStartDate(groupIndex) {\r\n        var firstRow = this.getFirstGroupRow(groupIndex);\r\n        if (firstRow) {\r\n            var {\r\n                startDate: startDate\r\n            } = firstRow[0].cellData;\r\n            return startDate\r\n        }\r\n    }\r\n    getGroupEndDate(groupIndex) {\r\n        var lastRow = this.getLastGroupRow(groupIndex);\r\n        if (lastRow) {\r\n            var lastCellIndex = lastRow.length - 1;\r\n            var {\r\n                cellData: cellData\r\n            } = lastRow[lastCellIndex];\r\n            var {\r\n                endDate: endDate\r\n            } = cellData;\r\n            return endDate\r\n        }\r\n    }\r\n    findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {\r\n        if (isAllDay) {\r\n            return this.findAllDayGroupCellStartDate(groupIndex, startDate)\r\n        }\r\n        var groupData = this.getGroupFromDateTableGroupMap(groupIndex);\r\n        var checkCellStartDate = (rowIndex, cellIndex) => {\r\n            var {\r\n                cellData: cellData\r\n            } = groupData[rowIndex][cellIndex];\r\n            var {\r\n                startDate: secondMin,\r\n                endDate: secondMax\r\n            } = cellData;\r\n            if (dateUtils.intervalsOverlap({\r\n                    firstMin: startDate,\r\n                    firstMax: endDate,\r\n                    secondMin: secondMin,\r\n                    secondMax: secondMax\r\n                })) {\r\n                return secondMin\r\n            }\r\n        };\r\n        var startDateVerticalSearch = (() => {\r\n            var cellCount = groupData[0].length;\r\n            for (var cellIndex = 0; cellIndex < cellCount; ++cellIndex) {\r\n                for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\r\n                    var result = checkCellStartDate(rowIndex, cellIndex);\r\n                    if (result) {\r\n                        return result\r\n                    }\r\n                }\r\n            }\r\n        })();\r\n        var startDateHorizontalSearch = (() => {\r\n            for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\r\n                var row = groupData[rowIndex];\r\n                for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {\r\n                    var result = checkCellStartDate(rowIndex, cellIndex);\r\n                    if (result) {\r\n                        return result\r\n                    }\r\n                }\r\n            }\r\n        })();\r\n        return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch\r\n    }\r\n    findAllDayGroupCellStartDate(groupIndex, startDate) {\r\n        var groupStartDate = this.getGroupStartDate(groupIndex);\r\n        return groupStartDate > startDate ? groupStartDate : startDate\r\n    }\r\n    findCellPositionInMap(cellInfo) {\r\n        var {\r\n            groupIndex: groupIndex,\r\n            startDate: startDate,\r\n            isAllDay: isAllDay,\r\n            index: index\r\n        } = cellInfo;\r\n        var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();\r\n        var isStartDateInCell = cellData => {\r\n            if (!this._workspace.isDateAndTimeView) {\r\n                return dateUtils.sameDate(startDate, cellData.startDate)\r\n            }\r\n            var cellStartTime = cellData.startDate.getTime();\r\n            var cellEndTime = cellData.endDate.getTime();\r\n            return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime\r\n        };\r\n        var {\r\n            allDayPanelGroupedMap: allDayPanelGroupedMap,\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var rows = isAllDay && !this._workspace._isVerticalGroupedWorkSpace() ? [allDayPanelGroupedMap[groupIndex]] || [] : dateTableGroupedMap[groupIndex] || [];\r\n        for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\r\n            var row = rows[rowIndex];\r\n            for (var cellIndex = 0; cellIndex < row.length; ++cellIndex) {\r\n                var cell = row[cellIndex];\r\n                var {\r\n                    cellData: cellData\r\n                } = cell;\r\n                if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {\r\n                    if (isStartDateInCell(cellData)) {\r\n                        return cell.position\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return\r\n    }\r\n    _isSameGroupIndexAndIndex(cellData, groupIndex, index) {\r\n        return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index)\r\n    }\r\n    getCellsGroup(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var groupData = dateTableGroupedMap[groupIndex];\r\n        if (groupData) {\r\n            var {\r\n                cellData: cellData\r\n            } = groupData[0][0];\r\n            return cellData.groups\r\n        }\r\n    }\r\n    getCompletedGroupsInfo() {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        return dateTableGroupedMap.map(groupData => {\r\n            var firstCell = groupData[0][0];\r\n            var {\r\n                allDay: allDay,\r\n                groupIndex: groupIndex\r\n            } = firstCell.cellData;\r\n            return {\r\n                allDay: allDay,\r\n                groupIndex: groupIndex,\r\n                startDate: this.getGroupStartDate(groupIndex),\r\n                endDate: this.getGroupEndDate(groupIndex)\r\n            }\r\n        }).filter(_ref7 => {\r\n            var {\r\n                startDate: startDate\r\n            } = _ref7;\r\n            return !!startDate\r\n        })\r\n    }\r\n    getGroupIndices() {\r\n        return this.getCompletedGroupsInfo().map(_ref8 => {\r\n            var {\r\n                groupIndex: groupIndex\r\n            } = _ref8;\r\n            return groupIndex\r\n        })\r\n    }\r\n    getGroupFromDateTableGroupMap(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        return dateTableGroupedMap[groupIndex]\r\n    }\r\n    getFirstGroupRow(groupIndex) {\r\n        var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);\r\n        if (groupedData) {\r\n            var {\r\n                cellData: cellData\r\n            } = groupedData[0][0];\r\n            return !cellData.allDay ? groupedData[0] : groupedData[1]\r\n        }\r\n    }\r\n    getLastGroupRow(groupIndex) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        var groupedData = dateTableGroupedMap[groupIndex];\r\n        if (groupedData) {\r\n            var lastRowIndex = groupedData.length - 1;\r\n            return groupedData[lastRowIndex]\r\n        }\r\n    }\r\n    getLasGroupCellPosition(groupIndex) {\r\n        var groupRow = this.getLastGroupRow(groupIndex);\r\n        return groupRow[groupRow.length - 1].position\r\n    }\r\n    getRowCountInGroup(groupIndex) {\r\n        var groupRow = this.getLastGroupRow(groupIndex);\r\n        var cellAmount = groupRow.length;\r\n        var lastCellData = groupRow[cellAmount - 1].cellData;\r\n        var lastCellIndex = lastCellData.index;\r\n        return (lastCellIndex + 1) / groupRow.length\r\n    }\r\n}\r\nexport default class ViewDataProvider {\r\n    constructor(workspace) {\r\n        this._viewDataGenerator = null;\r\n        this._viewData = [];\r\n        this._completeViewDataMap = [];\r\n        this._completeDateHeaderMap = [];\r\n        this._viewDataMap = [];\r\n        this._groupedDataMapProvider = null;\r\n        this._workspace = workspace\r\n    }\r\n    get viewDataGenerator() {\r\n        if (!this._viewDataGenerator) {\r\n            this._viewDataGenerator = new ViewDataGenerator(this._workspace)\r\n        }\r\n        return this._viewDataGenerator\r\n    }\r\n    get completeViewDataMap() {\r\n        return this._completeViewDataMap\r\n    }\r\n    set completeViewDataMap(value) {\r\n        this._completeViewDataMap = value\r\n    }\r\n    get completeDateHeaderMap() {\r\n        return this._completeDateHeaderMap\r\n    }\r\n    set completeDateHeaderMap(value) {\r\n        this._completeDateHeaderMap = value\r\n    }\r\n    get completeTimePanelMap() {\r\n        return this._completeTimePanelMap\r\n    }\r\n    set completeTimePanelMap(value) {\r\n        this._completeTimePanelMap = value\r\n    }\r\n    get viewData() {\r\n        return this._viewData\r\n    }\r\n    set viewData(value) {\r\n        this._viewData = value\r\n    }\r\n    get viewDataMap() {\r\n        return this._viewDataMap\r\n    }\r\n    set viewDataMap(value) {\r\n        this._viewDataMap = value\r\n    }\r\n    get dateHeaderData() {\r\n        return this._dateHeaderData\r\n    }\r\n    set dateHeaderData(value) {\r\n        this._dateHeaderData = value\r\n    }\r\n    get timePanelData() {\r\n        return this._timePanelData\r\n    }\r\n    set timePanelData(value) {\r\n        this._timePanelData = value\r\n    }\r\n    get groupedDataMap() {\r\n        return this._groupedDataMapProvider.groupedDataMap\r\n    }\r\n    get isVerticalGroupedWorkspace() {\r\n        return this._workspace._isVerticalGroupedWorkSpace()\r\n    }\r\n    update(isGenerateNewViewData) {\r\n        var {\r\n            viewDataGenerator: viewDataGenerator,\r\n            _workspace: _workspace\r\n        } = this;\r\n        var renderOptions = _workspace.generateRenderOptions();\r\n        if (isGenerateNewViewData) {\r\n            this.completeViewDataMap = viewDataGenerator._getCompleteViewDataMap(renderOptions);\r\n            this.completeDateHeaderMap = viewDataGenerator._getCompleteDateHeaderMap(renderOptions, this.completeViewDataMap);\r\n            this.completeTimePanelMap = viewDataGenerator._getCompleteTimePanelMap(renderOptions, this.completeViewDataMap)\r\n        }\r\n        this.viewDataMap = viewDataGenerator._generateViewDataMap(this.completeViewDataMap, renderOptions);\r\n        this.viewData = viewDataGenerator._getViewDataFromMap(this.viewDataMap, renderOptions);\r\n        this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, this._workspace);\r\n        this.dateHeaderData = viewDataGenerator._generateDateHeaderData(this.completeDateHeaderMap, renderOptions);\r\n        this.timePanelData = viewDataGenerator._generateTimePanelData(this.completeTimePanelMap, renderOptions)\r\n    }\r\n    getStartDate() {\r\n        var {\r\n            groupedData: groupedData\r\n        } = this.viewData;\r\n        var {\r\n            dateTable: dateTable\r\n        } = groupedData[0];\r\n        return dateTable[0][0].startDate\r\n    }\r\n    getGroupStartDate(groupIndex) {\r\n        return this._groupedDataMapProvider.getGroupStartDate(groupIndex)\r\n    }\r\n    getGroupEndDate(groupIndex) {\r\n        return this._groupedDataMapProvider.getGroupEndDate(groupIndex)\r\n    }\r\n    findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay) {\r\n        return this._groupedDataMapProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay)\r\n    }\r\n    findAllDayGroupCellStartDate(groupIndex, startDate) {\r\n        return this._groupedDataMapProvider.findAllDayGroupCellStartDate(groupIndex, startDate)\r\n    }\r\n    findCellPositionInMap(cellInfo) {\r\n        return this._groupedDataMapProvider.findCellPositionInMap(cellInfo)\r\n    }\r\n    getCellsGroup(groupIndex) {\r\n        return this._groupedDataMapProvider.getCellsGroup(groupIndex)\r\n    }\r\n    getCompletedGroupsInfo() {\r\n        return this._groupedDataMapProvider.getCompletedGroupsInfo()\r\n    }\r\n    getGroupIndices() {\r\n        return this._groupedDataMapProvider.getGroupIndices()\r\n    }\r\n    getLasGroupCellPosition(groupIndex) {\r\n        return this._groupedDataMapProvider.getLasGroupCellPosition(groupIndex)\r\n    }\r\n    getRowCountInGroup(groupIndex) {\r\n        return this._groupedDataMapProvider.getRowCountInGroup(groupIndex)\r\n    }\r\n    getCellData(rowIndex, cellIndex, isAllDay) {\r\n        if (isAllDay && !this.isVerticalGroupedWorkspace) {\r\n            return this._viewData.groupedData[0].allDayPanel[cellIndex]\r\n        }\r\n        var {\r\n            dateTableMap: dateTableMap\r\n        } = this.viewDataMap;\r\n        var {\r\n            cellData: cellData\r\n        } = dateTableMap[rowIndex][cellIndex];\r\n        return cellData\r\n    }\r\n    getCellsByGroupIndexAndAllDay(groupIndex, allDay) {\r\n        var workspace = this._workspace;\r\n        var rowsPerGroup = workspace._getRowCountWithAllDayRows();\r\n        var isShowAllDayPanel = workspace.isAllDayPanelVisible;\r\n        var firstRowInGroup = this.isVerticalGroupedWorkspace ? groupIndex * rowsPerGroup : 0;\r\n        var lastRowInGroup = this.isVerticalGroupedWorkspace ? (groupIndex + 1) * rowsPerGroup - 1 : rowsPerGroup;\r\n        var correctedFirstRow = isShowAllDayPanel && !allDay ? firstRowInGroup + 1 : firstRowInGroup;\r\n        var correctedLastRow = allDay ? correctedFirstRow : lastRowInGroup;\r\n        return this.completeViewDataMap.slice(correctedFirstRow, correctedLastRow + 1).map(row => row.filter(_ref9 => {\r\n            var {\r\n                groupIndex: currentGroupIndex\r\n            } = _ref9;\r\n            return groupIndex === currentGroupIndex\r\n        }))\r\n    }\r\n    getGroupData(groupIndex) {\r\n        var {\r\n            groupedData: groupedData\r\n        } = this.viewData;\r\n        if (this.isVerticalGroupedWorkspace) {\r\n            return groupedData.filter(item => item.groupIndex === groupIndex)[0]\r\n        }\r\n        var filterCells = row => null === row || void 0 === row ? void 0 : row.filter(cell => cell.groupIndex === groupIndex);\r\n        var {\r\n            allDayPanel: allDayPanel,\r\n            dateTable: dateTable\r\n        } = groupedData[0];\r\n        var filteredDateTable = [];\r\n        dateTable.forEach(row => {\r\n            filteredDateTable.push(filterCells(row))\r\n        });\r\n        return {\r\n            allDayPanel: filterCells(allDayPanel),\r\n            dateTable: filteredDateTable\r\n        }\r\n    }\r\n    getCellCountWithGroup(groupIndex) {\r\n        var rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this.groupedDataMap;\r\n        return dateTableGroupedMap.filter((_, index) => index <= groupIndex).reduce((previous, row) => previous + row[rowIndex].length, 0)\r\n    }\r\n    getAllDayPanel(groupIndex) {\r\n        var groupData = this.getGroupData(groupIndex);\r\n        return null === groupData || void 0 === groupData ? void 0 : groupData.allDayPanel\r\n    }\r\n    isGroupIntersectDateInterval(groupIndex, startDate, endDate) {\r\n        var groupStartDate = this.getGroupStartDate(groupIndex);\r\n        var groupEndDate = this.getGroupEndDate(groupIndex);\r\n        return startDate < groupEndDate && endDate > groupStartDate\r\n    }\r\n    findGlobalCellPosition(date) {\r\n        var groupIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\r\n        var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\r\n        var {\r\n            completeViewDataMap: completeViewDataMap,\r\n            _workspace: workspace\r\n        } = this;\r\n        var showAllDayPanel = workspace.isAllDayPanelVisible;\r\n        for (var rowIndex = 0; rowIndex < completeViewDataMap.length; rowIndex += 1) {\r\n            var currentRow = completeViewDataMap[rowIndex];\r\n            for (var columnIndex = 0; columnIndex < currentRow.length; columnIndex += 1) {\r\n                var cellData = currentRow[columnIndex];\r\n                var {\r\n                    startDate: currentStartDate,\r\n                    endDate: currentEndDate,\r\n                    groupIndex: currentGroupIndex,\r\n                    allDay: currentAllDay\r\n                } = cellData;\r\n                if (groupIndex === currentGroupIndex && allDay === !!currentAllDay && this._compareDatesAndAllDay(date, currentStartDate, currentEndDate, allDay)) {\r\n                    return {\r\n                        position: {\r\n                            columnIndex: columnIndex,\r\n                            rowIndex: showAllDayPanel && !this.isVerticalGroupedWorkspace ? rowIndex - 1 : rowIndex\r\n                        },\r\n                        cellData: cellData\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _compareDatesAndAllDay(date, cellStartDate, cellEndDate, allDay) {\r\n        var time = date.getTime();\r\n        var trimmedTime = dateUtils.trimTime(date).getTime();\r\n        var cellStartTime = cellStartDate.getTime();\r\n        var cellEndTime = cellEndDate.getTime();\r\n        return !allDay && time >= cellStartTime && time < cellEndTime || allDay && trimmedTime === cellStartTime\r\n    }\r\n    getSkippedDaysCount(groupIndex, startDate, endDate, daysCount) {\r\n        var {\r\n            dateTableGroupedMap: dateTableGroupedMap\r\n        } = this._groupedDataMapProvider.groupedDataMap;\r\n        var groupedData = dateTableGroupedMap[groupIndex];\r\n        var includedDays = 0;\r\n        for (var rowIndex = 0; rowIndex < groupedData.length; rowIndex += 1) {\r\n            for (var columnIndex = 0; columnIndex < groupedData[rowIndex].length; columnIndex += 1) {\r\n                var cell = groupedData[rowIndex][columnIndex].cellData;\r\n                if (startDate.getTime() < cell.endDate.getTime() && endDate.getTime() > cell.startDate.getTime()) {\r\n                    includedDays += 1\r\n                }\r\n            }\r\n        }\r\n        var lastCell = groupedData[groupedData.length - 1][groupedData[0].length - 1].cellData;\r\n        var lastCellStart = dateUtils.trimTime(lastCell.startDate);\r\n        var daysAfterView = Math.floor((endDate.getTime() - lastCellStart.getTime()) / dateUtils.dateToMilliseconds(\"day\"));\r\n        var deltaDays = daysAfterView > 0 ? daysAfterView : 0;\r\n        return daysCount - includedDays - deltaDays\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}